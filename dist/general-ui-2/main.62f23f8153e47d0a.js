(self.webpackChunkgeneral_ui_2 = self.webpackChunkgeneral_ui_2 || []).push([[179], { 296: (Ot, le, Ve) => { "use strict"; function V(e) { return "function" == typeof e } function ve(e) { const n = e(r => { Error.call(r), r.stack = (new Error).stack }); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n } const qt = ve(e => function (n) { e(this), this.message = n ? `${n.length} errors occurred during unsubscription:\n${n.map((r, o) => `${o + 1}) ${r.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = n }); function I(e, t) { if (e) { const n = e.indexOf(t); 0 <= n && e.splice(n, 1) } } class Me { constructor(t) { this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let t; if (!this.closed) { this.closed = !0; const { _parentage: n } = this; if (n) if (this._parentage = null, Array.isArray(n)) for (const i of n) i.remove(this); else n.remove(this); const { initialTeardown: r } = this; if (V(r)) try { r() } catch (i) { t = i instanceof qt ? i.errors : [i] } const { _finalizers: o } = this; if (o) { this._finalizers = null; for (const i of o) try { Le(i) } catch (s) { t = t ?? [], s instanceof qt ? t = [...t, ...s.errors] : t.push(s) } } if (t) throw new qt(t) } } add(t) { var n; if (t && t !== this) if (this.closed) Le(t); else { if (t instanceof Me) { if (t.closed || t._hasParent(this)) return; t._addParent(this) } (this._finalizers = null !== (n = this._finalizers) && void 0 !== n ? n : []).push(t) } } _hasParent(t) { const { _parentage: n } = this; return n === t || Array.isArray(n) && n.includes(t) } _addParent(t) { const { _parentage: n } = this; this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t } _removeParent(t) { const { _parentage: n } = this; n === t ? this._parentage = null : Array.isArray(n) && I(n, t) } remove(t) { const { _finalizers: n } = this; n && I(n, t), t instanceof Me && t._removeParent(this) } } Me.EMPTY = (() => { const e = new Me; return e.closed = !0, e })(); const nn = Me.EMPTY; function re(e) { return e instanceof Me || e && "closed" in e && V(e.remove) && V(e.add) && V(e.unsubscribe) } function Le(e) { V(e) ? e() : e.unsubscribe() } const B = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, oe = { setTimeout(e, t, ...n) { const { delegate: r } = oe; return r?.setTimeout ? r.setTimeout(e, t, ...n) : setTimeout(e, t, ...n) }, clearTimeout(e) { const { delegate: t } = oe; return (t?.clearTimeout || clearTimeout)(e) }, delegate: void 0 }; function Oe(e) { oe.setTimeout(() => { const { onUnhandledError: t } = B; if (!t) throw e; t(e) }) } function j() { } const ie = oo("C", void 0, void 0); function oo(e, t, n) { return { kind: e, value: t, error: n } } let Xe = null; function rt(e) { if (B.useDeprecatedSynchronousErrorHandling) { const t = !Xe; if (t && (Xe = { errorThrown: !1, error: null }), e(), t) { const { errorThrown: n, error: r } = Xe; if (Xe = null, n) throw r } } else e() } class rr extends Me { constructor(t) { super(), this.isStopped = !1, t ? (this.destination = t, re(t) && t.add(this)) : this.destination = Xb } static create(t, n, r) { return new An(t, n, r) } next(t) { this.isStopped ? _i(function ro(e) { return oo("N", e, void 0) }(t), this) : this._next(t) } error(t) { this.isStopped ? _i(function Pe(e) { return oo("E", void 0, e) }(t), this) : (this.isStopped = !0, this._error(t)) } complete() { this.isStopped ? _i(ie, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(t) { this.destination.next(t) } _error(t) { try { this.destination.error(t) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const Pu = Function.prototype.bind; function or(e, t) { return Pu.call(e, t) } class np { constructor(t) { this.partialObserver = t } next(t) { const { partialObserver: n } = this; if (n.next) try { n.next(t) } catch (r) { io(r) } } error(t) { const { partialObserver: n } = this; if (n.error) try { n.error(t) } catch (r) { io(r) } else io(t) } complete() { const { partialObserver: t } = this; if (t.complete) try { t.complete() } catch (n) { io(n) } } } class An extends rr { constructor(t, n, r) { let o; if (super(), V(t) || !t) o = { next: t ?? void 0, error: n ?? void 0, complete: r ?? void 0 }; else { let i; this && B.useDeprecatedNextContext ? (i = Object.create(t), i.unsubscribe = () => this.unsubscribe(), o = { next: t.next && or(t.next, i), error: t.error && or(t.error, i), complete: t.complete && or(t.complete, i) }) : o = t } this.destination = new np(o) } } function io(e) { B.useDeprecatedSynchronousErrorHandling ? function kn(e) { B.useDeprecatedSynchronousErrorHandling && Xe && (Xe.errorThrown = !0, Xe.error = e) }(e) : Oe(e) } function _i(e, t) { const { onStoppedNotification: n } = B; n && oe.setTimeout(() => n(e, t)) } const Xb = { closed: !0, next: j, error: function Ws(e) { throw e }, complete: j }, ku = "function" == typeof Symbol && Symbol.observable || "@@observable"; function Rn(e) { return e } function rp(e) { return 0 === e.length ? Rn : 1 === e.length ? e[0] : function (n) { return e.reduce((r, o) => o(r), n) } } let _e = (() => { class e { constructor(n) { n && (this._subscribe = n) } lift(n) { const r = new e; return r.source = this, r.operator = n, r } subscribe(n, r, o) { const i = function tD(e) { return e && e instanceof rr || function eD(e) { return e && V(e.next) && V(e.error) && V(e.complete) }(e) && re(e) }(n) ? n : new An(n, r, o); return rt(() => { const { operator: s, source: a } = this; i.add(s ? s.call(i, a) : a ? this._subscribe(i) : this._trySubscribe(i)) }), i } _trySubscribe(n) { try { return this._subscribe(n) } catch (r) { n.error(r) } } forEach(n, r) { return new (r = op(r))((o, i) => { const s = new An({ next: a => { try { n(a) } catch (c) { i(c), s.unsubscribe() } }, error: i, complete: o }); this.subscribe(s) }) } _subscribe(n) { var r; return null === (r = this.source) || void 0 === r ? void 0 : r.subscribe(n) } [ku]() { return this } pipe(...n) { return rp(n)(this) } toPromise(n) { return new (n = op(n))((r, o) => { let i; this.subscribe(s => i = s, s => o(s), () => r(i)) }) } } return e.create = t => new e(t), e })(); function op(e) { var t; return null !== (t = e ?? B.Promise) && void 0 !== t ? t : Promise } const nD = ve(e => function () { e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let Pt = (() => { class e extends _e { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(n) { const r = new ip(this, this); return r.operator = n, r } _throwIfClosed() { if (this.closed) throw new nD } next(n) { rt(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const r of this.currentObservers) r.next(n) } }) } error(n) { rt(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = n; const { observers: r } = this; for (; r.length;)r.shift().error(n) } }) } complete() { rt(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: n } = this; for (; n.length;)n.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var n; return (null === (n = this.observers) || void 0 === n ? void 0 : n.length) > 0 } _trySubscribe(n) { return this._throwIfClosed(), super._trySubscribe(n) } _subscribe(n) { return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n) } _innerSubscribe(n) { const { hasError: r, isStopped: o, observers: i } = this; return r || o ? nn : (this.currentObservers = null, i.push(n), new Me(() => { this.currentObservers = null, I(i, n) })) } _checkFinalizedStatuses(n) { const { hasError: r, thrownError: o, isStopped: i } = this; r ? n.error(o) : i && n.complete() } asObservable() { const n = new _e; return n.source = this, n } } return e.create = (t, n) => new ip(t, n), e })(); class ip extends Pt { constructor(t, n) { super(), this.destination = t, this.source = n } next(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.next) || void 0 === r || r.call(n, t) } error(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.error) || void 0 === r || r.call(n, t) } complete() { var t, n; null === (n = null === (t = this.destination) || void 0 === t ? void 0 : t.complete) || void 0 === n || n.call(t) } _subscribe(t) { var n, r; return null !== (r = null === (n = this.source) || void 0 === n ? void 0 : n.subscribe(t)) && void 0 !== r ? r : nn } } function sp(e) { return V(e?.lift) } function ke(e) { return t => { if (sp(t)) return t.lift(function (n) { try { return e(n, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function Se(e, t, n, r, o) { return new rD(e, t, n, r, o) } class rD extends rr { constructor(t, n, r, o, i, s) { super(t), this.onFinalize = i, this.shouldUnsubscribe = s, this._next = n ? function (a) { try { n(a) } catch (c) { t.error(c) } } : super._next, this._error = o ? function (a) { try { o(a) } catch (c) { t.error(c) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { t.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var t; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: n } = this; super.unsubscribe(), !n && (null === (t = this.onFinalize) || void 0 === t || t.call(this)) } } } function H(e, t) { return ke((n, r) => { let o = 0; n.subscribe(Se(r, i => { r.next(e.call(t, i, o++)) })) }) } function Er(e) { return this instanceof Er ? (this.v = e, this) : new Er(e) } function sD(e, t, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var o, r = n.apply(e, t || []), i = []; return o = {}, s("next"), s("throw"), s("return"), o[Symbol.asyncIterator] = function () { return this }, o; function s(f) { r[f] && (o[f] = function (h) { return new Promise(function (p, g) { i.push([f, h, p, g]) > 1 || a(f, h) }) }) } function a(f, h) { try { !function c(f) { f.value instanceof Er ? Promise.resolve(f.value.v).then(u, l) : d(i[0][2], f) }(r[f](h)) } catch (p) { d(i[0][3], p) } } function u(f) { a("next", f) } function l(f) { a("throw", f) } function d(f, h) { f(h), i.shift(), i.length && a(i[0][0], i[0][1]) } } function aD(e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var n, t = e[Symbol.asyncIterator]; return t ? t.call(e) : (e = function up(e) { var t = "function" == typeof Symbol && Symbol.iterator, n = t && e[t], r = 0; if (n) return n.call(e); if (e && "number" == typeof e.length) return { next: function () { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }(e), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function () { return this }, n); function r(i) { n[i] = e[i] && function (s) { return new Promise(function (a, c) { !function o(i, s, a, c) { Promise.resolve(c).then(function (u) { i({ value: u, done: a }) }, s) }(a, c, (s = e[i](s)).done, s.value) }) } } } const lp = e => e && "number" == typeof e.length && "function" != typeof e; function dp(e) { return V(e?.then) } function fp(e) { return V(e[ku]) } function hp(e) { return Symbol.asyncIterator && V(e?.[Symbol.asyncIterator]) } function pp(e) { return new TypeError(`You provided ${null !== e && "object" == typeof e ? "an invalid object" : `'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const gp = function uD() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function mp(e) { return V(e?.[gp]) } function yp(e) { return sD(this, arguments, function* () { const n = e.getReader(); try { for (; ;) { const { value: r, done: o } = yield Er(n.read()); if (o) return yield Er(void 0); yield yield Er(r) } } finally { n.releaseLock() } }) } function vp(e) { return V(e?.getReader) } function Wt(e) { if (e instanceof _e) return e; if (null != e) { if (fp(e)) return function lD(e) { return new _e(t => { const n = e[ku](); if (V(n.subscribe)) return n.subscribe(t); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(e); if (lp(e)) return function dD(e) { return new _e(t => { for (let n = 0; n < e.length && !t.closed; n++)t.next(e[n]); t.complete() }) }(e); if (dp(e)) return function fD(e) { return new _e(t => { e.then(n => { t.closed || (t.next(n), t.complete()) }, n => t.error(n)).then(null, Oe) }) }(e); if (hp(e)) return _p(e); if (mp(e)) return function hD(e) { return new _e(t => { for (const n of e) if (t.next(n), t.closed) return; t.complete() }) }(e); if (vp(e)) return function pD(e) { return _p(yp(e)) }(e) } throw pp(e) } function _p(e) { return new _e(t => { (function gD(e, t) { var n, r, o, i; return function oD(e, t, n, r) { return new (n || (n = Promise))(function (i, s) { function a(l) { try { u(r.next(l)) } catch (d) { s(d) } } function c(l) { try { u(r.throw(l)) } catch (d) { s(d) } } function u(l) { l.done ? i(l.value) : function o(i) { return i instanceof n ? i : new n(function (s) { s(i) }) }(l.value).then(a, c) } u((r = r.apply(e, t || [])).next()) }) }(this, void 0, void 0, function* () { try { for (n = aD(e); !(r = yield n.next()).done;)if (t.next(r.value), t.closed) return } catch (s) { o = { error: s } } finally { try { r && !r.done && (i = n.return) && (yield i.call(n)) } finally { if (o) throw o.error } } t.complete() }) })(e, t).catch(n => t.error(n)) }) } function Nn(e, t, n, r = 0, o = !1) { const i = t.schedule(function () { n(), o ? e.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (e.add(i), !o) return i } function Be(e, t, n = 1 / 0) { return V(t) ? Be((r, o) => H((i, s) => t(r, i, o, s))(Wt(e(r, o))), n) : ("number" == typeof t && (n = t), ke((r, o) => function mD(e, t, n, r, o, i, s, a) { const c = []; let u = 0, l = 0, d = !1; const f = () => { d && !c.length && !u && t.complete() }, h = g => u < r ? p(g) : c.push(g), p = g => { i && t.next(g), u++; let m = !1; Wt(n(g, l++)).subscribe(Se(t, v => { o?.(v), i ? h(v) : t.next(v) }, () => { m = !0 }, void 0, () => { if (m) try { for (u--; c.length && u < r;) { const v = c.shift(); s ? Nn(t, s, () => p(v)) : p(v) } f() } catch (v) { t.error(v) } })) }; return e.subscribe(Se(t, h, () => { d = !0, f() })), () => { a?.() } }(r, o, e, n))) } function so(e = 1 / 0) { return Be(Rn, e) } const Fn = new _e(e => e.complete()); function Ru(e) { return e[e.length - 1] } function Cp(e) { return V(Ru(e)) ? e.pop() : void 0 } function Ci(e) { return function vD(e) { return e && V(e.schedule) }(Ru(e)) ? e.pop() : void 0 } function wp(e, t = 0) { return ke((n, r) => { n.subscribe(Se(r, o => Nn(r, e, () => r.next(o), t), () => Nn(r, e, () => r.complete(), t), o => Nn(r, e, () => r.error(o), t))) }) } function bp(e, t = 0) { return ke((n, r) => { r.add(e.schedule(() => n.subscribe(r), t)) }) } function Dp(e, t) { if (!e) throw new Error("Iterable cannot be null"); return new _e(n => { Nn(n, t, () => { const r = e[Symbol.asyncIterator](); Nn(n, t, () => { r.next().then(o => { o.done ? n.complete() : n.next(o.value) }) }, 0, !0) }) }) } function Ie(e, t) { return t ? function MD(e, t) { if (null != e) { if (fp(e)) return function CD(e, t) { return Wt(e).pipe(bp(t), wp(t)) }(e, t); if (lp(e)) return function bD(e, t) { return new _e(n => { let r = 0; return t.schedule(function () { r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule()) }) }) }(e, t); if (dp(e)) return function wD(e, t) { return Wt(e).pipe(bp(t), wp(t)) }(e, t); if (hp(e)) return Dp(e, t); if (mp(e)) return function DD(e, t) { return new _e(n => { let r; return Nn(n, t, () => { r = e[gp](), Nn(n, t, () => { let o, i; try { ({ value: o, done: i } = r.next()) } catch (s) { return void n.error(s) } i ? n.complete() : n.next(o) }, 0, !0) }), () => V(r?.return) && r.return() }) }(e, t); if (vp(e)) return function ED(e, t) { return Dp(yp(e), t) }(e, t) } throw pp(e) }(e, t) : Wt(e) } function Ep(...e) { const t = Ci(e), n = function _D(e, t) { return "number" == typeof Ru(e) ? e.pop() : t }(e, 1 / 0), r = e; return r.length ? 1 === r.length ? Wt(r[0]) : so(n)(Ie(r, t)) : Fn } function Mp(e = {}) { const { connector: t = (() => new Pt), resetOnError: n = !0, resetOnComplete: r = !0, resetOnRefCountZero: o = !0 } = e; return i => { let s, a, c, u = 0, l = !1, d = !1; const f = () => { a?.unsubscribe(), a = void 0 }, h = () => { f(), s = c = void 0, l = d = !1 }, p = () => { const g = s; h(), g?.unsubscribe() }; return ke((g, m) => { u++, !d && !l && f(); const v = c = c ?? t(); m.add(() => { u--, 0 === u && !d && !l && (a = Nu(p, o)) }), v.subscribe(m), !s && u > 0 && (s = new An({ next: _ => v.next(_), error: _ => { d = !0, f(), a = Nu(h, n, _), v.error(_) }, complete: () => { l = !0, f(), a = Nu(h, r), v.complete() } }), Wt(g).subscribe(s)) })(i) } } function Nu(e, t, ...n) { if (!0 === t) return void e(); if (!1 === t) return; const r = new An({ next: () => { r.unsubscribe(), e() } }); return t(...n).subscribe(r) } function de(e) { for (let t in e) if (e[t] === de) return t; throw Error("Could not find renamed property on target object.") } function fe(e) { if ("string" == typeof e) return e; if (Array.isArray(e)) return "[" + e.map(fe).join(", ") + "]"; if (null == e) return "" + e; if (e.overriddenName) return `${e.overriddenName}`; if (e.name) return `${e.name}`; const t = e.toString(); if (null == t) return "" + t; const n = t.indexOf("\n"); return -1 === n ? t : t.substring(0, n) } function Lu(e, t) { return null == e || "" === e ? null === t ? "" : t : null == t || "" === t ? e : e + " " + t } const SD = de({ __forward_ref__: de }); function ju(e) { return e.__forward_ref__ = ju, e.toString = function () { return fe(this()) }, e } function F(e) { return function $u(e) { return "function" == typeof e && e.hasOwnProperty(SD) && e.__forward_ref__ === ju }(e) ? e() : e } class M extends Error { constructor(t, n) { super(function Gs(e, t) { return `NG0${Math.abs(e)}${t ? ": " + t.trim() : ""}` }(t, n)), this.code = t } } function $(e) { return "string" == typeof e ? e : null == e ? "" : String(e) } function Zs(e, t) { throw new M(-201, !1) } function At(e, t) { null == e && function ce(e, t, n, r) { throw new Error(`ASSERTION ERROR: ${e}` + (null == r ? "" : ` [Expected=> ${n} ${r} ${t} <=Actual]`)) }(t, e, null, "!=") } function x(e) { return { token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0 } } function _n(e) { return { providers: e.providers || [], imports: e.imports || [] } } function Ks(e) { return Sp(e, Ys) || Sp(e, Tp) } function Sp(e, t) { return e.hasOwnProperty(t) ? e[t] : null } function Ip(e) { return e && (e.hasOwnProperty(Uu) || e.hasOwnProperty(ND)) ? e[Uu] : null } const Ys = de({ \u0275prov: de }), Uu = de({ \u0275inj: de }), Tp = de({ ngInjectableDef: de }), ND = de({ ngInjectorDef: de }); var k = (() => ((k = k || {})[k.Default = 0] = "Default", k[k.Host = 1] = "Host", k[k.Self = 2] = "Self", k[k.SkipSelf = 4] = "SkipSelf", k[k.Optional = 8] = "Optional", k))(); let Vu; function Gt(e) { const t = Vu; return Vu = e, t } function xp(e, t, n) { const r = Ks(e); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : n & k.Optional ? null : void 0 !== t ? t : void Zs(fe(e)) } function ir(e) { return { toString: e }.toString() } var rn = (() => ((rn = rn || {})[rn.OnPush = 0] = "OnPush", rn[rn.Default = 1] = "Default", rn))(), Cn = (() => { return (e = Cn || (Cn = {}))[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom", Cn; var e })(); const he = (() => typeof globalThis < "u" && globalThis || typeof global < "u" && global || typeof window < "u" && window || typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self)(), ao = {}, ae = [], Qs = de({ \u0275cmp: de }), Bu = de({ \u0275dir: de }), Hu = de({ \u0275pipe: de }), Op = de({ \u0275mod: de }), jn = de({ \u0275fac: de }), wi = de({ __NG_ELEMENT_ID__: de }); let LD = 0; function ot(e) { return ir(() => { const n = !0 === e.standalone, r = {}, o = { type: e.type, providersResolver: null, decls: e.decls, vars: e.vars, factory: null, template: e.template || null, consts: e.consts || null, ngContentSelectors: e.ngContentSelectors, hostBindings: e.hostBindings || null, hostVars: e.hostVars || 0, hostAttrs: e.hostAttrs || null, contentQueries: e.contentQueries || null, declaredInputs: r, inputs: null, outputs: null, exportAs: e.exportAs || null, onPush: e.changeDetection === rn.OnPush, directiveDefs: null, pipeDefs: null, standalone: n, dependencies: n && e.dependencies || null, getStandaloneInjector: null, selectors: e.selectors || ae, viewQuery: e.viewQuery || null, features: e.features || null, data: e.data || {}, encapsulation: e.encapsulation || Cn.Emulated, id: "c" + LD++, styles: e.styles || ae, _: null, setInput: null, schemas: e.schemas || null, tView: null }, i = e.dependencies, s = e.features; return o.inputs = Ap(e.inputs, r), o.outputs = Ap(e.outputs), s && s.forEach(a => a(o)), o.directiveDefs = i ? () => ("function" == typeof i ? i() : i).map(Pp).filter(kp) : null, o.pipeDefs = i ? () => ("function" == typeof i ? i() : i).map(yt).filter(kp) : null, o }) } function Pp(e) { return ue(e) || mt(e) } function kp(e) { return null !== e } function $n(e) { return ir(() => ({ type: e.type, bootstrap: e.bootstrap || ae, declarations: e.declarations || ae, imports: e.imports || ae, exports: e.exports || ae, transitiveCompileScopes: null, schemas: e.schemas || null, id: e.id || null })) } function Ap(e, t) { if (null == e) return ao; const n = {}; for (const r in e) if (e.hasOwnProperty(r)) { let o = e[r], i = o; Array.isArray(o) && (i = o[1], o = o[0]), n[o] = r, t && (t[o] = i) } return n } const at = ot; function St(e) { return { type: e.type, name: e.name, factory: null, pure: !1 !== e.pure, standalone: !0 === e.standalone, onDestroy: e.type.prototype.ngOnDestroy || null } } function ue(e) { return e[Qs] || null } function mt(e) { return e[Bu] || null } function yt(e) { return e[Hu] || null } function Rt(e, t) { const n = e[Op] || null; if (!n && !0 === t) throw new Error(`Type ${fe(e)} does not have '\u0275mod' property.`); return n } const q = 11; function It(e) { return Array.isArray(e) && "object" == typeof e[1] } function sn(e) { return Array.isArray(e) && !0 === e[1] } function Wu(e) { return 0 != (8 & e.flags) } function ta(e) { return 2 == (2 & e.flags) } function na(e) { return 1 == (1 & e.flags) } function an(e) { return null !== e.template } function HD(e) { return 0 != (256 & e[2]) } function xr(e, t) { return e.hasOwnProperty(jn) ? e[jn] : null } class WD { constructor(t, n, r) { this.previousValue = t, this.currentValue = n, this.firstChange = r } isFirstChange() { return this.firstChange } } function sr() { return Fp } function Fp(e) { return e.type.prototype.ngOnChanges && (e.setInput = ZD), GD } function GD() { const e = jp(this), t = e?.current; if (t) { const n = e.previous; if (n === ao) e.previous = t; else for (let r in t) n[r] = t[r]; e.current = null, this.ngOnChanges(t) } } function ZD(e, t, n, r) { const o = jp(e) || function KD(e, t) { return e[Lp] = t }(e, { previous: ao, current: null }), i = o.current || (o.current = {}), s = o.previous, a = this.declaredInputs[n], c = s[a]; i[a] = new WD(c && c.currentValue, t, s === ao), e[r] = t } sr.ngInherit = !0; const Lp = "__ngSimpleChanges__"; function jp(e) { return e[Lp] || null } function je(e) { for (; Array.isArray(e);)e = e[0]; return e } function ra(e, t) { return je(t[e]) } function Ft(e, t) { return je(t[e.index]) } function Qu(e, t) { return e.data[t] } function ho(e, t) { return e[t] } function Lt(e, t) { const n = t[e]; return It(n) ? n : n[0] } function oa(e) { return 64 == (64 & e[2]) } function ar(e, t) { return null == t ? null : e[t] } function $p(e) { e[18] = 0 } function Xu(e, t) { e[5] += t; let n = e, r = e[3]; for (; null !== r && (1 === t && 1 === n[5] || -1 === t && 0 === n[5]);)r[5] += t, n = r, r = r[3] } const L = { lFrame: Qp(null), bindingsEnabled: !0 }; function Vp() { return L.bindingsEnabled } function C() { return L.lFrame.lView } function te() { return L.lFrame.tView } function He() { let e = zp(); for (; null !== e && 64 === e.type;)e = e.parent; return e } function zp() { return L.lFrame.currentTNode } function wn(e, t) { const n = L.lFrame; n.currentTNode = e, n.isParent = t } function Ju() { return L.lFrame.isParent } function el() { L.lFrame.isParent = !1 } function po() { return L.lFrame.bindingIndex++ } function Vn(e) { const t = L.lFrame, n = t.bindingIndex; return t.bindingIndex = t.bindingIndex + e, n } function lE(e, t) { const n = L.lFrame; n.bindingIndex = n.bindingRootIndex = e, tl(t) } function tl(e) { L.lFrame.currentDirectiveIndex = e } function rl(e) { L.lFrame.currentQueryIndex = e } function fE(e) { const t = e[1]; return 2 === t.type ? t.declTNode : 1 === t.type ? e[6] : null } function Kp(e, t, n) { if (n & k.SkipSelf) { let o = t, i = e; for (; !(o = o.parent, null !== o || n & k.Host || (o = fE(i), null === o || (i = i[15], 10 & o.type)));); if (null === o) return !1; t = o, e = i } const r = L.lFrame = Yp(); return r.currentTNode = t, r.lView = e, !0 } function ol(e) { const t = Yp(), n = e[1]; L.lFrame = t, t.currentTNode = n.firstChild, t.lView = e, t.tView = n, t.contextLView = e, t.bindingIndex = n.bindingStartIndex, t.inI18n = !1 } function Yp() { const e = L.lFrame, t = null === e ? null : e.child; return null === t ? Qp(e) : t } function Qp(e) { const t = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: e, child: null, inI18n: !1 }; return null !== e && (e.child = t), t } function Xp() { const e = L.lFrame; return L.lFrame = e.parent, e.currentTNode = null, e.lView = null, e } const Jp = Xp; function il() { const e = Xp(); e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0 } function _t() { return L.lFrame.selectedIndex } function cr(e) { L.lFrame.selectedIndex = e } function be() { const e = L.lFrame; return Qu(e.tView, e.selectedIndex) } function ia(e, t) { for (let n = t.directiveStart, r = t.directiveEnd; n < r; n++) { const i = e.data[n].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: c, ngAfterViewChecked: u, ngOnDestroy: l } = i; s && (e.contentHooks || (e.contentHooks = [])).push(-n, s), a && ((e.contentHooks || (e.contentHooks = [])).push(n, a), (e.contentCheckHooks || (e.contentCheckHooks = [])).push(n, a)), c && (e.viewHooks || (e.viewHooks = [])).push(-n, c), u && ((e.viewHooks || (e.viewHooks = [])).push(n, u), (e.viewCheckHooks || (e.viewCheckHooks = [])).push(n, u)), null != l && (e.destroyHooks || (e.destroyHooks = [])).push(n, l) } } function sa(e, t, n) { eg(e, t, 3, n) } function aa(e, t, n, r) { (3 & e[2]) === n && eg(e, t, n, r) } function sl(e, t) { let n = e[2]; (3 & n) === t && (n &= 2047, n += 1, e[2] = n) } function eg(e, t, n, r) { const i = r ?? -1, s = t.length - 1; let a = 0; for (let c = void 0 !== r ? 65535 & e[18] : 0; c < s; c++)if ("number" == typeof t[c + 1]) { if (a = t[c], null != r && a >= r) break } else t[c] < 0 && (e[18] += 65536), (a < i || -1 == i) && (wE(e, n, t, c), e[18] = (4294901760 & e[18]) + c + 2), c++ } function wE(e, t, n, r) { const o = n[r] < 0, i = n[r + 1], a = e[o ? -n[r] : n[r]]; if (o) { if (e[2] >> 11 < e[18] >> 16 && (3 & e[2]) === t) { e[2] += 2048; try { i.call(a) } finally { } } } else try { i.call(a) } finally { } } class Ii { constructor(t, n, r) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = n, this.injectImpl = r } } function ca(e, t, n) { let r = 0; for (; r < n.length;) { const o = n[r]; if ("number" == typeof o) { if (0 !== o) break; r++; const i = n[r++], s = n[r++], a = n[r++]; e.setAttribute(t, s, a, i) } else { const i = o, s = n[++r]; ng(i) ? e.setProperty(t, i, s) : e.setAttribute(t, i, s), r++ } } return r } function tg(e) { return 3 === e || 4 === e || 6 === e } function ng(e) { return 64 === e.charCodeAt(0) } function ua(e, t) { if (null !== t && 0 !== t.length) if (null === e || 0 === e.length) e = t.slice(); else { let n = -1; for (let r = 0; r < t.length; r++) { const o = t[r]; "number" == typeof o ? n = o : 0 === n || rg(e, n, o, null, -1 === n || 2 === n ? t[++r] : null) } } return e } function rg(e, t, n, r, o) { let i = 0, s = e.length; if (-1 === t) s = -1; else for (; i < e.length;) { const a = e[i++]; if ("number" == typeof a) { if (a === t) { s = -1; break } if (a > t) { s = i - 1; break } } } for (; i < e.length;) { const a = e[i]; if ("number" == typeof a) break; if (a === n) { if (null === r) return void (null !== o && (e[i + 1] = o)); if (r === e[i + 1]) return void (e[i + 2] = o) } i++, null !== r && i++, null !== o && i++ } -1 !== s && (e.splice(s, 0, t), i = s + 1), e.splice(i++, 0, n), null !== r && e.splice(i++, 0, r), null !== o && e.splice(i++, 0, o) } function og(e) { return -1 !== e } function go(e) { return 32767 & e } function mo(e, t) { let n = function SE(e) { return e >> 16 }(e), r = t; for (; n > 0;)r = r[15], n--; return r } let cl = !0; function la(e) { const t = cl; return cl = e, t } let IE = 0; const bn = {}; function xi(e, t) { const n = ll(e, t); if (-1 !== n) return n; const r = t[1]; r.firstCreatePass && (e.injectorIndex = t.length, ul(r.data, e), ul(t, null), ul(r.blueprint, null)); const o = da(e, t), i = e.injectorIndex; if (og(o)) { const s = go(o), a = mo(o, t), c = a[1].data; for (let u = 0; u < 8; u++)t[i + u] = a[s + u] | c[s + u] } return t[i + 8] = o, i } function ul(e, t) { e.push(0, 0, 0, 0, 0, 0, 0, 0, t) } function ll(e, t) { return -1 === e.injectorIndex || e.parent && e.parent.injectorIndex === e.injectorIndex || null === t[e.injectorIndex + 8] ? -1 : e.injectorIndex } function da(e, t) { if (e.parent && -1 !== e.parent.injectorIndex) return e.parent.injectorIndex; let n = 0, r = null, o = t; for (; null !== o;) { if (r = hg(o), null === r) return -1; if (n++, o = o[15], -1 !== r.injectorIndex) return r.injectorIndex | n << 16 } return -1 } function fa(e, t, n) { !function TE(e, t, n) { let r; "string" == typeof n ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(wi) && (r = n[wi]), null == r && (r = n[wi] = IE++); const o = 255 & r; t.data[e + (o >> 5)] |= 1 << o }(e, t, n) } function ag(e, t, n) { if (n & k.Optional || void 0 !== e) return e; Zs() } function cg(e, t, n, r) { if (n & k.Optional && void 0 === r && (r = null), 0 == (n & (k.Self | k.Host))) { const o = e[9], i = Gt(void 0); try { return o ? o.get(t, r, n & k.Optional) : xp(t, r, n & k.Optional) } finally { Gt(i) } } return ag(r, 0, n) } function ug(e, t, n, r = k.Default, o) { if (null !== e) { if (1024 & t[2]) { const s = function RE(e, t, n, r, o) { let i = e, s = t; for (; null !== i && null !== s && 1024 & s[2] && !(256 & s[2]);) { const a = lg(i, s, n, r | k.Self, bn); if (a !== bn) return a; let c = i.parent; if (!c) { const u = s[21]; if (u) { const l = u.get(n, bn, r); if (l !== bn) return l } c = hg(s), s = s[15] } i = c } return o }(e, t, n, r, bn); if (s !== bn) return s } const i = lg(e, t, n, r, bn); if (i !== bn) return i } return cg(t, n, r, o) } function lg(e, t, n, r, o) { const i = function PE(e) { if ("string" == typeof e) return e.charCodeAt(0) || 0; const t = e.hasOwnProperty(wi) ? e[wi] : void 0; return "number" == typeof t ? t >= 0 ? 255 & t : kE : t }(n); if ("function" == typeof i) { if (!Kp(t, e, r)) return r & k.Host ? ag(o, 0, r) : cg(t, n, r, o); try { const s = i(r); if (null != s || r & k.Optional) return s; Zs() } finally { Jp() } } else if ("number" == typeof i) { let s = null, a = ll(e, t), c = -1, u = r & k.Host ? t[16][6] : null; for ((-1 === a || r & k.SkipSelf) && (c = -1 === a ? da(e, t) : t[a + 8], -1 !== c && fg(r, !1) ? (s = t[1], a = go(c), t = mo(c, t)) : a = -1); -1 !== a;) { const l = t[1]; if (dg(i, a, l.data)) { const d = OE(a, t, n, s, r, u); if (d !== bn) return d } c = t[a + 8], -1 !== c && fg(r, t[1].data[a + 8] === u) && dg(i, a, t) ? (s = l, a = go(c), t = mo(c, t)) : a = -1 } } return o } function OE(e, t, n, r, o, i) { const s = t[1], a = s.data[e + 8], l = function ha(e, t, n, r, o) { const i = e.providerIndexes, s = t.data, a = 1048575 & i, c = e.directiveStart, l = i >> 20, f = o ? a + l : e.directiveEnd; for (let h = r ? a : a + l; h < f; h++) { const p = s[h]; if (h < c && n === p || h >= c && p.type === n) return h } if (o) { const h = s[c]; if (h && an(h) && h.type === n) return c } return null }(a, s, n, null == r ? ta(a) && cl : r != s && 0 != (3 & a.type), o & k.Host && i === a); return null !== l ? Oi(t, s, l, a) : bn } function Oi(e, t, n, r) { let o = e[n]; const i = t.data; if (function bE(e) { return e instanceof Ii }(o)) { const s = o; s.resolving && function ID(e, t) { const n = t ? `. Dependency path: ${t.join(" > ")} > ${e}` : ""; throw new M(-200, `Circular dependency in DI detected for ${e}${n}`) }(function se(e) { return "function" == typeof e ? e.name || e.toString() : "object" == typeof e && null != e && "function" == typeof e.type ? e.type.name || e.type.toString() : $(e) }(i[n])); const a = la(s.canSeeViewProviders); s.resolving = !0; const c = s.injectImpl ? Gt(s.injectImpl) : null; Kp(e, r, k.Default); try { o = e[n] = s.factory(void 0, i, e, r), t.firstCreatePass && n >= r.directiveStart && function CE(e, t, n) { const { ngOnChanges: r, ngOnInit: o, ngDoCheck: i } = t.type.prototype; if (r) { const s = Fp(t); (n.preOrderHooks || (n.preOrderHooks = [])).push(e, s), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(e, s) } o && (n.preOrderHooks || (n.preOrderHooks = [])).push(0 - e, o), i && ((n.preOrderHooks || (n.preOrderHooks = [])).push(e, i), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(e, i)) }(n, i[n], t) } finally { null !== c && Gt(c), la(a), s.resolving = !1, Jp() } } return o } function dg(e, t, n) { return !!(n[t + (e >> 5)] & 1 << e) } function fg(e, t) { return !(e & k.Self || e & k.Host && t) } class yo { constructor(t, n) { this._tNode = t, this._lView = n } get(t, n, r) { return ug(this._tNode, this._lView, t, r, n) } } function kE() { return new yo(He(), C()) } function hg(e) { const t = e[1], n = t.type; return 2 === n ? t.declTNode : 1 === n ? e[6] : null } const _o = "__parameters__"; function wo(e, t, n) { return ir(() => { const r = function fl(e) { return function (...n) { if (e) { const r = e(...n); for (const o in r) this[o] = r[o] } } }(t); function o(...i) { if (this instanceof o) return r.apply(this, i), this; const s = new o(...i); return a.annotation = s, a; function a(c, u, l) { const d = c.hasOwnProperty(_o) ? c[_o] : Object.defineProperty(c, _o, { value: [] })[_o]; for (; d.length <= l;)d.push(null); return (d[l] = d[l] || []).push(s), c } } return n && (o.prototype = Object.create(n.prototype)), o.prototype.ngMetadataName = e, o.annotationCls = o, o }) } class O { constructor(t, n) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof n ? this.__NG_ELEMENT_ID__ = n : void 0 !== n && (this.\u0275prov = x({ token: this, providedIn: n.providedIn || "root", factory: n.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } } function Bn(e, t) { e.forEach(n => Array.isArray(n) ? Bn(n, t) : t(n)) } function gg(e, t, n) { t >= e.length ? e.push(n) : e.splice(t, 0, n) } function pa(e, t) { return t >= e.length - 1 ? e.pop() : e.splice(t, 1)[0] } function $t(e, t, n) { let r = bo(e, t); return r >= 0 ? e[1 | r] = n : (r = ~r, function jE(e, t, n, r) { let o = e.length; if (o == t) e.push(n, r); else if (1 === o) e.push(r, e[0]), e[0] = n; else { for (o--, e.push(e[o - 1], e[o]); o > t;)e[o] = e[o - 2], o--; e[t] = n, e[t + 1] = r } }(e, r, t, n)), r } function pl(e, t) { const n = bo(e, t); if (n >= 0) return e[1 | n] } function bo(e, t) { return function vg(e, t, n) { let r = 0, o = e.length >> n; for (; o !== r;) { const i = r + (o - r >> 1), s = e[i << n]; if (t === s) return i << n; s > t ? o = i : r = i + 1 } return ~(o << n) }(e, t, 1) } const Ni = {}, ml = "__NG_DI_FLAG__", ma = "ngTempTokenPath", WE = /\n/gm, _g = "__source"; let Fi; function Do(e) { const t = Fi; return Fi = e, t } function ZE(e, t = k.Default) { if (void 0 === Fi) throw new M(-203, !1); return null === Fi ? xp(e, void 0, t) : Fi.get(e, t & k.Optional ? null : void 0, t) } function E(e, t = k.Default) { return (function FD() { return Vu }() || ZE)(F(e), t) } function Ae(e, t = k.Default) { return "number" != typeof t && (t = 0 | (t.optional && 8) | (t.host && 1) | (t.self && 2) | (t.skipSelf && 4)), E(e, t) } function yl(e) { const t = []; for (let n = 0; n < e.length; n++) { const r = F(e[n]); if (Array.isArray(r)) { if (0 === r.length) throw new M(900, !1); let o, i = k.Default; for (let s = 0; s < r.length; s++) { const a = r[s], c = KE(a); "number" == typeof c ? -1 === c ? o = a.token : i |= c : o = a } t.push(E(o, i)) } else t.push(E(r)) } return t } function Li(e, t) { return e[ml] = t, e.prototype[ml] = t, e } function KE(e) { return e[ml] } const ji = Li(wo("Optional"), 8), $i = Li(wo("SkipSelf"), 4); var Tt = (() => ((Tt = Tt || {})[Tt.Important = 1] = "Important", Tt[Tt.DashCase = 2] = "DashCase", Tt))(); const bl = new Map; let hM = 0; const El = "__ngContext__"; function lt(e, t) { It(t) ? (e[El] = t[20], function gM(e) { bl.set(e[20], e) }(t)) : e[El] = t } function Sl(e, t) { return undefined(e, t) } function Hi(e) { const t = e[3]; return sn(t) ? t[3] : t } function Il(e) { return Ug(e[13]) } function Tl(e) { return Ug(e[4]) } function Ug(e) { for (; null !== e && !sn(e);)e = e[4]; return e } function Mo(e, t, n, r, o) { if (null != r) { let i, s = !1; sn(r) ? i = r : It(r) && (s = !0, r = r[0]); const a = je(r); 0 === e && null !== n ? null == o ? Wg(t, n, a) : Or(t, n, a, o || null, !0) : 1 === e && null !== n ? Or(t, n, a, o || null, !0) : 2 === e ? function Nl(e, t, n) { const r = _a(e, t); r && function LM(e, t, n, r) { e.removeChild(t, n, r) }(e, r, t, n) }(t, a, s) : 3 === e && t.destroyNode(a), null != i && function UM(e, t, n, r, o) { const i = n[7]; i !== je(n) && Mo(t, e, r, i, o); for (let a = 10; a < n.length; a++) { const c = n[a]; zi(c[1], c, e, t, r, i) } }(t, e, i, n, o) } } function Ol(e, t, n) { return e.createElement(t, n) } function Bg(e, t) { const n = e[9], r = n.indexOf(t), o = t[3]; 512 & t[2] && (t[2] &= -513, Xu(o, -1)), n.splice(r, 1) } function Pl(e, t) { if (e.length <= 10) return; const n = 10 + t, r = e[n]; if (r) { const o = r[17]; null !== o && o !== e && Bg(o, r), t > 0 && (e[n - 1][4] = r[4]); const i = pa(e, 10 + t); !function xM(e, t) { zi(e, t, t[q], 2, null, null), t[0] = null, t[6] = null }(r[1], r); const s = i[19]; null !== s && s.detachView(i[1]), r[3] = null, r[4] = null, r[2] &= -65 } return r } function Hg(e, t) { if (!(128 & t[2])) { const n = t[q]; n.destroyNode && zi(e, t, n, 3, null, null), function kM(e) { let t = e[13]; if (!t) return kl(e[1], e); for (; t;) { let n = null; if (It(t)) n = t[13]; else { const r = t[10]; r && (n = r) } if (!n) { for (; t && !t[4] && t !== e;)It(t) && kl(t[1], t), t = t[3]; null === t && (t = e), It(t) && kl(t[1], t), n = t && t[4] } t = n } }(t) } } function kl(e, t) { if (!(128 & t[2])) { t[2] &= -65, t[2] |= 128, function FM(e, t) { let n; if (null != e && null != (n = e.destroyHooks)) for (let r = 0; r < n.length; r += 2) { const o = t[n[r]]; if (!(o instanceof Ii)) { const i = n[r + 1]; if (Array.isArray(i)) for (let s = 0; s < i.length; s += 2) { const a = o[i[s]], c = i[s + 1]; try { c.call(a) } finally { } } else try { i.call(o) } finally { } } } }(e, t), function NM(e, t) { const n = e.cleanup, r = t[7]; let o = -1; if (null !== n) for (let i = 0; i < n.length - 1; i += 2)if ("string" == typeof n[i]) { const s = n[i + 1], a = "function" == typeof s ? s(t) : je(t[s]), c = r[o = n[i + 2]], u = n[i + 3]; "boolean" == typeof u ? a.removeEventListener(n[i], c, u) : u >= 0 ? r[o = u]() : r[o = -u].unsubscribe(), i += 2 } else { const s = r[o = n[i + 1]]; n[i].call(s) } if (null !== r) { for (let i = o + 1; i < r.length; i++)(0, r[i])(); t[7] = null } }(e, t), 1 === t[1].type && t[q].destroy(); const n = t[17]; if (null !== n && sn(t[3])) { n !== t[3] && Bg(n, t); const r = t[19]; null !== r && r.detachView(e) } !function mM(e) { bl.delete(e[20]) }(t) } } function zg(e, t, n) { return function qg(e, t, n) { let r = t; for (; null !== r && 40 & r.type;)r = (t = r).parent; if (null === r) return n[0]; if (2 & r.flags) { const o = e.data[r.directiveStart].encapsulation; if (o === Cn.None || o === Cn.Emulated) return null } return Ft(r, n) }(e, t.parent, n) } function Or(e, t, n, r, o) { e.insertBefore(t, n, r, o) } function Wg(e, t, n) { e.appendChild(t, n) } function Gg(e, t, n, r, o) { null !== r ? Or(e, t, n, r, o) : Wg(e, t, n) } function _a(e, t) { return e.parentNode(t) } let ba, $l, Yg = function Kg(e, t, n) { return 40 & e.type ? Ft(e, n) : null }; function Ca(e, t, n, r) { const o = zg(e, r, t), i = t[q], a = function Zg(e, t, n) { return Yg(e, t, n) }(r.parent || t[6], r, t); if (null != o) if (Array.isArray(n)) for (let c = 0; c < n.length; c++)Gg(i, o, n[c], a, !1); else Gg(i, o, n, a, !1) } function wa(e, t) { if (null !== t) { const n = t.type; if (3 & n) return Ft(t, e); if (4 & n) return Rl(-1, e[t.index]); if (8 & n) { const r = t.child; if (null !== r) return wa(e, r); { const o = e[t.index]; return sn(o) ? Rl(-1, o) : je(o) } } if (32 & n) return Sl(t, e)() || je(e[t.index]); { const r = Xg(e, t); return null !== r ? Array.isArray(r) ? r[0] : wa(Hi(e[16]), r) : wa(e, t.next) } } return null } function Xg(e, t) { return null !== t ? e[16][6].projection[t.projection] : null } function Rl(e, t) { const n = 10 + e + 1; if (n < t.length) { const r = t[n], o = r[1].firstChild; if (null !== o) return wa(r, o) } return t[7] } function Fl(e, t, n, r, o, i, s) { for (; null != n;) { const a = r[n.index], c = n.type; if (s && 0 === t && (a && lt(je(a), r), n.flags |= 4), 64 != (64 & n.flags)) if (8 & c) Fl(e, t, n.child, r, o, i, !1), Mo(t, e, o, a, i); else if (32 & c) { const u = Sl(n, r); let l; for (; l = u();)Mo(t, e, o, l, i); Mo(t, e, o, a, i) } else 16 & c ? Jg(e, t, r, n, o, i) : Mo(t, e, o, a, i); n = s ? n.projectionNext : n.next } } function zi(e, t, n, r, o, i) { Fl(n, r, e.firstChild, t, o, i, !1) } function Jg(e, t, n, r, o, i) { const s = n[16], c = s[6].projection[r.projection]; if (Array.isArray(c)) for (let u = 0; u < c.length; u++)Mo(t, e, o, c[u], i); else Fl(e, t, c, s[3], o, i, !0) } function em(e, t, n) { e.setAttribute(t, "style", n) } function Ll(e, t, n) { "" === n ? e.removeAttribute(t, "class") : e.setAttribute(t, "class", n) } function Pr(e) { return function jl() { if (void 0 === ba && (ba = null, he.trustedTypes)) try { ba = he.trustedTypes.createPolicy("angular", { createHTML: e => e, createScript: e => e, createScriptURL: e => e }) } catch { } return ba }()?.createHTML(e) || e } class kr { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)` } } class WM extends kr { getTypeName() { return "HTML" } } class GM extends kr { getTypeName() { return "Style" } } class ZM extends kr { getTypeName() { return "Script" } } class KM extends kr { getTypeName() { return "URL" } } class YM extends kr { getTypeName() { return "ResourceURL" } } function Ut(e) { return e instanceof kr ? e.changingThisBreaksApplicationSecurity : e } function Dn(e, t) { const n = function QM(e) { return e instanceof kr && e.getTypeName() || null }(e); if (null != n && n !== t) { if ("ResourceURL" === n && "URL" === t) return !0; throw new Error(`Required a safe ${t}, got a ${n} (see https://g.co/ng/security#xss)`) } return n === t } class rS { constructor(t) { this.inertDocumentHelper = t } getInertBodyElement(t) { t = "<body><remove></remove>" + t; try { const n = (new window.DOMParser).parseFromString(Pr(t), "text/html").body; return null === n ? this.inertDocumentHelper.getInertBodyElement(t) : (n.removeChild(n.firstChild), n) } catch { return null } } } class oS { constructor(t) { if (this.defaultDoc = t, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), null == this.inertDocument.body) { const n = this.inertDocument.createElement("html"); this.inertDocument.appendChild(n); const r = this.inertDocument.createElement("body"); n.appendChild(r) } } getInertBodyElement(t) { const n = this.inertDocument.createElement("template"); if ("content" in n) return n.innerHTML = Pr(t), n; const r = this.inertDocument.createElement("body"); return r.innerHTML = Pr(t), this.defaultDoc.documentMode && this.stripCustomNsAttrs(r), r } stripCustomNsAttrs(t) { const n = t.attributes; for (let o = n.length - 1; 0 < o; o--) { const s = n.item(o).name; ("xmlns:ns1" === s || 0 === s.indexOf("ns1:")) && t.removeAttribute(s) } let r = t.firstChild; for (; r;)r.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(r), r = r.nextSibling } } const sS = /^(?:(?:https?|mailto|data|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi; function Ea(e) { return (e = String(e)).match(sS) ? e : "unsafe:" + e } function Hn(e) { const t = {}; for (const n of e.split(",")) t[n] = !0; return t } function qi(...e) { const t = {}; for (const n of e) for (const r in n) n.hasOwnProperty(r) && (t[r] = !0); return t } const sm = Hn("area,br,col,hr,img,wbr"), am = Hn("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), cm = Hn("rp,rt"), Vl = qi(sm, qi(am, Hn("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), qi(cm, Hn("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), qi(cm, am)), Bl = Hn("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), um = qi(Bl, Hn("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), Hn("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), aS = Hn("script,style,template"); class cS { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(t) { let n = t.firstChild, r = !0; for (; n;)if (n.nodeType === Node.ELEMENT_NODE ? r = this.startElement(n) : n.nodeType === Node.TEXT_NODE ? this.chars(n.nodeValue) : this.sanitizedSomething = !0, r && n.firstChild) n = n.firstChild; else for (; n;) { n.nodeType === Node.ELEMENT_NODE && this.endElement(n); let o = this.checkClobberedElement(n, n.nextSibling); if (o) { n = o; break } n = this.checkClobberedElement(n, n.parentNode) } return this.buf.join("") } startElement(t) { const n = t.nodeName.toLowerCase(); if (!Vl.hasOwnProperty(n)) return this.sanitizedSomething = !0, !aS.hasOwnProperty(n); this.buf.push("<"), this.buf.push(n); const r = t.attributes; for (let o = 0; o < r.length; o++) { const i = r.item(o), s = i.name, a = s.toLowerCase(); if (!um.hasOwnProperty(a)) { this.sanitizedSomething = !0; continue } let c = i.value; Bl[a] && (c = Ea(c)), this.buf.push(" ", s, '="', lm(c), '"') } return this.buf.push(">"), !0 } endElement(t) { const n = t.nodeName.toLowerCase(); Vl.hasOwnProperty(n) && !sm.hasOwnProperty(n) && (this.buf.push("</"), this.buf.push(n), this.buf.push(">")) } chars(t) { this.buf.push(lm(t)) } checkClobberedElement(t, n) { if (n && (t.compareDocumentPosition(n) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`); return n } } const uS = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, lS = /([^\#-~ |!])/g; function lm(e) { return e.replace(/&/g, "&amp;").replace(uS, function (t) { return "&#" + (1024 * (t.charCodeAt(0) - 55296) + (t.charCodeAt(1) - 56320) + 65536) + ";" }).replace(lS, function (t) { return "&#" + t.charCodeAt(0) + ";" }).replace(/</g, "&lt;").replace(/>/g, "&gt;") } let Ma; function dm(e, t) { let n = null; try { Ma = Ma || function im(e) { const t = new oS(e); return function iS() { try { return !!(new window.DOMParser).parseFromString(Pr(""), "text/html") } catch { return !1 } }() ? new rS(t) : t }(e); let r = t ? String(t) : ""; n = Ma.getInertBodyElement(r); let o = 5, i = r; do { if (0 === o) throw new Error("Failed to sanitize html because the input is unstable"); o--, r = i, i = n.innerHTML, n = Ma.getInertBodyElement(r) } while (r !== i); return Pr((new cS).sanitizeChildren(Hl(n) || n)) } finally { if (n) { const r = Hl(n) || n; for (; r.firstChild;)r.removeChild(r.firstChild) } } } function Hl(e) { return "content" in e && function dS(e) { return e.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === e.nodeName }(e) ? e.content : null } var ge = (() => ((ge = ge || {})[ge.NONE = 0] = "NONE", ge[ge.HTML = 1] = "HTML", ge[ge.STYLE = 2] = "STYLE", ge[ge.SCRIPT = 3] = "SCRIPT", ge[ge.URL = 4] = "URL", ge[ge.RESOURCE_URL = 5] = "RESOURCE_URL", ge))(); function zn(e) { const t = function Wi() { const e = C(); return e && e[12] }(); return t ? t.sanitize(ge.URL, e) || "" : Dn(e, "URL") ? Ut(e) : Ea($(e)) } const zl = new O("ENVIRONMENT_INITIALIZER"), hm = new O("INJECTOR", -1), pm = new O("INJECTOR_DEF_TYPES"); class gm { get(t, n = Ni) { if (n === Ni) { const r = new Error(`NullInjectorError: No provider for ${fe(t)}!`); throw r.name = "NullInjectorError", r } return n } } function _S(...e) { return { \u0275providers: mm(0, e) } } function mm(e, ...t) { const n = [], r = new Set; let o; return Bn(t, i => { const s = i; ql(s, n, [], r) && (o || (o = []), o.push(s)) }), void 0 !== o && ym(o, n), n } function ym(e, t) { for (let n = 0; n < e.length; n++) { const { providers: o } = e[n]; Bn(o, i => { t.push(i) }) } } function ql(e, t, n, r) { if (!(e = F(e))) return !1; let o = null, i = Ip(e); const s = !i && ue(e); if (i || s) { if (s && !s.standalone) return !1; o = e } else { const c = e.ngModule; if (i = Ip(c), !i) return !1; o = c } const a = r.has(o); if (s) { if (a) return !1; if (r.add(o), s.dependencies) { const c = "function" == typeof s.dependencies ? s.dependencies() : s.dependencies; for (const u of c) ql(u, t, n, r) } } else { if (!i) return !1; { if (null != i.imports && !a) { let u; r.add(o); try { Bn(i.imports, l => { ql(l, t, n, r) && (u || (u = []), u.push(l)) }) } finally { } void 0 !== u && ym(u, t) } if (!a) { const u = xr(o) || (() => new o); t.push({ provide: o, useFactory: u, deps: ae }, { provide: pm, useValue: o, multi: !0 }, { provide: zl, useValue: () => E(o), multi: !0 }) } const c = i.providers; null == c || a || Bn(c, l => { t.push(l) }) } } return o !== e && void 0 !== e.providers } const CS = de({ provide: String, useValue: de }); function Wl(e) { return null !== e && "object" == typeof e && CS in e } function Ar(e) { return "function" == typeof e } const Gl = new O("Set Injector scope."), Sa = {}, bS = {}; let Zl; function Ia() { return void 0 === Zl && (Zl = new gm), Zl } class lr { } class Cm extends lr { constructor(t, n, r, o) { super(), this.parent = n, this.source = r, this.scopes = o, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, Yl(t, s => this.processProvider(s)), this.records.set(hm, So(void 0, this)), o.has("environment") && this.records.set(lr, So(void 0, this)); const i = this.records.get(Gl); null != i && "string" == typeof i.value && this.scopes.add(i.value), this.injectorDefTypes = new Set(this.get(pm.multi, ae, k.Self)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { for (const t of this._ngOnDestroyHooks) t.ngOnDestroy(); for (const t of this._onDestroyHooks) t() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear(), this._onDestroyHooks.length = 0 } } onDestroy(t) { this._onDestroyHooks.push(t) } runInContext(t) { this.assertNotDestroyed(); const n = Do(this), r = Gt(void 0); try { return t() } finally { Do(n), Gt(r) } } get(t, n = Ni, r = k.Default) { this.assertNotDestroyed(); const o = Do(this), i = Gt(void 0); try { if (!(r & k.SkipSelf)) { let a = this.records.get(t); if (void 0 === a) { const c = function IS(e) { return "function" == typeof e || "object" == typeof e && e instanceof O }(t) && Ks(t); a = c && this.injectableDefInScope(c) ? So(Kl(t), Sa) : null, this.records.set(t, a) } if (null != a) return this.hydrate(t, a) } return (r & k.Self ? Ia() : this.parent).get(t, n = r & k.Optional && n === Ni ? null : n) } catch (s) { if ("NullInjectorError" === s.name) { if ((s[ma] = s[ma] || []).unshift(fe(t)), o) throw s; return function YE(e, t, n, r) { const o = e[ma]; throw t[_g] && o.unshift(t[_g]), e.message = function QE(e, t, n, r = null) { e = e && "\n" === e.charAt(0) && "\u0275" == e.charAt(1) ? e.slice(2) : e; let o = fe(t); if (Array.isArray(t)) o = t.map(fe).join(" -> "); else if ("object" == typeof t) { let i = []; for (let s in t) if (t.hasOwnProperty(s)) { let a = t[s]; i.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : fe(a))) } o = `{${i.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${o}]: ${e.replace(WE, "\n  ")}` }("\n" + e.message, o, n, r), e.ngTokenPath = o, e[ma] = null, e }(s, t, "R3InjectorError", this.source) } throw s } finally { Gt(i), Do(o) } } resolveInjectorInitializers() { const t = Do(this), n = Gt(void 0); try { const r = this.get(zl.multi, ae, k.Self); for (const o of r) o() } finally { Do(t), Gt(n) } } toString() { const t = [], n = this.records; for (const r of n.keys()) t.push(fe(r)); return `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new M(205, !1) } processProvider(t) { let n = Ar(t = F(t)) ? t : F(t && t.provide); const r = function ES(e) { return Wl(e) ? So(void 0, e.useValue) : So(function wm(e, t, n) { let r; if (Ar(e)) { const o = F(e); return xr(o) || Kl(o) } if (Wl(e)) r = () => F(e.useValue); else if (function _m(e) { return !(!e || !e.useFactory) }(e)) r = () => e.useFactory(...yl(e.deps || [])); else if (function vm(e) { return !(!e || !e.useExisting) }(e)) r = () => E(F(e.useExisting)); else { const o = F(e && (e.useClass || e.provide)); if (!function MS(e) { return !!e.deps }(e)) return xr(o) || Kl(o); r = () => new o(...yl(e.deps)) } return r }(e), Sa) }(t); if (Ar(t) || !0 !== t.multi) this.records.get(n); else { let o = this.records.get(n); o || (o = So(void 0, Sa, !0), o.factory = () => yl(o.multi), this.records.set(n, o)), n = t, o.multi.push(t) } this.records.set(n, r) } hydrate(t, n) { return n.value === Sa && (n.value = bS, n.value = n.factory()), "object" == typeof n.value && n.value && function SS(e) { return null !== e && "object" == typeof e && "function" == typeof e.ngOnDestroy }(n.value) && this._ngOnDestroyHooks.add(n.value), n.value } injectableDefInScope(t) { if (!t.providedIn) return !1; const n = F(t.providedIn); return "string" == typeof n ? "any" === n || this.scopes.has(n) : this.injectorDefTypes.has(n) } } function Kl(e) { const t = Ks(e), n = null !== t ? t.factory : xr(e); if (null !== n) return n; if (e instanceof O) throw new M(204, !1); if (e instanceof Function) return function DS(e) { const t = e.length; if (t > 0) throw function Ri(e, t) { const n = []; for (let r = 0; r < e; r++)n.push(t); return n }(t, "?"), new M(204, !1); const n = function AD(e) { const t = e && (e[Ys] || e[Tp]); if (t) { const n = function RD(e) { if (e.hasOwnProperty("name")) return e.name; const t = ("" + e).match(/^function\s*([^\s(]+)/); return null === t ? "" : t[1] }(e); return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`), t } return null }(e); return null !== n ? () => n.factory(e) : () => new e }(e); throw new M(204, !1) } function So(e, t, n = !1) { return { factory: e, value: t, multi: n ? [] : void 0 } } function TS(e) { return !!e.\u0275providers } function Yl(e, t) { for (const n of e) Array.isArray(n) ? Yl(n, t) : TS(n) ? Yl(n.\u0275providers, t) : t(n) } class bm { } class PS { resolveComponentFactory(t) { throw function OS(e) { const t = Error(`No component factory found for ${fe(e)}. Did you add it to @NgModule.entryComponents?`); return t.ngComponent = e, t }(t) } } let Gi = (() => { class e { } return e.NULL = new PS, e })(); function kS() { return Io(He(), C()) } function Io(e, t) { return new dr(Ft(e, t)) } let dr = (() => { class e { constructor(n) { this.nativeElement = n } } return e.__NG_ELEMENT_ID__ = kS, e })(); class Em { } let Ta = (() => { class e { } return e.__NG_ELEMENT_ID__ = () => function RS() { const e = C(), n = Lt(He().index, e); return (It(n) ? n : e)[q] }(), e })(), NS = (() => { class e { } return e.\u0275prov = x({ token: e, providedIn: "root", factory: () => null }), e })(); class xa { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const Mm = new xa("14.3.0"), Ql = {}; function Jl(e) { return e.ngOriginalError } class To { constructor() { this._console = console } handleError(t) { const n = this._findOriginalError(t); this._console.error("ERROR", t), n && this._console.error("ORIGINAL ERROR", n) } _findOriginalError(t) { let n = t && Jl(t); for (; n && Jl(n);)n = Jl(n); return n || null } } function Sm(e) { return e.ownerDocument.defaultView } function qn(e) { return e instanceof Function ? e() : e } function Tm(e, t, n) { let r = e.length; for (; ;) { const o = e.indexOf(t, n); if (-1 === o) return o; if (0 === o || e.charCodeAt(o - 1) <= 32) { const i = t.length; if (o + i === r || e.charCodeAt(o + i) <= 32) return o } n = o + 1 } } const xm = "ng-template"; function qS(e, t, n) { let r = 0; for (; r < e.length;) { let o = e[r++]; if (n && "class" === o) { if (o = e[r], -1 !== Tm(o.toLowerCase(), t, 0)) return !0 } else if (1 === o) { for (; r < e.length && "string" == typeof (o = e[r++]);)if (o.toLowerCase() === t) return !0; return !1 } } return !1 } function Om(e) { return 4 === e.type && e.value !== xm } function WS(e, t, n) { return t === (4 !== e.type || n ? e.value : xm) } function GS(e, t, n) { let r = 4; const o = e.attrs || [], i = function YS(e) { for (let t = 0; t < e.length; t++)if (tg(e[t])) return t; return e.length }(o); let s = !1; for (let a = 0; a < t.length; a++) { const c = t[a]; if ("number" != typeof c) { if (!s) if (4 & r) { if (r = 2 | 1 & r, "" !== c && !WS(e, c, n) || "" === c && 1 === t.length) { if (cn(r)) return !1; s = !0 } } else { const u = 8 & r ? c : t[++a]; if (8 & r && null !== e.attrs) { if (!qS(e.attrs, u, n)) { if (cn(r)) return !1; s = !0 } continue } const d = ZS(8 & r ? "class" : c, o, Om(e), n); if (-1 === d) { if (cn(r)) return !1; s = !0; continue } if ("" !== u) { let f; f = d > i ? "" : o[d + 1].toLowerCase(); const h = 8 & r ? f : null; if (h && -1 !== Tm(h, u, 0) || 2 & r && u !== f) { if (cn(r)) return !1; s = !0 } } } } else { if (!s && !cn(r) && !cn(c)) return !1; if (s && cn(c)) continue; s = !1, r = c | 1 & r } } return cn(r) || s } function cn(e) { return 0 == (1 & e) } function ZS(e, t, n, r) { if (null === t) return -1; let o = 0; if (r || !n) { let i = !1; for (; o < t.length;) { const s = t[o]; if (s === e) return o; if (3 === s || 6 === s) i = !0; else { if (1 === s || 2 === s) { let a = t[++o]; for (; "string" == typeof a;)a = t[++o]; continue } if (4 === s) break; if (0 === s) { o += 4; continue } } o += i ? 1 : 2 } return -1 } return function QS(e, t) { let n = e.indexOf(4); if (n > -1) for (n++; n < e.length;) { const r = e[n]; if ("number" == typeof r) return -1; if (r === t) return n; n++ } return -1 }(t, e) } function Pm(e, t, n = !1) { for (let r = 0; r < t.length; r++)if (GS(e, t[r], n)) return !0; return !1 } function km(e, t) { return e ? ":not(" + t.trim() + ")" : t } function JS(e) { let t = e[0], n = 1, r = 2, o = "", i = !1; for (; n < e.length;) { let s = e[n]; if ("string" == typeof s) if (2 & r) { const a = e[++n]; o += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & r ? o += "." + s : 4 & r && (o += " " + s); else "" !== o && !cn(s) && (t += km(i, o), o = ""), r = s, i = i || !cn(r); n++ } return "" !== o && (t += km(i, o)), t } const U = {}; function A(e) { Am(te(), C(), _t() + e, !1) } function Am(e, t, n, r) { if (!r) if (3 == (3 & t[2])) { const i = e.preOrderCheckHooks; null !== i && sa(t, i, n) } else { const i = e.preOrderHooks; null !== i && aa(t, i, 0, n) } cr(n) } function Lm(e, t = null, n = null, r) { const o = jm(e, t, n, r); return o.resolveInjectorInitializers(), o } function jm(e, t = null, n = null, r, o = new Set) { const i = [n || ae, _S(e)]; return r = r || ("object" == typeof e ? void 0 : fe(e)), new Cm(i, t || Ia(), r || null, o) } let Vt = (() => { class e { static create(n, r) { if (Array.isArray(n)) return Lm({ name: "" }, r, n, ""); { const o = n.name ?? ""; return Lm({ name: o }, n.parent, n.providers, o) } } } return e.THROW_IF_NOT_FOUND = Ni, e.NULL = new gm, e.\u0275prov = x({ token: e, providedIn: "any", factory: () => E(hm) }), e.__NG_ELEMENT_ID__ = -1, e })(); function S(e, t = k.Default) { const n = C(); return null === n ? E(e, t) : ug(He(), n, F(e), t) } function od() { throw new Error("invalid") } function Pa(e, t) { return e << 17 | t << 2 } function un(e) { return e >> 17 & 32767 } function id(e) { return 2 | e } function Wn(e) { return (131068 & e) >> 2 } function sd(e, t) { return -131069 & e | t << 2 } function ad(e) { return 1 | e } function ty(e, t) { const n = e.contentQueries; if (null !== n) for (let r = 0; r < n.length; r += 2) { const o = n[r], i = n[r + 1]; if (-1 !== i) { const s = e.data[i]; rl(o), s.contentQueries(2, t[i], i) } } } function Ra(e, t, n, r, o, i, s, a, c, u, l) { const d = t.blueprint.slice(); return d[0] = o, d[2] = 76 | r, (null !== l || e && 1024 & e[2]) && (d[2] |= 1024), $p(d), d[3] = d[15] = e, d[8] = n, d[10] = s || e && e[10], d[q] = a || e && e[q], d[12] = c || e && e[12] || null, d[9] = u || e && e[9] || null, d[6] = i, d[20] = function pM() { return hM++ }(), d[21] = l, d[16] = 2 == t.type ? e[16] : d, d } function Po(e, t, n, r, o) { let i = e.data[t]; if (null === i) i = function gd(e, t, n, r, o) { const i = zp(), s = Ju(), c = e.data[t] = function NI(e, t, n, r, o, i) { return { type: n, index: r, insertBeforeIndex: null, injectorIndex: t ? t.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: o, attrs: i, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: t, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, s ? i : i && i.parent, n, t, r, o); return null === e.firstChild && (e.firstChild = c), null !== i && (s ? null == i.child && null !== c.parent && (i.child = c) : null === i.next && (i.next = c)), c }(e, t, n, r, o), function uE() { return L.lFrame.inI18n }() && (i.flags |= 64); else if (64 & i.type) { i.type = n, i.value = r, i.attrs = o; const s = function Si() { const e = L.lFrame, t = e.currentTNode; return e.isParent ? t : t.parent }(); i.injectorIndex = null === s ? -1 : s.injectorIndex } return wn(i, !0), i } function ko(e, t, n, r) { if (0 === n) return -1; const o = t.length; for (let i = 0; i < n; i++)t.push(r), e.blueprint.push(r), e.data.push(null); return o } function md(e, t, n) { ol(t); try { const r = e.viewQuery; null !== r && Ed(1, r, n); const o = e.template; null !== o && ny(e, t, o, 1, n), e.firstCreatePass && (e.firstCreatePass = !1), e.staticContentQueries && ty(e, t), e.staticViewQueries && Ed(2, e.viewQuery, n); const i = e.components; null !== i && function kI(e, t) { for (let n = 0; n < t.length; n++)QI(e, t[n]) }(t, i) } catch (r) { throw e.firstCreatePass && (e.incompleteFirstPass = !0, e.firstCreatePass = !1), r } finally { t[2] &= -5, il() } } function Na(e, t, n, r) { const o = t[2]; if (128 != (128 & o)) { ol(t); try { $p(t), function Wp(e) { return L.lFrame.bindingIndex = e }(e.bindingStartIndex), null !== n && ny(e, t, n, 2, r); const s = 3 == (3 & o); if (s) { const u = e.preOrderCheckHooks; null !== u && sa(t, u, null) } else { const u = e.preOrderHooks; null !== u && aa(t, u, 0, null), sl(t, 0) } if (function KI(e) { for (let t = Il(e); null !== t; t = Tl(t)) { if (!t[2]) continue; const n = t[9]; for (let r = 0; r < n.length; r++) { const o = n[r], i = o[3]; 0 == (512 & o[2]) && Xu(i, 1), o[2] |= 512 } } }(t), function ZI(e) { for (let t = Il(e); null !== t; t = Tl(t))for (let n = 10; n < t.length; n++) { const r = t[n], o = r[1]; oa(r) && Na(o, r, o.template, r[8]) } }(t), null !== e.contentQueries && ty(e, t), s) { const u = e.contentCheckHooks; null !== u && sa(t, u) } else { const u = e.contentHooks; null !== u && aa(t, u, 1), sl(t, 1) } !function OI(e, t) { const n = e.hostBindingOpCodes; if (null !== n) try { for (let r = 0; r < n.length; r++) { const o = n[r]; if (o < 0) cr(~o); else { const i = o, s = n[++r], a = n[++r]; lE(s, i), a(2, t[i]) } } } finally { cr(-1) } }(e, t); const a = e.components; null !== a && function PI(e, t) { for (let n = 0; n < t.length; n++)YI(e, t[n]) }(t, a); const c = e.viewQuery; if (null !== c && Ed(2, c, r), s) { const u = e.viewCheckHooks; null !== u && sa(t, u) } else { const u = e.viewHooks; null !== u && aa(t, u, 2), sl(t, 2) } !0 === e.firstUpdatePass && (e.firstUpdatePass = !1), t[2] &= -41, 512 & t[2] && (t[2] &= -513, Xu(t[3], -1)) } finally { il() } } } function ny(e, t, n, r, o) { const i = _t(), s = 2 & r; try { cr(-1), s && t.length > 22 && Am(e, t, 22, !1), n(r, o) } finally { cr(i) } } function ry(e, t, n) { if (Wu(t)) { const o = t.directiveEnd; for (let i = t.directiveStart; i < o; i++) { const s = e.data[i]; s.contentQueries && s.contentQueries(1, n[i], i) } } } function yd(e, t, n) { !Vp() || (function UI(e, t, n, r) { const o = n.directiveStart, i = n.directiveEnd; e.firstCreatePass || xi(n, t), lt(r, t); const s = n.initialInputs; for (let a = o; a < i; a++) { const c = e.data[a], u = an(c); u && qI(t, n, c); const l = Oi(t, e, a, n); lt(l, t), null !== s && WI(0, a - o, l, c, 0, s), u && (Lt(n.index, t)[8] = l) } }(e, t, n, Ft(n, t)), 128 == (128 & n.flags) && function VI(e, t, n) { const r = n.directiveStart, o = n.directiveEnd, i = n.index, s = function dE() { return L.lFrame.currentDirectiveIndex }(); try { cr(i); for (let a = r; a < o; a++) { const c = e.data[a], u = t[a]; tl(a), (null !== c.hostBindings || 0 !== c.hostVars || null !== c.hostAttrs) && ly(c, u) } } finally { cr(-1), tl(s) } }(e, t, n)) } function vd(e, t, n = Ft) { const r = t.localNames; if (null !== r) { let o = t.index + 1; for (let i = 0; i < r.length; i += 2) { const s = r[i + 1], a = -1 === s ? n(t, e) : e[s]; e[o++] = a } } } function oy(e) { const t = e.tView; return null === t || t.incompleteFirstPass ? e.tView = _d(1, null, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts) : t } function _d(e, t, n, r, o, i, s, a, c, u) { const l = 22 + r, d = l + o, f = function AI(e, t) { const n = []; for (let r = 0; r < t; r++)n.push(r < e ? null : U); return n }(l, d), h = "function" == typeof u ? u() : u; return f[1] = { type: e, blueprint: f, template: n, queries: null, viewQuery: a, declTNode: t, data: f.slice().fill(null, l), bindingStartIndex: l, expandoStartIndex: d, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof i ? i() : i, pipeRegistry: "function" == typeof s ? s() : s, firstChild: null, schemas: c, consts: h, incompleteFirstPass: !1 } } function sy(e, t, n) { for (let r in e) if (e.hasOwnProperty(r)) { const o = e[r]; (n = null === n ? {} : n).hasOwnProperty(r) ? n[r].push(t, o) : n[r] = [t, o] } return n } function ay(e, t) { const r = t.directiveEnd, o = e.data, i = t.attrs, s = []; let a = null, c = null; for (let u = t.directiveStart; u < r; u++) { const l = o[u], d = l.inputs, f = null === i || Om(t) ? null : GI(d, i); s.push(f), a = sy(d, u, a), c = sy(l.outputs, u, c) } null !== a && (a.hasOwnProperty("class") && (t.flags |= 16), a.hasOwnProperty("style") && (t.flags |= 32)), t.initialInputs = s, t.inputs = a, t.outputs = c } function Bt(e, t, n, r, o, i, s, a) { const c = Ft(t, n); let l, u = t.inputs; !a && null != u && (l = u[r]) ? (Md(e, n, l, r, o), ta(t) && cy(n, t.index)) : 3 & t.type && (r = function FI(e) { return "class" === e ? "className" : "for" === e ? "htmlFor" : "formaction" === e ? "formAction" : "innerHtml" === e ? "innerHTML" : "readonly" === e ? "readOnly" : "tabindex" === e ? "tabIndex" : e }(r), o = null != s ? s(o, t.value || "", r) : o, i.setProperty(c, r, o)) } function cy(e, t) { const n = Lt(t, e); 16 & n[2] || (n[2] |= 32) } function Cd(e, t, n, r) { let o = !1; if (Vp()) { const i = function BI(e, t, n) { const r = e.directiveRegistry; let o = null; if (r) for (let i = 0; i < r.length; i++) { const s = r[i]; Pm(n, s.selectors, !1) && (o || (o = []), fa(xi(n, t), e, s.type), an(s) ? (dy(e, n), o.unshift(s)) : o.push(s)) } return o }(e, t, n), s = null === r ? null : { "": -1 }; if (null !== i) { o = !0, fy(n, e.data.length, i.length); for (let l = 0; l < i.length; l++) { const d = i[l]; d.providersResolver && d.providersResolver(d) } let a = !1, c = !1, u = ko(e, t, i.length, null); for (let l = 0; l < i.length; l++) { const d = i[l]; n.mergedAttrs = ua(n.mergedAttrs, d.hostAttrs), hy(e, n, t, u, d), zI(u, d, s), null !== d.contentQueries && (n.flags |= 8), (null !== d.hostBindings || null !== d.hostAttrs || 0 !== d.hostVars) && (n.flags |= 128); const f = d.type.prototype; !a && (f.ngOnChanges || f.ngOnInit || f.ngDoCheck) && ((e.preOrderHooks || (e.preOrderHooks = [])).push(n.index), a = !0), !c && (f.ngOnChanges || f.ngDoCheck) && ((e.preOrderCheckHooks || (e.preOrderCheckHooks = [])).push(n.index), c = !0), u++ } ay(e, n) } s && function HI(e, t, n) { if (t) { const r = e.localNames = []; for (let o = 0; o < t.length; o += 2) { const i = n[t[o + 1]]; if (null == i) throw new M(-301, !1); r.push(t[o], i) } } }(n, r, s) } return n.mergedAttrs = ua(n.mergedAttrs, n.attrs), o } function uy(e, t, n, r, o, i) { const s = i.hostBindings; if (s) { let a = e.hostBindingOpCodes; null === a && (a = e.hostBindingOpCodes = []); const c = ~t.index; (function $I(e) { let t = e.length; for (; t > 0;) { const n = e[--t]; if ("number" == typeof n && n < 0) return n } return 0 })(a) != c && a.push(c), a.push(r, o, s) } } function ly(e, t) { null !== e.hostBindings && e.hostBindings(1, t) } function dy(e, t) { t.flags |= 2, (e.components || (e.components = [])).push(t.index) } function zI(e, t, n) { if (n) { if (t.exportAs) for (let r = 0; r < t.exportAs.length; r++)n[t.exportAs[r]] = e; an(t) && (n[""] = e) } } function fy(e, t, n) { e.flags |= 1, e.directiveStart = t, e.directiveEnd = t + n, e.providerIndexes = t } function hy(e, t, n, r, o) { e.data[r] = o; const i = o.factory || (o.factory = xr(o.type)), s = new Ii(i, an(o), S); e.blueprint[r] = s, n[r] = s, uy(e, t, 0, r, ko(e, n, o.hostVars, U), o) } function qI(e, t, n) { const r = Ft(t, e), o = oy(n), i = e[10], s = Fa(e, Ra(e, o, null, n.onPush ? 32 : 16, r, t, i, i.createRenderer(r, n), null, null, null)); e[t.index] = s } function WI(e, t, n, r, o, i) { const s = i[t]; if (null !== s) { const a = r.setInput; for (let c = 0; c < s.length;) { const u = s[c++], l = s[c++], d = s[c++]; null !== a ? r.setInput(n, d, u, l) : n[l] = d } } } function GI(e, t) { let n = null, r = 0; for (; r < t.length;) { const o = t[r]; if (0 !== o) if (5 !== o) { if ("number" == typeof o) break; e.hasOwnProperty(o) && (null === n && (n = []), n.push(o, e[o], t[r + 1])), r += 2 } else r += 2; else r += 4 } return n } function py(e, t, n, r) { return new Array(e, !0, !1, t, null, 0, r, n, null, null) } function YI(e, t) { const n = Lt(t, e); if (oa(n)) { const r = n[1]; 48 & n[2] ? Na(r, n, r.template, n[8]) : n[5] > 0 && bd(n) } } function bd(e) { for (let r = Il(e); null !== r; r = Tl(r))for (let o = 10; o < r.length; o++) { const i = r[o]; if (oa(i)) if (512 & i[2]) { const s = i[1]; Na(s, i, s.template, i[8]) } else i[5] > 0 && bd(i) } const n = e[1].components; if (null !== n) for (let r = 0; r < n.length; r++) { const o = Lt(n[r], e); oa(o) && o[5] > 0 && bd(o) } } function QI(e, t) { const n = Lt(t, e), r = n[1]; (function XI(e, t) { for (let n = t.length; n < e.blueprint.length; n++)t.push(e.blueprint[n]) })(r, n), md(r, n, n[8]) } function Fa(e, t) { return e[13] ? e[14][4] = t : e[13] = t, e[14] = t, t } function Dd(e) { for (; e;) { e[2] |= 32; const t = Hi(e); if (HD(e) && !t) return e; e = t } return null } function La(e, t, n, r = !0) { const o = t[10]; o.begin && o.begin(); try { Na(e, t, e.template, n) } catch (s) { throw r && vy(t, s), s } finally { o.end && o.end() } } function Ed(e, t, n) { rl(0), t(e, n) } function gy(e) { return e[7] || (e[7] = []) } function my(e) { return e.cleanup || (e.cleanup = []) } function vy(e, t) { const n = e[9], r = n ? n.get(To, null) : null; r && r.handleError(t) } function Md(e, t, n, r, o) { for (let i = 0; i < n.length;) { const s = n[i++], a = n[i++], c = t[s], u = e.data[s]; null !== u.setInput ? u.setInput(c, o, r, a) : c[a] = o } } function ja(e, t, n) { let r = n ? e.styles : null, o = n ? e.classes : null, i = 0; if (null !== t) for (let s = 0; s < t.length; s++) { const a = t[s]; "number" == typeof a ? i = a : 1 == i ? o = Lu(o, a) : 2 == i && (r = Lu(r, a + ": " + t[++s] + ";")) } n ? e.styles = r : e.stylesWithoutHost = r, n ? e.classes = o : e.classesWithoutHost = o } function $a(e, t, n, r, o = !1) { for (; null !== n;) { const i = t[n.index]; if (null !== i && r.push(je(i)), sn(i)) for (let a = 10; a < i.length; a++) { const c = i[a], u = c[1].firstChild; null !== u && $a(c[1], c, u, r) } const s = n.type; if (8 & s) $a(e, t, n.child, r); else if (32 & s) { const a = Sl(n, t); let c; for (; c = a();)r.push(c) } else if (16 & s) { const a = Xg(t, n); if (Array.isArray(a)) r.push(...a); else { const c = Hi(t[16]); $a(c[1], c, a, r, !0) } } n = o ? n.projectionNext : n.next } return r } class Zi { constructor(t, n) { this._lView = t, this._cdRefInjectingView = n, this._appRef = null, this._attachedToViewContainer = !1 } get rootNodes() { const t = this._lView, n = t[1]; return $a(n, t, n.firstChild, []) } get context() { return this._lView[8] } set context(t) { this._lView[8] = t } get destroyed() { return 128 == (128 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const t = this._lView[3]; if (sn(t)) { const n = t[8], r = n ? n.indexOf(this) : -1; r > -1 && (Pl(t, r), pa(n, r)) } this._attachedToViewContainer = !1 } Hg(this._lView[1], this._lView) } onDestroy(t) { !function iy(e, t, n, r) { const o = gy(t); null === n ? o.push(r) : (o.push(n), e.firstCreatePass && my(e).push(r, o.length - 1)) }(this._lView[1], this._lView, null, t) } markForCheck() { Dd(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -65 } reattach() { this._lView[2] |= 64 } detectChanges() { La(this._lView[1], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new M(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function PM(e, t) { zi(e, t, t[q], 2, null, null) }(this._lView[1], this._lView) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new M(902, !1); this._appRef = t } } class JI extends Zi { constructor(t) { super(t), this._view = t } detectChanges() { const t = this._view; La(t[1], t, t[8], !1) } checkNoChanges() { } get context() { return null } } class Sd extends Gi { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const n = ue(t); return new Ki(n, this.ngModule) } } function _y(e) { const t = []; for (let n in e) e.hasOwnProperty(n) && t.push({ propName: e[n], templateName: n }); return t } class tT { constructor(t, n) { this.injector = t, this.parentInjector = n } get(t, n, r) { const o = this.injector.get(t, Ql, r); return o !== Ql || n === Ql ? o : this.parentInjector.get(t, n, r) } } class Ki extends bm { constructor(t, n) { super(), this.componentDef = t, this.ngModule = n, this.componentType = t.type, this.selector = function eI(e) { return e.map(JS).join(",") }(t.selectors), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!n } get inputs() { return _y(this.componentDef.inputs) } get outputs() { return _y(this.componentDef.outputs) } create(t, n, r, o) { let i = (o = o || this.ngModule) instanceof lr ? o : o?.injector; i && null !== this.componentDef.getStandaloneInjector && (i = this.componentDef.getStandaloneInjector(i) || i); const s = i ? new tT(t, i) : t, a = s.get(Em, null); if (null === a) throw new M(407, !1); const c = s.get(NS, null), u = a.createRenderer(null, this.componentDef), l = this.componentDef.selectors[0][0] || "div", d = r ? function RI(e, t, n) { return e.selectRootElement(t, n === Cn.ShadowDom) }(u, r, this.componentDef.encapsulation) : Ol(u, l, function eT(e) { const t = e.toLowerCase(); return "svg" === t ? "svg" : "math" === t ? "math" : null }(l)), f = this.componentDef.onPush ? 288 : 272, h = _d(0, null, null, 1, 0, null, null, null, null, null), p = Ra(null, h, null, f, null, null, a, u, c, s, null); let g, m; ol(p); try { const v = function oT(e, t, n, r, o, i) { const s = n[1]; n[22] = e; const c = Po(s, 22, 2, "#host", null), u = c.mergedAttrs = t.hostAttrs; null !== u && (ja(c, u, !0), null !== e && (ca(o, e, u), null !== c.classes && Ll(o, e, c.classes), null !== c.styles && em(o, e, c.styles))); const l = r.createRenderer(e, t), d = Ra(n, oy(t), null, t.onPush ? 32 : 16, n[22], c, r, l, i || null, null, null); return s.firstCreatePass && (fa(xi(c, n), s, t.type), dy(s, c), fy(c, n.length, 1)), Fa(n, d), n[22] = d }(d, this.componentDef, p, a, u); if (d) if (r) ca(u, d, ["ng-version", Mm.full]); else { const { attrs: _, classes: y } = function tI(e) { const t = [], n = []; let r = 1, o = 2; for (; r < e.length;) { let i = e[r]; if ("string" == typeof i) 2 === o ? "" !== i && t.push(i, e[++r]) : 8 === o && n.push(i); else { if (!cn(o)) break; o = i } r++ } return { attrs: t, classes: n } }(this.componentDef.selectors[0]); _ && ca(u, d, _), y && y.length > 0 && Ll(u, d, y.join(" ")) } if (m = Qu(h, 22), void 0 !== n) { const _ = m.projection = []; for (let y = 0; y < this.ngContentSelectors.length; y++) { const w = n[y]; _.push(null != w ? Array.from(w) : null) } } g = function iT(e, t, n, r) { const o = n[1], i = function jI(e, t, n) { const r = He(); e.firstCreatePass && (n.providersResolver && n.providersResolver(n), hy(e, r, t, ko(e, t, 1, null), n), ay(e, r)); const o = Oi(t, e, r.directiveStart, r); lt(o, t); const i = Ft(r, t); return i && lt(i, t), o }(o, n, t); if (e[8] = n[8] = i, null !== r) for (const a of r) a(i, t); if (t.contentQueries) { const a = He(); t.contentQueries(1, i, a.directiveStart) } const s = He(); return !o.firstCreatePass || null === t.hostBindings && null === t.hostAttrs || (cr(s.index), uy(n[1], s, 0, s.directiveStart, s.directiveEnd, t), ly(t, i)), i }(v, this.componentDef, p, [sT]), md(h, p, null) } finally { il() } return new rT(this.componentType, g, Io(m, p), p, m) } } class rT extends class xS { }{ constructor(t, n, r, o, i) { super(), this.location = r, this._rootLView = o, this._tNode = i, this.instance = n, this.hostView = this.changeDetectorRef = new JI(o), this.componentType = t } setInput(t, n) { const r = this._tNode.inputs; let o; if (null !== r && (o = r[t])) { const i = this._rootLView; Md(i[1], i, o, t, n), cy(i, this._tNode.index) } } get injector() { return new yo(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } } function sT() { const e = He(); ia(C()[1], e) } let Ua = null; function Rr() { if (!Ua) { const e = he.Symbol; if (e && e.iterator) Ua = e.iterator; else { const t = Object.getOwnPropertyNames(Map.prototype); for (let n = 0; n < t.length; ++n) { const r = t[n]; "entries" !== r && "size" !== r && Map.prototype[r] === Map.prototype.entries && (Ua = r) } } } return Ua } function Yi(e) { return !!Td(e) && (Array.isArray(e) || !(e instanceof Map) && Rr() in e) } function Td(e) { return null !== e && ("function" == typeof e || "object" == typeof e) } function dt(e, t, n) { return !Object.is(e[t], n) && (e[t] = n, !0) } function Ro(e, t, n, r) { return dt(e, po(), n) ? t + $(n) + r : U } function we(e, t, n, r, o, i, s, a) { const c = C(), u = te(), l = e + 22, d = u.firstCreatePass ? function vT(e, t, n, r, o, i, s, a, c) { const u = t.consts, l = Po(t, e, 4, s || null, ar(u, a)); Cd(t, n, l, ar(u, c)), ia(t, l); const d = l.tViews = _d(2, l, r, o, i, t.directiveRegistry, t.pipeRegistry, null, t.schemas, u); return null !== t.queries && (t.queries.template(t, l), d.queries = t.queries.embeddedTView(l)), l }(l, u, c, t, n, r, o, i, s) : u.data[l]; wn(d, !1); const f = c[q].createComment(""); Ca(u, c, f, d), lt(f, c), Fa(c, c[l] = py(f, c, f, d)), na(d) && yd(u, c, d), null != s && vd(c, d, a) } function Od(e) { return ho(function cE() { return L.lFrame.contextLView }(), 22 + e) } function J(e, t, n) { const r = C(); return dt(r, po(), t) && Bt(te(), be(), r, e, t, r[q], n, !1), J } function Pd(e, t, n, r, o) { const s = o ? "class" : "style"; Md(e, n, t.inputs[s], s, r) } function ee(e, t, n, r) { const o = C(), i = te(), s = 22 + e, a = o[q], c = o[s] = Ol(a, t, function _E() { return L.lFrame.currentNamespace }()), u = i.firstCreatePass ? function CT(e, t, n, r, o, i, s) { const a = t.consts, u = Po(t, e, 2, o, ar(a, i)); return Cd(t, n, u, ar(a, s)), null !== u.attrs && ja(u, u.attrs, !1), null !== u.mergedAttrs && ja(u, u.mergedAttrs, !0), null !== t.queries && t.queries.elementStart(t, u), u }(s, i, o, 0, t, n, r) : i.data[s]; wn(u, !0); const l = u.mergedAttrs; null !== l && ca(a, c, l); const d = u.classes; null !== d && Ll(a, c, d); const f = u.styles; return null !== f && em(a, c, f), 64 != (64 & u.flags) && Ca(i, o, c, u), 0 === function rE() { return L.lFrame.elementDepthCount }() && lt(c, o), function oE() { L.lFrame.elementDepthCount++ }(), na(u) && (yd(i, o, u), ry(i, u, o)), null !== r && vd(o, u), ee } function Q() { let e = He(); Ju() ? el() : (e = e.parent, wn(e, !1)); const t = e; !function iE() { L.lFrame.elementDepthCount-- }(); const n = te(); return n.firstCreatePass && (ia(n, e), Wu(e) && n.queries.elementEnd(e)), null != t.classesWithoutHost && function EE(e) { return 0 != (16 & e.flags) }(t) && Pd(n, t, C(), t.classesWithoutHost, !0), null != t.stylesWithoutHost && function ME(e) { return 0 != (32 & e.flags) }(t) && Pd(n, t, C(), t.stylesWithoutHost, !1), Q } function me(e, t, n, r) { return ee(e, t, n, r), Q(), me } function kd(e, t, n) { const r = C(), o = te(), i = e + 22, s = o.firstCreatePass ? function wT(e, t, n, r, o) { const i = t.consts, s = ar(i, r), a = Po(t, e, 8, "ng-container", s); return null !== s && ja(a, s, !0), Cd(t, n, a, ar(i, o)), null !== t.queries && t.queries.elementStart(t, a), a }(i, o, r, t, n) : o.data[i]; wn(s, !0); const a = r[i] = r[q].createComment(""); return Ca(o, r, a, s), lt(a, r), na(s) && (yd(o, r, s), ry(o, s, r)), null != n && vd(r, s), kd } function Ad() { let e = He(); const t = te(); return Ju() ? el() : (e = e.parent, wn(e, !1)), t.firstCreatePass && (ia(t, e), Wu(e) && t.queries.elementEnd(e)), Ad } function Ba(e, t, n) { return kd(e, t, n), Ad(), Ba } function Ha(e) { return !!e && "function" == typeof e.then } function ky(e) { return !!e && "function" == typeof e.subscribe } const Ay = ky; function pr(e, t, n, r) { const o = C(), i = te(), s = He(); return function Ny(e, t, n, r, o, i, s, a) { const c = na(r), l = e.firstCreatePass && my(e), d = t[8], f = gy(t); let h = !0; if (3 & r.type || a) { const m = Ft(r, t), v = a ? a(m) : m, _ = f.length, y = a ? N => a(je(N[r.index])) : r.index; let w = null; if (!a && c && (w = function bT(e, t, n, r) { const o = e.cleanup; if (null != o) for (let i = 0; i < o.length - 1; i += 2) { const s = o[i]; if (s === n && o[i + 1] === r) { const a = t[7], c = o[i + 2]; return a.length > c ? a[c] : null } "string" == typeof s && (i += 2) } return null }(e, t, o, r.index)), null !== w) (w.__ngLastListenerFn__ || w).__ngNextListenerFn__ = i, w.__ngLastListenerFn__ = i, h = !1; else { i = Ly(r, t, d, i, !1); const N = n.listen(v, o, i); f.push(i, N), l && l.push(o, y, _, _ + 1) } } else i = Ly(r, t, d, i, !1); const p = r.outputs; let g; if (h && null !== p && (g = p[o])) { const m = g.length; if (m) for (let v = 0; v < m; v += 2) { const ne = t[g[v]][g[v + 1]].subscribe(i), gt = f.length; f.push(i, ne), l && l.push(o, r.index, gt, -(gt + 1)) } } }(i, o, o[q], s, e, t, 0, r), pr } function Fy(e, t, n, r) { try { return !1 !== n(r) } catch (o) { return vy(e, o), !1 } } function Ly(e, t, n, r, o) { return function i(s) { if (s === Function) return r; Dd(2 & e.flags ? Lt(e.index, t) : t); let c = Fy(t, 0, r, s), u = i.__ngNextListenerFn__; for (; u;)c = Fy(t, 0, u, s) && c, u = u.__ngNextListenerFn__; return o && !1 === c && (s.preventDefault(), s.returnValue = !1), c } } function ft(e = 1) { return function hE(e) { return (L.lFrame.contextLView = function pE(e, t) { for (; e > 0;)t = t[15], e--; return t }(e, L.lFrame.contextLView))[8] }(e) } function Zn(e, t, n) { return Bo(e, "", t, "", n), Zn } function Bo(e, t, n, r, o) { const i = C(), s = Ro(i, t, n, r); return s !== U && Bt(te(), be(), i, e, s, i[q], o, !1), Bo } function Wy(e, t, n, r, o) { const i = e[n + 1], s = null === t; let a = r ? un(i) : Wn(i), c = !1; for (; 0 !== a && (!1 === c || s);) { const l = e[a + 1]; TT(e[a], t) && (c = !0, e[a + 1] = r ? ad(l) : id(l)), a = r ? un(l) : Wn(l) } c && (e[n + 1] = r ? id(i) : ad(i)) } function TT(e, t) { return null === e || null == t || (Array.isArray(e) ? e[1] : e) === t || !(!Array.isArray(e) || "string" != typeof t) && bo(e, t) >= 0 } const qe = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 }; function Gy(e) { return e.substring(qe.key, qe.keyEnd) } function xT(e) { return e.substring(qe.value, qe.valueEnd) } function Zy(e, t) { const n = qe.textEnd; return n === t ? -1 : (t = qe.keyEnd = function kT(e, t, n) { for (; t < n && e.charCodeAt(t) > 32;)t++; return t }(e, qe.key = t, n), Ho(e, t, n)) } function Ky(e, t) { const n = qe.textEnd; let r = qe.key = Ho(e, t, n); return n === r ? -1 : (r = qe.keyEnd = function AT(e, t, n) { let r; for (; t < n && (45 === (r = e.charCodeAt(t)) || 95 === r || (-33 & r) >= 65 && (-33 & r) <= 90 || r >= 48 && r <= 57);)t++; return t }(e, r, n), r = Qy(e, r, n), r = qe.value = Ho(e, r, n), r = qe.valueEnd = function RT(e, t, n) { let r = -1, o = -1, i = -1, s = t, a = s; for (; s < n;) { const c = e.charCodeAt(s++); if (59 === c) return a; 34 === c || 39 === c ? a = s = Xy(e, c, s, n) : t === s - 4 && 85 === i && 82 === o && 76 === r && 40 === c ? a = s = Xy(e, 41, s, n) : c > 32 && (a = s), i = o, o = r, r = -33 & c } return a }(e, r, n), Qy(e, r, n)) } function Yy(e) { qe.key = 0, qe.keyEnd = 0, qe.value = 0, qe.valueEnd = 0, qe.textEnd = e.length } function Ho(e, t, n) { for (; t < n && e.charCodeAt(t) <= 32;)t++; return t } function Qy(e, t, n, r) { return (t = Ho(e, t, n)) < n && t++, t } function Xy(e, t, n, r) { let o = -1, i = n; for (; i < r;) { const s = e.charCodeAt(i++); if (s == t && 92 !== o) return i; o = 92 == s && 92 === o ? 0 : s } throw new Error } function gr(e, t, n) { return ln(e, t, n, !1), gr } function Xi(e, t) { return ln(e, t, null, !0), Xi } function NT(e, t) { for (let n = function PT(e) { return Yy(e), Ky(e, Ho(e, 0, qe.textEnd)) }(t); n >= 0; n = Ky(t, n))tv(e, Gy(t), xT(t)) } function za(e) { dn($t, In, e, !0) } function In(e, t) { for (let n = function OT(e) { return Yy(e), Zy(e, Ho(e, 0, qe.textEnd)) }(t); n >= 0; n = Zy(t, n))$t(e, Gy(t), !0) } function ln(e, t, n, r) { const o = C(), i = te(), s = Vn(2); i.firstUpdatePass && ev(i, e, s, r), t !== U && dt(o, s, t) && nv(i, i.data[_t()], o, o[q], e, o[s + 1] = function BT(e, t) { return null == e || ("string" == typeof t ? e += t : "object" == typeof e && (e = fe(Ut(e)))), e }(t, n), r, s) } function dn(e, t, n, r) { const o = te(), i = Vn(2); o.firstUpdatePass && ev(o, null, i, r); const s = C(); if (n !== U && dt(s, i, n)) { const a = o.data[_t()]; if (ov(a, r) && !Jy(o, i)) { let c = r ? a.classesWithoutHost : a.stylesWithoutHost; null !== c && (n = Lu(c, n || "")), Pd(o, a, s, n, r) } else !function VT(e, t, n, r, o, i, s, a) { o === U && (o = ae); let c = 0, u = 0, l = 0 < o.length ? o[0] : null, d = 0 < i.length ? i[0] : null; for (; null !== l || null !== d;) { const f = c < o.length ? o[c + 1] : void 0, h = u < i.length ? i[u + 1] : void 0; let g, p = null; l === d ? (c += 2, u += 2, f !== h && (p = d, g = h)) : null === d || null !== l && l < d ? (c += 2, p = l) : (u += 2, p = d, g = h), null !== p && nv(e, t, n, r, p, g, s, a), l = c < o.length ? o[c] : null, d = u < i.length ? i[u] : null } }(o, a, s, s[q], s[i + 1], s[i + 1] = function UT(e, t, n) { if (null == n || "" === n) return ae; const r = [], o = Ut(n); if (Array.isArray(o)) for (let i = 0; i < o.length; i++)e(r, o[i], !0); else if ("object" == typeof o) for (const i in o) o.hasOwnProperty(i) && e(r, i, o[i]); else "string" == typeof o && t(r, o); return r }(e, t, n), r, i) } } function Jy(e, t) { return t >= e.expandoStartIndex } function ev(e, t, n, r) { const o = e.data; if (null === o[n + 1]) { const i = o[_t()], s = Jy(e, n); ov(i, r) && null === t && !s && (t = !1), t = function FT(e, t, n, r) { const o = function nl(e) { const t = L.lFrame.currentDirectiveIndex; return -1 === t ? null : e[t] }(e); let i = r ? t.residualClasses : t.residualStyles; if (null === o) 0 === (r ? t.classBindings : t.styleBindings) && (n = Ji(n = Rd(null, e, t, n, r), t.attrs, r), i = null); else { const s = t.directiveStylingLast; if (-1 === s || e[s] !== o) if (n = Rd(o, e, t, n, r), null === i) { let c = function LT(e, t, n) { const r = n ? t.classBindings : t.styleBindings; if (0 !== Wn(r)) return e[un(r)] }(e, t, r); void 0 !== c && Array.isArray(c) && (c = Rd(null, e, t, c[1], r), c = Ji(c, t.attrs, r), function jT(e, t, n, r) { e[un(n ? t.classBindings : t.styleBindings)] = r }(e, t, r, c)) } else i = function $T(e, t, n) { let r; const o = t.directiveEnd; for (let i = 1 + t.directiveStylingLast; i < o; i++)r = Ji(r, e[i].hostAttrs, n); return Ji(r, t.attrs, n) }(e, t, r) } return void 0 !== i && (r ? t.residualClasses = i : t.residualStyles = i), n }(o, i, t, r), function ST(e, t, n, r, o, i) { let s = i ? t.classBindings : t.styleBindings, a = un(s), c = Wn(s); e[r] = n; let l, u = !1; if (Array.isArray(n)) { const d = n; l = d[1], (null === l || bo(d, l) > 0) && (u = !0) } else l = n; if (o) if (0 !== c) { const f = un(e[a + 1]); e[r + 1] = Pa(f, a), 0 !== f && (e[f + 1] = sd(e[f + 1], r)), e[a + 1] = function CI(e, t) { return 131071 & e | t << 17 }(e[a + 1], r) } else e[r + 1] = Pa(a, 0), 0 !== a && (e[a + 1] = sd(e[a + 1], r)), a = r; else e[r + 1] = Pa(c, 0), 0 === a ? a = r : e[c + 1] = sd(e[c + 1], r), c = r; u && (e[r + 1] = id(e[r + 1])), Wy(e, l, r, !0), Wy(e, l, r, !1), function IT(e, t, n, r, o) { const i = o ? e.residualClasses : e.residualStyles; null != i && "string" == typeof t && bo(i, t) >= 0 && (n[r + 1] = ad(n[r + 1])) }(t, l, e, r, i), s = Pa(a, c), i ? t.classBindings = s : t.styleBindings = s }(o, i, t, n, s, r) } } function Rd(e, t, n, r, o) { let i = null; const s = n.directiveEnd; let a = n.directiveStylingLast; for (-1 === a ? a = n.directiveStart : a++; a < s && (i = t[a], r = Ji(r, i.hostAttrs, o), i !== e);)a++; return null !== e && (n.directiveStylingLast = a), r } function Ji(e, t, n) { const r = n ? 1 : 2; let o = -1; if (null !== t) for (let i = 0; i < t.length; i++) { const s = t[i]; "number" == typeof s ? o = s : o === r && (Array.isArray(e) || (e = void 0 === e ? [] : ["", e]), $t(e, s, !!n || t[++i])) } return void 0 === e ? null : e } function tv(e, t, n) { $t(e, t, Ut(n)) } function nv(e, t, n, r, o, i, s, a) { if (!(3 & t.type)) return; const c = e.data, u = c[a + 1]; qa(function Gm(e) { return 1 == (1 & e) }(u) ? rv(c, t, n, o, Wn(u), s) : void 0) || (qa(i) || function Wm(e) { return 2 == (2 & e) }(u) && (i = rv(c, null, n, o, a, s)), function VM(e, t, n, r, o) { if (t) o ? e.addClass(n, r) : e.removeClass(n, r); else { let i = -1 === r.indexOf("-") ? void 0 : Tt.DashCase; null == o ? e.removeStyle(n, r, i) : ("string" == typeof o && o.endsWith("!important") && (o = o.slice(0, -10), i |= Tt.Important), e.setStyle(n, r, o, i)) } }(r, s, ra(_t(), n), o, i)) } function rv(e, t, n, r, o, i) { const s = null === t; let a; for (; o > 0;) { const c = e[o], u = Array.isArray(c), l = u ? c[1] : c, d = null === l; let f = n[o + 1]; f === U && (f = d ? ae : void 0); let h = d ? pl(f, r) : l === r ? f : void 0; if (u && !qa(h) && (h = pl(c, r)), qa(h) && (a = h, s)) return a; const p = e[o + 1]; o = s ? un(p) : Wn(p) } if (null !== t) { let c = i ? t.residualClasses : t.residualStyles; null != c && (a = pl(c, r)) } return a } function qa(e) { return void 0 !== e } function ov(e, t) { return 0 != (e.flags & (t ? 16 : 32)) } function De(e, t = "") { const n = C(), r = te(), o = e + 22, i = r.firstCreatePass ? Po(r, o, 1, t, null) : r.data[o], s = n[o] = function xl(e, t) { return e.createText(t) }(n[q], t); Ca(r, n, s, i), wn(i, !1) } function et(e) { return zo("", e, ""), et } function zo(e, t, n) { const r = C(), o = Ro(r, e, t, n); return o !== U && function Gn(e, t, n) { const r = ra(t, e); !function Vg(e, t, n) { e.setValue(t, n) }(e[q], r, n) }(r, _t(), o), zo } function Wa(e, t, n) { dn($t, In, Ro(C(), e, t, n), !0) } function hv(e, t, n) { !function Sn(e) { dn(tv, NT, e, !1) }(Ro(C(), e, t, n)) } const Wo = "en-US"; let Iv = Wo; class Lr { } class Jv { } class e_ extends Lr { constructor(t, n) { super(), this._parent = n, this._bootstrapComponents = [], this.destroyCbs = [], this.componentFactoryResolver = new Sd(this); const r = Rt(t); this._bootstrapComponents = qn(r.bootstrap), this._r3Injector = jm(t, n, [{ provide: Lr, useValue: this }, { provide: Gi, useValue: this.componentFactoryResolver }], fe(t), new Set(["environment"])), this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(t) } get injector() { return this._r3Injector } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(n => n()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class Vd extends Jv { constructor(t) { super(), this.moduleType = t } create(t) { return new e_(this.moduleType, t) } } class a1 extends Lr { constructor(t, n, r) { super(), this.componentFactoryResolver = new Sd(this), this.instance = null; const o = new Cm([...t, { provide: Lr, useValue: this }, { provide: Gi, useValue: this.componentFactoryResolver }], n || Ia(), r, new Set(["environment"])); this.injector = o, o.resolveInjectorInitializers() } destroy() { this.injector.destroy() } onDestroy(t) { this.injector.onDestroy(t) } } function Qa(e, t, n = null) { return new a1(e, t, n).injector } let c1 = (() => { class e { constructor(n) { this._injector = n, this.cachedInjectors = new Map } getOrCreateStandaloneInjector(n) { if (!n.standalone) return null; if (!this.cachedInjectors.has(n.id)) { const r = mm(0, n.type), o = r.length > 0 ? Qa([r], this._injector, `Standalone[${n.type.name}]`) : null; this.cachedInjectors.set(n.id, o) } return this.cachedInjectors.get(n.id) } ngOnDestroy() { try { for (const n of this.cachedInjectors.values()) null !== n && n.destroy() } finally { this.cachedInjectors.clear() } } } return e.\u0275prov = x({ token: e, providedIn: "environment", factory: () => new e(E(lr)) }), e })(); function t_(e) { e.getStandaloneInjector = t => t.get(c1).getOrCreateStandaloneInjector(e) } function c_(e, t, n, r, o, i) { const s = t + n; return dt(e, s, o) ? function Mn(e, t, n) { return e[t] = n }(e, s + 1, i ? r.call(i, o) : r(o)) : function is(e, t) { const n = e[t]; return n === U ? void 0 : n }(e, s + 1) } function Hd(e, t) { const n = te(); let r; const o = e + 22; n.firstCreatePass ? (r = function I1(e, t) { if (t) for (let n = t.length - 1; n >= 0; n--) { const r = t[n]; if (e === r.name) return r } }(t, n.pipeRegistry), n.data[o] = r, r.onDestroy && (n.destroyHooks || (n.destroyHooks = [])).push(o, r.onDestroy)) : r = n.data[o]; const i = r.factory || (r.factory = xr(r.type)), s = Gt(S); try { const a = la(!1), c = i(); return la(a), function _T(e, t, n, r) { n >= e.data.length && (e.data[n] = null, e.blueprint[n] = null), t[n] = r }(n, C(), o, c), c } finally { Gt(s) } } function zd(e, t, n) { const r = e + 22, o = C(), i = ho(o, r); return function ss(e, t) { return e[1].data[t].pure }(o, r) ? c_(o, function vt() { const e = L.lFrame; let t = e.bindingRootIndex; return -1 === t && (t = e.bindingRootIndex = e.tView.bindingStartIndex), t }(), t, i.transform, n, i) : i.transform(n) } function qd(e) { return t => { setTimeout(e, void 0, t) } } const bt = class k1 extends Pt { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, n, r) { let o = t, i = n || (() => null), s = r; if (t && "object" == typeof t) { const c = t; o = c.next?.bind(c), i = c.error?.bind(c), s = c.complete?.bind(c) } this.__isAsync && (i = qd(i), o && (o = qd(o)), s && (s = qd(s))); const a = super.subscribe({ next: o, error: i, complete: s }); return t instanceof Me && t.add(a), a } }; let Kn = (() => { class e { } return e.__NG_ELEMENT_ID__ = F1, e })(); const R1 = Kn, N1 = class extends R1 { constructor(t, n, r) { super(), this._declarationLView = t, this._declarationTContainer = n, this.elementRef = r } createEmbeddedView(t, n) { const r = this._declarationTContainer.tViews, o = Ra(this._declarationLView, r, t, 16, null, r.declTNode, null, null, null, null, n || null); o[17] = this._declarationLView[this._declarationTContainer.index]; const s = this._declarationLView[19]; return null !== s && (o[19] = s.createEmbeddedView(r)), md(r, o, t), new Zi(o) } }; function F1() { return Xa(He(), C()) } function Xa(e, t) { return 4 & e.type ? new N1(t, e, Io(e, t)) : null } let fn = (() => { class e { } return e.__NG_ELEMENT_ID__ = L1, e })(); function L1() { return function g_(e, t) { let n; const r = t[e.index]; if (sn(r)) n = r; else { let o; if (8 & e.type) o = je(r); else { const i = t[q]; o = i.createComment(""); const s = Ft(e, t); Or(i, _a(i, s), o, function jM(e, t) { return e.nextSibling(t) }(i, s), !1) } t[e.index] = n = py(r, t, o, e), Fa(t, n) } return new h_(n, e, t) }(He(), C()) } const j1 = fn, h_ = class extends j1 { constructor(t, n, r) { super(), this._lContainer = t, this._hostTNode = n, this._hostLView = r } get element() { return Io(this._hostTNode, this._hostLView) } get injector() { return new yo(this._hostTNode, this._hostLView) } get parentInjector() { const t = da(this._hostTNode, this._hostLView); if (og(t)) { const n = mo(t, this._hostLView), r = go(t); return new yo(n[1].data[r + 8], n) } return new yo(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { const n = p_(this._lContainer); return null !== n && n[t] || null } get length() { return this._lContainer.length - 10 } createEmbeddedView(t, n, r) { let o, i; "number" == typeof r ? o = r : null != r && (o = r.index, i = r.injector); const s = t.createEmbeddedView(n || {}, i); return this.insert(s, o), s } createComponent(t, n, r, o, i) { const s = t && !function Ai(e) { return "function" == typeof e }(t); let a; if (s) a = n; else { const d = n || {}; a = d.index, r = d.injector, o = d.projectableNodes, i = d.environmentInjector || d.ngModuleRef } const c = s ? t : new Ki(ue(t)), u = r || this.parentInjector; if (!i && null == c.ngModule) { const f = (s ? u : this.parentInjector).get(lr, null); f && (i = f) } const l = c.create(u, o, void 0, i); return this.insert(l.hostView, a), l } insert(t, n) { const r = t._lView, o = r[1]; if (function nE(e) { return sn(e[3]) }(r)) { const l = this.indexOf(t); if (-1 !== l) this.detach(l); else { const d = r[3], f = new h_(d, d[6], d[3]); f.detach(f.indexOf(t)) } } const i = this._adjustIndex(n), s = this._lContainer; !function AM(e, t, n, r) { const o = 10 + r, i = n.length; r > 0 && (n[o - 1][4] = t), r < i - 10 ? (t[4] = n[o], gg(n, 10 + r, t)) : (n.push(t), t[4] = null), t[3] = n; const s = t[17]; null !== s && n !== s && function RM(e, t) { const n = e[9]; t[16] !== t[3][3][16] && (e[2] = !0), null === n ? e[9] = [t] : n.push(t) }(s, t); const a = t[19]; null !== a && a.insertView(e), t[2] |= 64 }(o, r, s, i); const a = Rl(i, s), c = r[q], u = _a(c, s[7]); return null !== u && function OM(e, t, n, r, o, i) { r[0] = o, r[6] = t, zi(e, r, n, 1, o, i) }(o, s[6], c, r, u, a), t.attachToViewContainerRef(), gg(Gd(s), i, t), t } move(t, n) { return this.insert(t, n) } indexOf(t) { const n = p_(this._lContainer); return null !== n ? n.indexOf(t) : -1 } remove(t) { const n = this._adjustIndex(t, -1), r = Pl(this._lContainer, n); r && (pa(Gd(this._lContainer), n), Hg(r[1], r)) } detach(t) { const n = this._adjustIndex(t, -1), r = Pl(this._lContainer, n); return r && null != pa(Gd(this._lContainer), n) ? new Zi(r) : null } _adjustIndex(t, n = 0) { return t ?? this.length + n } }; function p_(e) { return e[8] } function Gd(e) { return e[8] || (e[8] = []) } function nf(e, t) { return Xa(e, t) } function ec(...e) { } const tc = new O("Application Initializer"); let nc = (() => { class e { constructor(n) { this.appInits = n, this.resolve = ec, this.reject = ec, this.initialized = !1, this.done = !1, this.donePromise = new Promise((r, o) => { this.resolve = r, this.reject = o }) } runInitializers() { if (this.initialized) return; const n = [], r = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let o = 0; o < this.appInits.length; o++) { const i = this.appInits[o](); if (Ha(i)) n.push(i); else if (Ay(i)) { const s = new Promise((a, c) => { i.subscribe({ complete: a, error: c }) }); n.push(s) } } Promise.all(n).then(() => { r() }).catch(o => { this.reject(o) }), 0 === n.length && r(), this.initialized = !0 } } return e.\u0275fac = function (n) { return new (n || e)(E(tc, 8)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const cs = new O("AppId", { providedIn: "root", factory: function $_() { return `${uf()}${uf()}${uf()}` } }); function uf() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const U_ = new O("Platform Initializer"), V_ = new O("Platform ID", { providedIn: "platform", factory: () => "unknown" }), B_ = new O("appBootstrapListener"); let hO = (() => { class e { log(n) { console.log(n) } warn(n) { console.warn(n) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); const Yn = new O("LocaleId", { providedIn: "root", factory: () => Ae(Yn, k.Optional | k.SkipSelf) || function pO() { return typeof $localize < "u" && $localize.locale || Wo }() }); class mO { constructor(t, n) { this.ngModuleFactory = t, this.componentFactories = n } } let lf = (() => { class e { compileModuleSync(n) { return new Vd(n) } compileModuleAsync(n) { return Promise.resolve(this.compileModuleSync(n)) } compileModuleAndAllComponentsSync(n) { const r = this.compileModuleSync(n), i = qn(Rt(n).declarations).reduce((s, a) => { const c = ue(a); return c && s.push(new Ki(c)), s }, []); return new mO(r, i) } compileModuleAndAllComponentsAsync(n) { return Promise.resolve(this.compileModuleAndAllComponentsSync(n)) } clearCache() { } clearCacheFor(n) { } getModuleId(n) { } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const _O = (() => Promise.resolve(0))(); function df(e) { typeof Zone > "u" ? _O.then(() => { e && e.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", e) } class We { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: n = !1, shouldCoalesceRunChangeDetection: r = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new bt(!1), this.onMicrotaskEmpty = new bt(!1), this.onStable = new bt(!1), this.onError = new bt(!1), typeof Zone > "u") throw new M(908, !1); Zone.assertZonePatched(); const o = this; if (o._nesting = 0, o._outer = o._inner = Zone.current, Zone.AsyncStackTaggingZoneSpec) { const i = Zone.AsyncStackTaggingZoneSpec; o._inner = o._inner.fork(new i("Angular")) } Zone.TaskTrackingZoneSpec && (o._inner = o._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (o._inner = o._inner.fork(Zone.longStackTraceZoneSpec)), o.shouldCoalesceEventChangeDetection = !r && n, o.shouldCoalesceRunChangeDetection = r, o.lastRequestAnimationFrameId = -1, o.nativeRequestAnimationFrame = function CO() { let e = he.requestAnimationFrame, t = he.cancelAnimationFrame; if (typeof Zone < "u" && e && t) { const n = e[Zone.__symbol__("OriginalDelegate")]; n && (e = n); const r = t[Zone.__symbol__("OriginalDelegate")]; r && (t = r) } return { nativeRequestAnimationFrame: e, nativeCancelAnimationFrame: t } }().nativeRequestAnimationFrame, function DO(e) { const t = () => { !function bO(e) { e.isCheckStableRunning || -1 !== e.lastRequestAnimationFrameId || (e.lastRequestAnimationFrameId = e.nativeRequestAnimationFrame.call(he, () => { e.fakeTopEventTask || (e.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { e.lastRequestAnimationFrameId = -1, hf(e), e.isCheckStableRunning = !0, ff(e), e.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), e.fakeTopEventTask.invoke() }), hf(e)) }(e) }; e._inner = e._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, r, o, i, s, a) => { try { return q_(e), n.invokeTask(o, i, s, a) } finally { (e.shouldCoalesceEventChangeDetection && "eventTask" === i.type || e.shouldCoalesceRunChangeDetection) && t(), W_(e) } }, onInvoke: (n, r, o, i, s, a, c) => { try { return q_(e), n.invoke(o, i, s, a, c) } finally { e.shouldCoalesceRunChangeDetection && t(), W_(e) } }, onHasTask: (n, r, o, i) => { n.hasTask(o, i), r === o && ("microTask" == i.change ? (e._hasPendingMicrotasks = i.microTask, hf(e), ff(e)) : "macroTask" == i.change && (e.hasPendingMacrotasks = i.macroTask)) }, onHandleError: (n, r, o, i) => (n.handleError(o, i), e.runOutsideAngular(() => e.onError.emit(i)), !1) }) }(o) } static isInAngularZone() { return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!We.isInAngularZone()) throw new M(909, !1) } static assertNotInAngularZone() { if (We.isInAngularZone()) throw new M(909, !1) } run(t, n, r) { return this._inner.run(t, n, r) } runTask(t, n, r, o) { const i = this._inner, s = i.scheduleEventTask("NgZoneEvent: " + o, t, wO, ec, ec); try { return i.runTask(s, n, r) } finally { i.cancelTask(s) } } runGuarded(t, n, r) { return this._inner.runGuarded(t, n, r) } runOutsideAngular(t) { return this._outer.run(t) } } const wO = {}; function ff(e) { if (0 == e._nesting && !e.hasPendingMicrotasks && !e.isStable) try { e._nesting++, e.onMicrotaskEmpty.emit(null) } finally { if (e._nesting--, !e.hasPendingMicrotasks) try { e.runOutsideAngular(() => e.onStable.emit(null)) } finally { e.isStable = !0 } } } function hf(e) { e.hasPendingMicrotasks = !!(e._hasPendingMicrotasks || (e.shouldCoalesceEventChangeDetection || e.shouldCoalesceRunChangeDetection) && -1 !== e.lastRequestAnimationFrameId) } function q_(e) { e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null)) } function W_(e) { e._nesting--, ff(e) } class EO { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new bt, this.onMicrotaskEmpty = new bt, this.onStable = new bt, this.onError = new bt } run(t, n, r) { return t.apply(n, r) } runGuarded(t, n, r) { return t.apply(n, r) } runOutsideAngular(t) { return t() } runTask(t, n, r, o) { return t.apply(n, r) } } const G_ = new O(""), rc = new O(""); let mf, pf = (() => { class e { constructor(n, r, o) { this._ngZone = n, this.registry = r, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, mf || (function MO(e) { mf = e }(o), o.addToWindow(r)), this._watchAngularEvents(), n.run(() => { this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { We.assertNotInAngularZone(), df(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) df(() => { for (; 0 !== this._callbacks.length;) { let n = this._callbacks.pop(); clearTimeout(n.timeoutId), n.doneCb(this._didWork) } this._didWork = !1 }); else { let n = this.getPendingTasks(); this._callbacks = this._callbacks.filter(r => !r.updateCb || !r.updateCb(n) || (clearTimeout(r.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(n => ({ source: n.source, creationLocation: n.creationLocation, data: n.data })) : [] } addCallback(n, r, o) { let i = -1; r && r > 0 && (i = setTimeout(() => { this._callbacks = this._callbacks.filter(s => s.timeoutId !== i), n(this._didWork, this.getPendingTasks()) }, r)), this._callbacks.push({ doneCb: n, timeoutId: i, updateCb: o }) } whenStable(n, r, o) { if (o && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(n, r, o), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } registerApplication(n) { this.registry.registerApplication(n, this) } unregisterApplication(n) { this.registry.unregisterApplication(n) } findProviders(n, r, o) { return [] } } return e.\u0275fac = function (n) { return new (n || e)(E(We), E(gf), E(rc)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(), gf = (() => { class e { constructor() { this._applications = new Map } registerApplication(n, r) { this._applications.set(n, r) } unregisterApplication(n) { this._applications.delete(n) } unregisterAllApplications() { this._applications.clear() } getTestability(n) { return this._applications.get(n) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(n, r = !0) { return mf?.findTestabilityInTree(this, n, r) ?? null } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(), mr = null; const Z_ = new O("AllowMultipleToken"), yf = new O("PlatformDestroyListeners"); class K_ { constructor(t, n) { this.name = t, this.token = n } } function Q_(e, t, n = []) { const r = `Platform: ${t}`, o = new O(r); return (i = []) => { let s = vf(); if (!s || s.injector.get(Z_, !1)) { const a = [...n, ...i, { provide: o, useValue: !0 }]; e ? e(a) : function TO(e) { if (mr && !mr.get(Z_, !1)) throw new M(400, !1); mr = e; const t = e.get(J_); (function Y_(e) { const t = e.get(U_, null); t && t.forEach(n => n()) })(e) }(function X_(e = [], t) { return Vt.create({ name: t, providers: [{ provide: Gl, useValue: "platform" }, { provide: yf, useValue: new Set([() => mr = null]) }, ...e] }) }(a, r)) } return function OO(e) { const t = vf(); if (!t) throw new M(401, !1); return t }() } } function vf() { return mr?.get(J_) ?? null } let J_ = (() => { class e { constructor(n) { this._injector = n, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(n, r) { const o = function tC(e, t) { let n; return n = "noop" === e ? new EO : ("zone.js" === e ? void 0 : e) || new We(t), n }(r?.ngZone, function eC(e) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: !(!e || !e.ngZoneEventCoalescing) || !1, shouldCoalesceRunChangeDetection: !(!e || !e.ngZoneRunCoalescing) || !1 } }(r)), i = [{ provide: We, useValue: o }]; return o.run(() => { const s = Vt.create({ providers: i, parent: this.injector, name: n.moduleType.name }), a = n.create(s), c = a.injector.get(To, null); if (!c) throw new M(402, !1); return o.runOutsideAngular(() => { const u = o.onError.subscribe({ next: l => { c.handleError(l) } }); a.onDestroy(() => { ic(this._modules, a), u.unsubscribe() }) }), function nC(e, t, n) { try { const r = n(); return Ha(r) ? r.catch(o => { throw t.runOutsideAngular(() => e.handleError(o)), o }) : r } catch (r) { throw t.runOutsideAngular(() => e.handleError(r)), r } }(c, o, () => { const u = a.injector.get(nc); return u.runInitializers(), u.donePromise.then(() => (function Tv(e) { At(e, "Expected localeId to be defined"), "string" == typeof e && (Iv = e.toLowerCase().replace(/_/g, "-")) }(a.injector.get(Yn, Wo) || Wo), this._moduleDoBootstrap(a), a)) }) }) } bootstrapModule(n, r = []) { const o = rC({}, r); return function SO(e, t, n) { const r = new Vd(n); return Promise.resolve(r) }(0, 0, n).then(i => this.bootstrapModuleFactory(i, o)) } _moduleDoBootstrap(n) { const r = n.injector.get(oc); if (n._bootstrapComponents.length > 0) n._bootstrapComponents.forEach(o => r.bootstrap(o)); else { if (!n.instance.ngDoBootstrap) throw new M(403, !1); n.instance.ngDoBootstrap(r) } this._modules.push(n) } onDestroy(n) { this._destroyListeners.push(n) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new M(404, !1); this._modules.slice().forEach(r => r.destroy()), this._destroyListeners.forEach(r => r()); const n = this._injector.get(yf, null); n && (n.forEach(r => r()), n.clear()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return e.\u0275fac = function (n) { return new (n || e)(E(Vt)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); function rC(e, t) { return Array.isArray(t) ? t.reduce(rC, e) : { ...e, ...t } } let oc = (() => { class e { constructor(n, r, o) { this._zone = n, this._injector = r, this._exceptionHandler = o, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this._destroyed = !1, this._destroyListeners = [], this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const i = new _e(a => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { a.next(this._stable), a.complete() }) }), s = new _e(a => { let c; this._zone.runOutsideAngular(() => { c = this._zone.onStable.subscribe(() => { We.assertNotInAngularZone(), df(() => { !this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, a.next(!0)) }) }) }); const u = this._zone.onUnstable.subscribe(() => { We.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { a.next(!1) })) }); return () => { c.unsubscribe(), u.unsubscribe() } }); this.isStable = Ep(i, s.pipe(Mp())) } get destroyed() { return this._destroyed } get injector() { return this._injector } bootstrap(n, r) { const o = n instanceof bm; if (!this._injector.get(nc).done) throw !o && function co(e) { const t = ue(e) || mt(e) || yt(e); return null !== t && t.standalone }(n), new M(405, false); let s; s = o ? n : this._injector.get(Gi).resolveComponentFactory(n), this.componentTypes.push(s.componentType); const a = function IO(e) { return e.isBoundToModule }(s) ? void 0 : this._injector.get(Lr), u = s.create(Vt.NULL, [], r || s.selector, a), l = u.location.nativeElement, d = u.injector.get(G_, null); return d?.registerApplication(l), u.onDestroy(() => { this.detachView(u.hostView), ic(this.components, u), d?.unregisterApplication(l) }), this._loadComponent(u), u } tick() { if (this._runningTick) throw new M(101, !1); try { this._runningTick = !0; for (let n of this._views) n.detectChanges() } catch (n) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(n)) } finally { this._runningTick = !1 } } attachView(n) { const r = n; this._views.push(r), r.attachToAppRef(this) } detachView(n) { const r = n; ic(this._views, r), r.detachFromAppRef() } _loadComponent(n) { this.attachView(n.hostView), this.tick(), this.components.push(n), this._injector.get(B_, []).concat(this._bootstrapListeners).forEach(o => o(n)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(n => n()), this._views.slice().forEach(n => n.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(n) { return this._destroyListeners.push(n), () => ic(this._destroyListeners, n) } destroy() { if (this._destroyed) throw new M(406, !1); const n = this._injector; n.destroy && !n.destroyed && n.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } } return e.\u0275fac = function (n) { return new (n || e)(E(We), E(lr), E(To)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function ic(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } let iC = !0, sc = (() => { class e { } return e.__NG_ELEMENT_ID__ = AO, e })(); function AO(e) { return function RO(e, t, n) { if (ta(e) && !n) { const r = Lt(e.index, t); return new Zi(r, r) } return 47 & e.type ? new Zi(t[16], t) : null }(He(), C(), 16 == (16 & e)) } class lC { constructor() { } supports(t) { return Yi(t) } create(t) { return new UO(t) } } const $O = (e, t) => t; class UO { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || $O } forEachItem(t) { let n; for (n = this._itHead; null !== n; n = n._next)t(n) } forEachOperation(t) { let n = this._itHead, r = this._removalsHead, o = 0, i = null; for (; n || r;) { const s = !r || n && n.currentIndex < fC(r, o, i) ? n : r, a = fC(s, o, i), c = s.currentIndex; if (s === r) o--, r = r._nextRemoved; else if (n = n._next, null == s.previousIndex) o++; else { i || (i = []); const u = a - o, l = c - o; if (u != l) { for (let f = 0; f < u; f++) { const h = f < i.length ? i[f] : i[f] = 0, p = h + f; l <= p && p < u && (i[f] = h + 1) } i[s.previousIndex] = l - u } } a !== c && t(s, a, c) } } forEachPreviousItem(t) { let n; for (n = this._previousItHead; null !== n; n = n._nextPrevious)t(n) } forEachAddedItem(t) { let n; for (n = this._additionsHead; null !== n; n = n._nextAdded)t(n) } forEachMovedItem(t) { let n; for (n = this._movesHead; null !== n; n = n._nextMoved)t(n) } forEachRemovedItem(t) { let n; for (n = this._removalsHead; null !== n; n = n._nextRemoved)t(n) } forEachIdentityChange(t) { let n; for (n = this._identityChangesHead; null !== n; n = n._nextIdentityChange)t(n) } diff(t) { if (null == t && (t = []), !Yi(t)) throw new M(900, !1); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let o, i, s, n = this._itHead, r = !1; if (Array.isArray(t)) { this.length = t.length; for (let a = 0; a < this.length; a++)i = t[a], s = this._trackByFn(a, i), null !== n && Object.is(n.trackById, s) ? (r && (n = this._verifyReinsertion(n, i, s, a)), Object.is(n.item, i) || this._addIdentityChange(n, i)) : (n = this._mismatch(n, i, s, a), r = !0), n = n._next } else o = 0, function gT(e, t) { if (Array.isArray(e)) for (let n = 0; n < e.length; n++)t(e[n]); else { const n = e[Rr()](); let r; for (; !(r = n.next()).done;)t(r.value) } }(t, a => { s = this._trackByFn(o, a), null !== n && Object.is(n.trackById, s) ? (r && (n = this._verifyReinsertion(n, a, s, o)), Object.is(n.item, a) || this._addIdentityChange(n, a)) : (n = this._mismatch(n, a, s, o), r = !0), n = n._next, o++ }), this.length = o; return this._truncate(n), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved)t.previousIndex = t.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, n, r, o) { let i; return null === t ? i = this._itTail : (i = t._prev, this._remove(t)), null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null)) ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._reinsertAfter(t, i, o)) : null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(r, o)) ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._moveAfter(t, i, o)) : t = this._addAfter(new VO(n, r), i, o), t } _verifyReinsertion(t, n, r, o) { let i = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null); return null !== i ? t = this._reinsertAfter(i, t._prev, o) : t.currentIndex != o && (t.currentIndex = o, this._addToMoves(t, o)), t } _truncate(t) { for (; null !== t;) { const n = t._next; this._addToRemovals(this._unlink(t)), t = n } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, n, r) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const o = t._prevRemoved, i = t._nextRemoved; return null === o ? this._removalsHead = i : o._nextRemoved = i, null === i ? this._removalsTail = o : i._prevRemoved = o, this._insertAfter(t, n, r), this._addToMoves(t, r), t } _moveAfter(t, n, r) { return this._unlink(t), this._insertAfter(t, n, r), this._addToMoves(t, r), t } _addAfter(t, n, r) { return this._insertAfter(t, n, r), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, n, r) { const o = null === n ? this._itHead : n._next; return t._next = o, t._prev = n, null === o ? this._itTail = t : o._prev = t, null === n ? this._itHead = t : n._next = t, null === this._linkedRecords && (this._linkedRecords = new dC), this._linkedRecords.put(t), t.currentIndex = r, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const n = t._prev, r = t._next; return null === n ? this._itHead = r : n._next = r, null === r ? this._itTail = n : r._prev = n, t } _addToMoves(t, n) { return t.previousIndex === n || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new dC), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, n) { return t.item = n, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class VO { constructor(t, n) { this.item = t, this.trackById = n, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class BO { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, n) { let r; for (r = this._head; null !== r; r = r._nextDup)if ((null === n || n <= r.currentIndex) && Object.is(r.trackById, t)) return r; return null } remove(t) { const n = t._prevDup, r = t._nextDup; return null === n ? this._head = r : n._nextDup = r, null === r ? this._tail = n : r._prevDup = n, null === this._head } } class dC { constructor() { this.map = new Map } put(t) { const n = t.trackById; let r = this.map.get(n); r || (r = new BO, this.map.set(n, r)), r.add(t) } get(t, n) { const o = this.map.get(t); return o ? o.get(t, n) : null } remove(t) { const n = t.trackById; return this.map.get(n).remove(t) && this.map.delete(n), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function fC(e, t, n) { const r = e.previousIndex; if (null === r) return r; let o = 0; return n && r < n.length && (o = n[r]), r + t + o } class hC { constructor() { } supports(t) { return t instanceof Map || Td(t) } create() { return new HO } } class HO { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let n; for (n = this._mapHead; null !== n; n = n._next)t(n) } forEachPreviousItem(t) { let n; for (n = this._previousMapHead; null !== n; n = n._nextPrevious)t(n) } forEachChangedItem(t) { let n; for (n = this._changesHead; null !== n; n = n._nextChanged)t(n) } forEachAddedItem(t) { let n; for (n = this._additionsHead; null !== n; n = n._nextAdded)t(n) } forEachRemovedItem(t) { let n; for (n = this._removalsHead; null !== n; n = n._nextRemoved)t(n) } diff(t) { if (t) { if (!(t instanceof Map || Td(t))) throw new M(900, !1) } else t = new Map; return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let n = this._mapHead; if (this._appendAfter = null, this._forEach(t, (r, o) => { if (n && n.key === o) this._maybeAddToChanges(n, r), this._appendAfter = n, n = n._next; else { const i = this._getOrCreateRecordForKey(o, r); n = this._insertBeforeOrAppend(n, i) } }), n) { n._prev && (n._prev._next = null), this._removalsHead = n; for (let r = n; null !== r; r = r._nextRemoved)r === this._mapHead && (this._mapHead = null), this._records.delete(r.key), r._nextRemoved = r._next, r.previousValue = r.currentValue, r.currentValue = null, r._prev = null, r._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, n) { if (t) { const r = t._prev; return n._next = t, n._prev = r, t._prev = n, r && (r._next = n), t === this._mapHead && (this._mapHead = n), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = n, n._prev = this._appendAfter) : this._mapHead = n, this._appendAfter = n, null } _getOrCreateRecordForKey(t, n) { if (this._records.has(t)) { const o = this._records.get(t); this._maybeAddToChanges(o, n); const i = o._prev, s = o._next; return i && (i._next = s), s && (s._prev = i), o._next = null, o._prev = null, o } const r = new zO(t); return this._records.set(t, r), r.currentValue = n, this._addToAdditions(r), r } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged)t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded)t.previousValue = t.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, n) { Object.is(n, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = n, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, n) { t instanceof Map ? t.forEach(n) : Object.keys(t).forEach(r => n(t[r], r)) } } class zO { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function pC() { return new uc([new lC]) } let uc = (() => { class e { constructor(n) { this.factories = n } static create(n, r) { if (null != r) { const o = r.factories.slice(); n = n.concat(o) } return new e(n) } static extend(n) { return { provide: e, useFactory: r => e.create(n, r || pC()), deps: [[e, new $i, new ji]] } } find(n) { const r = this.factories.find(o => o.supports(n)); if (null != r) return r; throw new M(901, !1) } } return e.\u0275prov = x({ token: e, providedIn: "root", factory: pC }), e })(); function gC() { return new us([new hC]) } let us = (() => { class e { constructor(n) { this.factories = n } static create(n, r) { if (r) { const o = r.factories.slice(); n = n.concat(o) } return new e(n) } static extend(n) { return { provide: e, useFactory: r => e.create(n, r || gC()), deps: [[e, new $i, new ji]] } } find(n) { const r = this.factories.find(o => o.supports(n)); if (r) return r; throw new M(901, !1) } } return e.\u0275prov = x({ token: e, providedIn: "root", factory: gC }), e })(); const GO = Q_(null, "core", []); let ZO = (() => { class e { constructor(n) { } } return e.\u0275fac = function (n) { return new (n || e)(E(oc)) }, e.\u0275mod = $n({ type: e }), e.\u0275inj = _n({}), e })(), lc = null; function yr() { return lc } const it = new O("DocumentToken"); let Df = (() => { class e { historyGo(n) { throw new Error("Not implemented") } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: function () { return function XO() { return E(mC) }() }, providedIn: "platform" }), e })(); const JO = new O("Location Initialized"); let mC = (() => { class e extends Df { constructor(n) { super(), this._doc = n, this._init() } _init() { this.location = window.location, this._history = window.history } getBaseHrefFromDOM() { return yr().getBaseHref(this._doc) } onPopState(n) { const r = yr().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("popstate", n, !1), () => r.removeEventListener("popstate", n) } onHashChange(n) { const r = yr().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("hashchange", n, !1), () => r.removeEventListener("hashchange", n) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(n) { this.location.pathname = n } pushState(n, r, o) { yC() ? this._history.pushState(n, r, o) : this.location.hash = o } replaceState(n, r, o) { yC() ? this._history.replaceState(n, r, o) : this.location.hash = o } forward() { this._history.forward() } back() { this._history.back() } historyGo(n = 0) { this._history.go(n) } getState() { return this._history.state } } return e.\u0275fac = function (n) { return new (n || e)(E(it)) }, e.\u0275prov = x({ token: e, factory: function () { return function eP() { return new mC(E(it)) }() }, providedIn: "platform" }), e })(); function yC() { return !!window.history.pushState } function Ef(e, t) { if (0 == e.length) return t; if (0 == t.length) return e; let n = 0; return e.endsWith("/") && n++, t.startsWith("/") && n++, 2 == n ? e + t.substring(1) : 1 == n ? e + t : e + "/" + t } function vC(e) { const t = e.match(/#|\?|$/), n = t && t.index || e.length; return e.slice(0, n - ("/" === e[n - 1] ? 1 : 0)) + e.slice(n) } function Xn(e) { return e && "?" !== e[0] ? "?" + e : e } let $r = (() => { class e { historyGo(n) { throw new Error("Not implemented") } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: function () { return Ae(CC) }, providedIn: "root" }), e })(); const _C = new O("appBaseHref"); let CC = (() => { class e extends $r { constructor(n, r) { super(), this._platformLocation = n, this._removeListenerFns = [], this._baseHref = r ?? this._platformLocation.getBaseHrefFromDOM() ?? Ae(it).location?.origin ?? "" } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(n) { this._removeListenerFns.push(this._platformLocation.onPopState(n), this._platformLocation.onHashChange(n)) } getBaseHref() { return this._baseHref } prepareExternalUrl(n) { return Ef(this._baseHref, n) } path(n = !1) { const r = this._platformLocation.pathname + Xn(this._platformLocation.search), o = this._platformLocation.hash; return o && n ? `${r}${o}` : r } pushState(n, r, o, i) { const s = this.prepareExternalUrl(o + Xn(i)); this._platformLocation.pushState(n, r, s) } replaceState(n, r, o, i) { const s = this.prepareExternalUrl(o + Xn(i)); this._platformLocation.replaceState(n, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(n = 0) { this._platformLocation.historyGo?.(n) } } return e.\u0275fac = function (n) { return new (n || e)(E(Df), E(_C, 8)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), tP = (() => { class e extends $r { constructor(n, r) { super(), this._platformLocation = n, this._baseHref = "", this._removeListenerFns = [], null != r && (this._baseHref = r) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(n) { this._removeListenerFns.push(this._platformLocation.onPopState(n), this._platformLocation.onHashChange(n)) } getBaseHref() { return this._baseHref } path(n = !1) { let r = this._platformLocation.hash; return null == r && (r = "#"), r.length > 0 ? r.substring(1) : r } prepareExternalUrl(n) { const r = Ef(this._baseHref, n); return r.length > 0 ? "#" + r : r } pushState(n, r, o, i) { let s = this.prepareExternalUrl(o + Xn(i)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(n, r, s) } replaceState(n, r, o, i) { let s = this.prepareExternalUrl(o + Xn(i)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(n, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(n = 0) { this._platformLocation.historyGo?.(n) } } return e.\u0275fac = function (n) { return new (n || e)(E(Df), E(_C, 8)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(), dc = (() => { class e { constructor(n) { this._subject = new bt, this._urlChangeListeners = [], this._urlChangeSubscription = null, this._locationStrategy = n; const r = this._locationStrategy.getBaseHref(); this._baseHref = vC(wC(r)), this._locationStrategy.onPopState(o => { this._subject.emit({ url: this.path(!0), pop: !0, state: o.state, type: o.type }) }) } ngOnDestroy() { this._urlChangeSubscription?.unsubscribe(), this._urlChangeListeners = [] } path(n = !1) { return this.normalize(this._locationStrategy.path(n)) } getState() { return this._locationStrategy.getState() } isCurrentPathEqualTo(n, r = "") { return this.path() == this.normalize(n + Xn(r)) } normalize(n) { return e.stripTrailingSlash(function rP(e, t) { return e && t.startsWith(e) ? t.substring(e.length) : t }(this._baseHref, wC(n))) } prepareExternalUrl(n) { return n && "/" !== n[0] && (n = "/" + n), this._locationStrategy.prepareExternalUrl(n) } go(n, r = "", o = null) { this._locationStrategy.pushState(o, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + Xn(r)), o) } replaceState(n, r = "", o = null) { this._locationStrategy.replaceState(o, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + Xn(r)), o) } forward() { this._locationStrategy.forward() } back() { this._locationStrategy.back() } historyGo(n = 0) { this._locationStrategy.historyGo?.(n) } onUrlChange(n) { return this._urlChangeListeners.push(n), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(r => { this._notifyUrlChangeListeners(r.url, r.state) })), () => { const r = this._urlChangeListeners.indexOf(n); this._urlChangeListeners.splice(r, 1), 0 === this._urlChangeListeners.length && (this._urlChangeSubscription?.unsubscribe(), this._urlChangeSubscription = null) } } _notifyUrlChangeListeners(n = "", r) { this._urlChangeListeners.forEach(o => o(n, r)) } subscribe(n, r, o) { return this._subject.subscribe({ next: n, error: r, complete: o }) } } return e.normalizeQueryParams = Xn, e.joinWithSlash = Ef, e.stripTrailingSlash = vC, e.\u0275fac = function (n) { return new (n || e)(E($r)) }, e.\u0275prov = x({ token: e, factory: function () { return function nP() { return new dc(E($r)) }() }, providedIn: "root" }), e })(); function wC(e) { return e.replace(/\/index.html$/, "") } let OC = (() => { class e { constructor(n, r, o, i) { this._iterableDiffers = n, this._keyValueDiffers = r, this._ngEl = o, this._renderer = i, this._iterableDiffer = null, this._keyValueDiffer = null, this._initialClasses = [], this._rawClass = null } set klass(n) { this._removeClasses(this._initialClasses), this._initialClasses = "string" == typeof n ? n.split(/\s+/) : [], this._applyClasses(this._initialClasses), this._applyClasses(this._rawClass) } set ngClass(n) { this._removeClasses(this._rawClass), this._applyClasses(this._initialClasses), this._iterableDiffer = null, this._keyValueDiffer = null, this._rawClass = "string" == typeof n ? n.split(/\s+/) : n, this._rawClass && (Yi(this._rawClass) ? this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create() : this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create()) } ngDoCheck() { if (this._iterableDiffer) { const n = this._iterableDiffer.diff(this._rawClass); n && this._applyIterableChanges(n) } else if (this._keyValueDiffer) { const n = this._keyValueDiffer.diff(this._rawClass); n && this._applyKeyValueChanges(n) } } _applyKeyValueChanges(n) { n.forEachAddedItem(r => this._toggleClass(r.key, r.currentValue)), n.forEachChangedItem(r => this._toggleClass(r.key, r.currentValue)), n.forEachRemovedItem(r => { r.previousValue && this._toggleClass(r.key, !1) }) } _applyIterableChanges(n) { n.forEachAddedItem(r => { if ("string" != typeof r.item) throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${fe(r.item)}`); this._toggleClass(r.item, !0) }), n.forEachRemovedItem(r => this._toggleClass(r.item, !1)) } _applyClasses(n) { n && (Array.isArray(n) || n instanceof Set ? n.forEach(r => this._toggleClass(r, !0)) : Object.keys(n).forEach(r => this._toggleClass(r, !!n[r]))) } _removeClasses(n) { n && (Array.isArray(n) || n instanceof Set ? n.forEach(r => this._toggleClass(r, !1)) : Object.keys(n).forEach(r => this._toggleClass(r, !1))) } _toggleClass(n, r) { (n = n.trim()) && n.split(/\s+/g).forEach(o => { r ? this._renderer.addClass(this._ngEl.nativeElement, o) : this._renderer.removeClass(this._ngEl.nativeElement, o) }) } } return e.\u0275fac = function (n) { return new (n || e)(S(uc), S(us), S(dr), S(Ta)) }, e.\u0275dir = at({ type: e, selectors: [["", "ngClass", ""]], inputs: { klass: ["class", "klass"], ngClass: "ngClass" }, standalone: !0 }), e })(); class BP { constructor(t, n, r, o) { this.$implicit = t, this.ngForOf = n, this.index = r, this.count = o } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let Yo = (() => { class e { constructor(n, r, o) { this._viewContainer = n, this._template = r, this._differs = o, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForOf(n) { this._ngForOf = n, this._ngForOfDirty = !0 } set ngForTrackBy(n) { this._trackByFn = n } get ngForTrackBy() { return this._trackByFn } set ngForTemplate(n) { n && (this._template = n) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const n = this._ngForOf; !this._differ && n && (this._differ = this._differs.find(n).create(this.ngForTrackBy)) } if (this._differ) { const n = this._differ.diff(this._ngForOf); n && this._applyChanges(n) } } _applyChanges(n) { const r = this._viewContainer; n.forEachOperation((o, i, s) => { if (null == o.previousIndex) r.createEmbeddedView(this._template, new BP(o.item, this._ngForOf, -1, -1), null === s ? void 0 : s); else if (null == s) r.remove(null === i ? void 0 : i); else if (null !== i) { const a = r.get(i); r.move(a, s), AC(a, o) } }); for (let o = 0, i = r.length; o < i; o++) { const a = r.get(o).context; a.index = o, a.count = i, a.ngForOf = this._ngForOf } n.forEachIdentityChange(o => { AC(r.get(o.currentIndex), o) }) } static ngTemplateContextGuard(n, r) { return !0 } } return e.\u0275fac = function (n) { return new (n || e)(S(fn), S(Kn), S(uc)) }, e.\u0275dir = at({ type: e, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" }, standalone: !0 }), e })(); function AC(e, t) { e.context.$implicit = t.item } let fs = (() => { class e { constructor(n, r) { this._viewContainer = n, this._context = new zP, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = r } set ngIf(n) { this._context.$implicit = this._context.ngIf = n, this._updateView() } set ngIfThen(n) { RC("ngIfThen", n), this._thenTemplateRef = n, this._thenViewRef = null, this._updateView() } set ngIfElse(n) { RC("ngIfElse", n), this._elseTemplateRef = n, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(n, r) { return !0 } } return e.\u0275fac = function (n) { return new (n || e)(S(fn), S(Kn)) }, e.\u0275dir = at({ type: e, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" }, standalone: !0 }), e })(); class zP { constructor() { this.$implicit = null, this.ngIf = null } } function RC(e, t) { if (t && !t.createEmbeddedView) throw new Error(`${e} must be a TemplateRef, but received '${fe(t)}'.`) } let FC = (() => { class e { constructor(n) { this._viewContainerRef = n, this._viewRef = null, this.ngTemplateOutletContext = null, this.ngTemplateOutlet = null, this.ngTemplateOutletInjector = null } ngOnChanges(n) { if (n.ngTemplateOutlet || n.ngTemplateOutletInjector) { const r = this._viewContainerRef; if (this._viewRef && r.remove(r.indexOf(this._viewRef)), this.ngTemplateOutlet) { const { ngTemplateOutlet: o, ngTemplateOutletContext: i, ngTemplateOutletInjector: s } = this; this._viewRef = r.createEmbeddedView(o, i, s ? { injector: s } : void 0) } else this._viewRef = null } else this._viewRef && n.ngTemplateOutletContext && this.ngTemplateOutletContext && (this._viewRef.context = this.ngTemplateOutletContext) } } return e.\u0275fac = function (n) { return new (n || e)(S(fn)) }, e.\u0275dir = at({ type: e, selectors: [["", "ngTemplateOutlet", ""]], inputs: { ngTemplateOutletContext: "ngTemplateOutletContext", ngTemplateOutlet: "ngTemplateOutlet", ngTemplateOutletInjector: "ngTemplateOutletInjector" }, standalone: !0, features: [sr] }), e })(); class KP { createSubscription(t, n) { return t.subscribe({ next: n, error: r => { throw r } }) } dispose(t) { t.unsubscribe() } } class YP { createSubscription(t, n) { return t.then(n, r => { throw r }) } dispose(t) { } } const QP = new YP, XP = new KP; let LC = (() => { class e { constructor(n) { this._latestValue = null, this._subscription = null, this._obj = null, this._strategy = null, this._ref = n } ngOnDestroy() { this._subscription && this._dispose(), this._ref = null } transform(n) { return this._obj ? n !== this._obj ? (this._dispose(), this.transform(n)) : this._latestValue : (n && this._subscribe(n), this._latestValue) } _subscribe(n) { this._obj = n, this._strategy = this._selectStrategy(n), this._subscription = this._strategy.createSubscription(n, r => this._updateLatestValue(n, r)) } _selectStrategy(n) { if (Ha(n)) return QP; if (ky(n)) return XP; throw function gn(e, t) { return new M(2100, !1) }() } _dispose() { this._strategy.dispose(this._subscription), this._latestValue = null, this._subscription = null, this._obj = null } _updateLatestValue(n, r) { n === this._obj && (this._latestValue = r, this._ref.markForCheck()) } } return e.\u0275fac = function (n) { return new (n || e)(S(sc, 16)) }, e.\u0275pipe = St({ name: "async", type: e, pure: !1, standalone: !0 }), e })(), $C = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = $n({ type: e }), e.\u0275inj = _n({}), e })(); let VC = (() => { class e { } return e.\u0275prov = x({ token: e, providedIn: "root", factory: () => new vk(E(it), window) }), e })(); class vk { constructor(t, n) { this.document = t, this.window = n, this.offset = () => [0, 0] } setOffset(t) { this.offset = Array.isArray(t) ? () => t : t } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(t) { this.supportsScrolling() && this.window.scrollTo(t[0], t[1]) } scrollToAnchor(t) { if (!this.supportsScrolling()) return; const n = function _k(e, t) { const n = e.getElementById(t) || e.getElementsByName(t)[0]; if (n) return n; if ("function" == typeof e.createTreeWalker && e.body && (e.body.createShadowRoot || e.body.attachShadow)) { const r = e.createTreeWalker(e.body, NodeFilter.SHOW_ELEMENT); let o = r.currentNode; for (; o;) { const i = o.shadowRoot; if (i) { const s = i.getElementById(t) || i.querySelector(`[name="${t}"]`); if (s) return s } o = r.nextNode() } } return null }(this.document, t); n && (this.scrollToElement(n), n.focus()) } setHistoryScrollRestoration(t) { if (this.supportScrollRestoration()) { const n = this.window.history; n && n.scrollRestoration && (n.scrollRestoration = t) } } scrollToElement(t) { const n = t.getBoundingClientRect(), r = n.left + this.window.pageXOffset, o = n.top + this.window.pageYOffset, i = this.offset(); this.window.scrollTo(r - i[0], o - i[1]) } supportScrollRestoration() { try { if (!this.supportsScrolling()) return !1; const t = BC(this.window.history) || BC(Object.getPrototypeOf(this.window.history)); return !(!t || !t.writable && !t.set) } catch { return !1 } } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch { return !1 } } } function BC(e) { return Object.getOwnPropertyDescriptor(e, "scrollRestoration") } class Uf extends class Gk extends class QO { }{ constructor() { super(...arguments), this.supportsDOMEvents = !0 } }{ static makeCurrent() { !function YO(e) { lc || (lc = e) }(new Uf) } onAndCancel(t, n, r) { return t.addEventListener(n, r, !1), () => { t.removeEventListener(n, r, !1) } } dispatchEvent(t, n) { t.dispatchEvent(n) } remove(t) { t.parentNode && t.parentNode.removeChild(t) } createElement(t, n) { return (n = n || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, n) { return "window" === n ? window : "document" === n ? t : "body" === n ? t.body : null } getBaseHref(t) { const n = function Zk() { return ps = ps || document.querySelector("base"), ps ? ps.getAttribute("href") : null }(); return null == n ? null : function Kk(e) { Dc = Dc || document.createElement("a"), Dc.setAttribute("href", e); const t = Dc.pathname; return "/" === t.charAt(0) ? t : `/${t}` }(n) } resetBaseElement() { ps = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return function UP(e, t) { t = encodeURIComponent(t); for (const n of e.split(";")) { const r = n.indexOf("="), [o, i] = -1 == r ? [n, ""] : [n.slice(0, r), n.slice(r + 1)]; if (o.trim() === t) return decodeURIComponent(i) } return null }(document.cookie, t) } } let Dc, ps = null; const GC = new O("TRANSITION_ID"), Qk = [{ provide: tc, useFactory: function Yk(e, t, n) { return () => { n.get(nc).donePromise.then(() => { const r = yr(), o = t.querySelectorAll(`style[ng-transition="${e}"]`); for (let i = 0; i < o.length; i++)r.remove(o[i]) }) } }, deps: [GC, it, Vt], multi: !0 }]; let Jk = (() => { class e { build() { return new XMLHttpRequest } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); const Ec = new O("EventManagerPlugins"); let Mc = (() => { class e { constructor(n, r) { this._zone = r, this._eventNameToPlugin = new Map, n.forEach(o => o.manager = this), this._plugins = n.slice().reverse() } addEventListener(n, r, o) { return this._findPluginFor(r).addEventListener(n, r, o) } addGlobalEventListener(n, r, o) { return this._findPluginFor(r).addGlobalEventListener(n, r, o) } getZone() { return this._zone } _findPluginFor(n) { const r = this._eventNameToPlugin.get(n); if (r) return r; const o = this._plugins; for (let i = 0; i < o.length; i++) { const s = o[i]; if (s.supports(n)) return this._eventNameToPlugin.set(n, s), s } throw new Error(`No event manager plugin found for event ${n}`) } } return e.\u0275fac = function (n) { return new (n || e)(E(Ec), E(We)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); class ZC { constructor(t) { this._doc = t } addGlobalEventListener(t, n, r) { const o = yr().getGlobalEventTarget(this._doc, t); if (!o) throw new Error(`Unsupported event target ${o} for event ${n}`); return this.addEventListener(o, n, r) } } let KC = (() => { class e { constructor() { this._stylesSet = new Set } addStyles(n) { const r = new Set; n.forEach(o => { this._stylesSet.has(o) || (this._stylesSet.add(o), r.add(o)) }), this.onStylesAdded(r) } onStylesAdded(n) { } getAllStyles() { return Array.from(this._stylesSet) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(), gs = (() => { class e extends KC { constructor(n) { super(), this._doc = n, this._hostNodes = new Map, this._hostNodes.set(n.head, []) } _addStylesToHost(n, r, o) { n.forEach(i => { const s = this._doc.createElement("style"); s.textContent = i, o.push(r.appendChild(s)) }) } addHost(n) { const r = []; this._addStylesToHost(this._stylesSet, n, r), this._hostNodes.set(n, r) } removeHost(n) { const r = this._hostNodes.get(n); r && r.forEach(YC), this._hostNodes.delete(n) } onStylesAdded(n) { this._hostNodes.forEach((r, o) => { this._addStylesToHost(n, o, r) }) } ngOnDestroy() { this._hostNodes.forEach(n => n.forEach(YC)) } } return e.\u0275fac = function (n) { return new (n || e)(E(it)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); function YC(e) { yr().remove(e) } const Vf = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, Bf = /%COMP%/g; function Sc(e, t, n) { for (let r = 0; r < t.length; r++) { let o = t[r]; Array.isArray(o) ? Sc(e, o, n) : (o = o.replace(Bf, e), n.push(o)) } return n } function JC(e) { return t => { if ("__ngUnwrap__" === t) return e; !1 === e(t) && (t.preventDefault(), t.returnValue = !1) } } let Hf = (() => { class e { constructor(n, r, o) { this.eventManager = n, this.sharedStylesHost = r, this.appId = o, this.rendererByCompId = new Map, this.defaultRenderer = new zf(n) } createRenderer(n, r) { if (!n || !r) return this.defaultRenderer; switch (r.encapsulation) { case Cn.Emulated: { let o = this.rendererByCompId.get(r.id); return o || (o = new iA(this.eventManager, this.sharedStylesHost, r, this.appId), this.rendererByCompId.set(r.id, o)), o.applyToHost(n), o } case 1: case Cn.ShadowDom: return new sA(this.eventManager, this.sharedStylesHost, n, r); default: if (!this.rendererByCompId.has(r.id)) { const o = Sc(r.id, r.styles, []); this.sharedStylesHost.addStyles(o), this.rendererByCompId.set(r.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return e.\u0275fac = function (n) { return new (n || e)(E(Mc), E(gs), E(cs)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); class zf { constructor(t) { this.eventManager = t, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(t, n) { return n ? document.createElementNS(Vf[n] || n, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, n) { (tw(t) ? t.content : t).appendChild(n) } insertBefore(t, n, r) { t && (tw(t) ? t.content : t).insertBefore(n, r) } removeChild(t, n) { t && t.removeChild(n) } selectRootElement(t, n) { let r = "string" == typeof t ? document.querySelector(t) : t; if (!r) throw new Error(`The selector "${t}" did not match any elements`); return n || (r.textContent = ""), r } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, n, r, o) { if (o) { n = o + ":" + n; const i = Vf[o]; i ? t.setAttributeNS(i, n, r) : t.setAttribute(n, r) } else t.setAttribute(n, r) } removeAttribute(t, n, r) { if (r) { const o = Vf[r]; o ? t.removeAttributeNS(o, n) : t.removeAttribute(`${r}:${n}`) } else t.removeAttribute(n) } addClass(t, n) { t.classList.add(n) } removeClass(t, n) { t.classList.remove(n) } setStyle(t, n, r, o) { o & (Tt.DashCase | Tt.Important) ? t.style.setProperty(n, r, o & Tt.Important ? "important" : "") : t.style[n] = r } removeStyle(t, n, r) { r & Tt.DashCase ? t.style.removeProperty(n) : t.style[n] = "" } setProperty(t, n, r) { t[n] = r } setValue(t, n) { t.nodeValue = n } listen(t, n, r) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, n, JC(r)) : this.eventManager.addEventListener(t, n, JC(r)) } } function tw(e) { return "TEMPLATE" === e.tagName && void 0 !== e.content } class iA extends zf { constructor(t, n, r, o) { super(t), this.component = r; const i = Sc(o + "-" + r.id, r.styles, []); n.addStyles(i), this.contentAttr = function nA(e) { return "_ngcontent-%COMP%".replace(Bf, e) }(o + "-" + r.id), this.hostAttr = function rA(e) { return "_nghost-%COMP%".replace(Bf, e) }(o + "-" + r.id) } applyToHost(t) { super.setAttribute(t, this.hostAttr, "") } createElement(t, n) { const r = super.createElement(t, n); return super.setAttribute(r, this.contentAttr, ""), r } } class sA extends zf { constructor(t, n, r, o) { super(t), this.sharedStylesHost = n, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const i = Sc(o.id, o.styles, []); for (let s = 0; s < i.length; s++) { const a = document.createElement("style"); a.textContent = i[s], this.shadowRoot.appendChild(a) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(t, n) { return super.appendChild(this.nodeOrShadowRoot(t), n) } insertBefore(t, n, r) { return super.insertBefore(this.nodeOrShadowRoot(t), n, r) } removeChild(t, n) { return super.removeChild(this.nodeOrShadowRoot(t), n) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } } let aA = (() => { class e extends ZC { constructor(n) { super(n) } supports(n) { return !0 } addEventListener(n, r, o) { return n.addEventListener(r, o, !1), () => this.removeEventListener(n, r, o) } removeEventListener(n, r, o) { return n.removeEventListener(r, o) } } return e.\u0275fac = function (n) { return new (n || e)(E(it)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); const nw = ["alt", "control", "meta", "shift"], cA = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, uA = { alt: e => e.altKey, control: e => e.ctrlKey, meta: e => e.metaKey, shift: e => e.shiftKey }; let lA = (() => { class e extends ZC { constructor(n) { super(n) } supports(n) { return null != e.parseEventName(n) } addEventListener(n, r, o) { const i = e.parseEventName(r), s = e.eventCallback(i.fullKey, o, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => yr().onAndCancel(n, i.domEventName, s)) } static parseEventName(n) { const r = n.toLowerCase().split("."), o = r.shift(); if (0 === r.length || "keydown" !== o && "keyup" !== o) return null; const i = e._normalizeKey(r.pop()); let s = "", a = r.indexOf("code"); if (a > -1 && (r.splice(a, 1), s = "code."), nw.forEach(u => { const l = r.indexOf(u); l > -1 && (r.splice(l, 1), s += u + ".") }), s += i, 0 != r.length || 0 === i.length) return null; const c = {}; return c.domEventName = o, c.fullKey = s, c } static matchEventFullKeyCode(n, r) { let o = cA[n.key] || n.key, i = ""; return r.indexOf("code.") > -1 && (o = n.code, i = "code."), !(null == o || !o) && (o = o.toLowerCase(), " " === o ? o = "space" : "." === o && (o = "dot"), nw.forEach(s => { s !== o && (0, uA[s])(n) && (i += s + ".") }), i += o, i === r) } static eventCallback(n, r, o) { return i => { e.matchEventFullKeyCode(i, n) && o.runGuarded(() => r(i)) } } static _normalizeKey(n) { return "esc" === n ? "escape" : n } } return e.\u0275fac = function (n) { return new (n || e)(E(it)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); const ow = [{ provide: V_, useValue: "browser" }, { provide: U_, useValue: function dA() { Uf.makeCurrent() }, multi: !0 }, { provide: it, useFactory: function hA() { return function qM(e) { $l = e }(document), document }, deps: [] }], pA = Q_(GO, "browser", ow), iw = new O(""), sw = [{ provide: rc, useClass: class Xk { addToWindow(t) { he.getAngularTestability = (r, o = !0) => { const i = t.findTestabilityInTree(r, o); if (null == i) throw new Error("Could not find testability for element."); return i }, he.getAllAngularTestabilities = () => t.getAllTestabilities(), he.getAllAngularRootElements = () => t.getAllRootElements(), he.frameworkStabilizers || (he.frameworkStabilizers = []), he.frameworkStabilizers.push(r => { const o = he.getAllAngularTestabilities(); let i = o.length, s = !1; const a = function (c) { s = s || c, i--, 0 == i && r(s) }; o.forEach(function (c) { c.whenStable(a) }) }) } findTestabilityInTree(t, n, r) { return null == n ? null : t.getTestability(n) ?? (r ? yr().isShadowRoot(n) ? this.findTestabilityInTree(t, n.host, !0) : this.findTestabilityInTree(t, n.parentElement, !0) : null) } }, deps: [] }, { provide: G_, useClass: pf, deps: [We, gf, rc] }, { provide: pf, useClass: pf, deps: [We, gf, rc] }], aw = [{ provide: Gl, useValue: "root" }, { provide: To, useFactory: function fA() { return new To }, deps: [] }, { provide: Ec, useClass: aA, multi: !0, deps: [it, We, V_] }, { provide: Ec, useClass: lA, multi: !0, deps: [it] }, { provide: Hf, useClass: Hf, deps: [Mc, gs, cs] }, { provide: Em, useExisting: Hf }, { provide: KC, useExisting: gs }, { provide: gs, useClass: gs, deps: [it] }, { provide: Mc, useClass: Mc, deps: [Ec, We] }, { provide: class Ck { }, useClass: Jk, deps: [] }, []]; let gA = (() => { class e { constructor(n) { } static withServerTransition(n) { return { ngModule: e, providers: [{ provide: cs, useValue: n.appId }, { provide: GC, useExisting: cs }, Qk] } } } return e.\u0275fac = function (n) { return new (n || e)(E(iw, 12)) }, e.\u0275mod = $n({ type: e }), e.\u0275inj = _n({ providers: [...aw, ...sw], imports: [$C, ZO] }), e })(), cw = (() => { class e { constructor(n) { this._doc = n } getTitle() { return this._doc.title } setTitle(n) { this._doc.title = n || "" } } return e.\u0275fac = function (n) { return new (n || e)(E(it)) }, e.\u0275prov = x({ token: e, factory: function (n) { let r = null; return r = n ? new n : function yA() { return new cw(E(it)) }(), r }, providedIn: "root" }), e })(); typeof window < "u" && window; let dw = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: function (n) { let r = null; return r = n ? new (n || e) : E(fw), r }, providedIn: "root" }), e })(), fw = (() => { class e extends dw { constructor(n) { super(), this._doc = n } sanitize(n, r) { if (null == r) return null; switch (n) { case ge.NONE: return r; case ge.HTML: return Dn(r, "HTML") ? Ut(r) : dm(this._doc, String(r)).toString(); case ge.STYLE: return Dn(r, "Style") ? Ut(r) : r; case ge.SCRIPT: if (Dn(r, "Script")) return Ut(r); throw new Error("unsafe value used in a script context"); case ge.URL: return Dn(r, "URL") ? Ut(r) : Ea(String(r)); case ge.RESOURCE_URL: if (Dn(r, "ResourceURL")) return Ut(r); throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)"); default: throw new Error(`Unexpected SecurityContext ${n} (see https://g.co/ng/security#xss)`) } } bypassSecurityTrustHtml(n) { return function XM(e) { return new WM(e) }(n) } bypassSecurityTrustStyle(n) { return function JM(e) { return new GM(e) }(n) } bypassSecurityTrustScript(n) { return function eS(e) { return new ZM(e) }(n) } bypassSecurityTrustUrl(n) { return function tS(e) { return new KM(e) }(n) } bypassSecurityTrustResourceUrl(n) { return function nS(e) { return new YM(e) }(n) } } return e.\u0275fac = function (n) { return new (n || e)(E(it)) }, e.\u0275prov = x({ token: e, factory: function (n) { let r = null; return r = n ? new n : function EA(e) { return new fw(e.get(it)) }(E(Vt)), r }, providedIn: "root" }), e })(); function T(...e) { return Ie(e, Ci(e)) } class ht extends Pt { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const n = super._subscribe(t); return !n.closed && t.next(this._value), n } getValue() { const { hasError: t, thrownError: n, _value: r } = this; if (t) throw n; return this._throwIfClosed(), r } next(t) { super.next(this._value = t) } } const ms = ve(e => function () { e(this), this.name = "EmptyError", this.message = "no elements in sequence" }), { isArray: MA } = Array, { getPrototypeOf: SA, prototype: IA, keys: TA } = Object; const { isArray: PA } = Array; function hw(...e) { const t = Ci(e), n = Cp(e), { args: r, keys: o } = function xA(e) { if (1 === e.length) { const t = e[0]; if (MA(t)) return { args: t, keys: null }; if (function OA(e) { return e && "object" == typeof e && SA(e) === IA }(t)) { const n = TA(t); return { args: n.map(r => t[r]), keys: n } } } return { args: e, keys: null } }(e); if (0 === r.length) return Ie([], t); const i = new _e(function NA(e, t, n = Rn) { return r => { pw(t, () => { const { length: o } = e, i = new Array(o); let s = o, a = o; for (let c = 0; c < o; c++)pw(t, () => { const u = Ie(e[c], t); let l = !1; u.subscribe(Se(r, d => { i[c] = d, l || (l = !0, a--), a || r.next(n(i.slice())) }, () => { --s || r.complete() })) }, r) }, r) } }(r, t, o ? s => function RA(e, t) { return e.reduce((n, r, o) => (n[r] = t[o], n), {}) }(o, s) : Rn)); return n ? i.pipe(function AA(e) { return H(t => function kA(e, t) { return PA(t) ? e(...t) : e(t) }(e, t)) }(n)) : i } function pw(e, t, n) { e ? Nn(n, e, t) : t() } function Gf(...e) { return function FA() { return so(1) }()(Ie(e, Ci(e))) } function Qo(e) { return new _e(t => { Wt(e()).subscribe(t) }) } function Ur(e, t) { const n = V(e) ? e : () => e, r = o => o.error(n()); return new _e(t ? o => t.schedule(r, 0, o) : r) } function Zf() { return ke((e, t) => { let n = null; e._refCount++; const r = Se(t, void 0, void 0, void 0, () => { if (!e || e._refCount <= 0 || 0 < --e._refCount) return void (n = null); const o = e._connection, i = n; n = null, o && (!i || o === i) && o.unsubscribe(), t.unsubscribe() }); e.subscribe(r), r.closed || (n = e.connect()) }) } class gw extends _e { constructor(t, n) { super(), this.source = t, this.subjectFactory = n, this._subject = null, this._refCount = 0, this._connection = null, sp(t) && (this.lift = t.lift) } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return (!t || t.isStopped) && (this._subject = this.subjectFactory()), this._subject } _teardown() { this._refCount = 0; const { _connection: t } = this; this._subject = this._connection = null, t?.unsubscribe() } connect() { let t = this._connection; if (!t) { t = this._connection = new Me; const n = this.getSubject(); t.add(this.source.subscribe(Se(n, void 0, () => { this._teardown(), n.complete() }, r => { this._teardown(), n.error(r) }, () => this._teardown()))), t.closed && (this._connection = null, t = Me.EMPTY) } return t } refCount() { return Zf()(this) } } function Jt(e, t) { return ke((n, r) => { let o = null, i = 0, s = !1; const a = () => s && !o && r.complete(); n.subscribe(Se(r, c => { o?.unsubscribe(); let u = 0; const l = i++; Wt(e(c, l)).subscribe(o = Se(r, d => r.next(t ? t(c, d, l, u++) : d), () => { o = null, a() })) }, () => { s = !0, a() })) }) } function Xo(e) { return e <= 0 ? () => Fn : ke((t, n) => { let r = 0; t.subscribe(Se(n, o => { ++r <= e && (n.next(o), e <= r && n.complete()) })) }) } function Ze(e, t) { return ke((n, r) => { let o = 0; n.subscribe(Se(r, i => e.call(t, i, o++) && r.next(i))) }) } function Ic(e) { return ke((t, n) => { let r = !1; t.subscribe(Se(n, o => { r = !0, n.next(o) }, () => { r || n.next(e), n.complete() })) }) } function mw(e = jA) { return ke((t, n) => { let r = !1; t.subscribe(Se(n, o => { r = !0, n.next(o) }, () => r ? n.complete() : n.error(e()))) }) } function jA() { return new ms } function _r(e, t) { const n = arguments.length >= 2; return r => r.pipe(e ? Ze((o, i) => e(o, i, r)) : Rn, Xo(1), n ? Ic(t) : mw(() => new ms)) } function mn(e, t) { return V(t) ? Be(e, t, 1) : Be(e, 1) } function Fe(e, t, n) { const r = V(e) || t || n ? { next: e, error: t, complete: n } : e; return r ? ke((o, i) => { var s; null === (s = r.subscribe) || void 0 === s || s.call(r); let a = !0; o.subscribe(Se(i, c => { var u; null === (u = r.next) || void 0 === u || u.call(r, c), i.next(c) }, () => { var c; a = !1, null === (c = r.complete) || void 0 === c || c.call(r), i.complete() }, c => { var u; a = !1, null === (u = r.error) || void 0 === u || u.call(r, c), i.error(c) }, () => { var c, u; a && (null === (c = r.unsubscribe) || void 0 === c || c.call(r)), null === (u = r.finalize) || void 0 === u || u.call(r) })) }) : Rn } function yn(e) { return ke((t, n) => { let i, r = null, o = !1; r = t.subscribe(Se(n, void 0, void 0, s => { i = Wt(e(s, yn(e)(t))), r ? (r.unsubscribe(), r = null, i.subscribe(n)) : o = !0 })), o && (r.unsubscribe(), r = null, i.subscribe(n)) }) } function $A(e, t, n, r, o) { return (i, s) => { let a = n, c = t, u = 0; i.subscribe(Se(s, l => { const d = u++; c = a ? e(c, l, d) : (a = !0, l), r && s.next(c) }, o && (() => { a && s.next(c), s.complete() }))) } } function Kf(e, t) { return ke($A(e, t, arguments.length >= 2, !0)) } function Yf(e) { return e <= 0 ? () => Fn : ke((t, n) => { let r = []; t.subscribe(Se(n, o => { r.push(o), e < r.length && r.shift() }, () => { for (const o of r) n.next(o); n.complete() }, void 0, () => { r = null })) }) } function yw(e, t) { const n = arguments.length >= 2; return r => r.pipe(e ? Ze((o, i) => e(o, i, r)) : Rn, Yf(1), n ? Ic(t) : mw(() => new ms)) } function Qf(e) { return ke((t, n) => { try { t.subscribe(n) } finally { n.add(e) } }) } const G = "primary", ys = Symbol("RouteTitle"); class BA { constructor(t) { this.params = t || {} } has(t) { return Object.prototype.hasOwnProperty.call(this.params, t) } get(t) { if (this.has(t)) { const n = this.params[t]; return Array.isArray(n) ? n[0] : n } return null } getAll(t) { if (this.has(t)) { const n = this.params[t]; return Array.isArray(n) ? n : [n] } return [] } get keys() { return Object.keys(this.params) } } function Jo(e) { return new BA(e) } function HA(e, t, n) { const r = n.path.split("/"); if (r.length > e.length || "full" === n.pathMatch && (t.hasChildren() || r.length < e.length)) return null; const o = {}; for (let i = 0; i < r.length; i++) { const s = r[i], a = e[i]; if (s.startsWith(":")) o[s.substring(1)] = a; else if (s !== a.path) return null } return { consumed: e.slice(0, r.length), posParams: o } } function Tn(e, t) { const n = e ? Object.keys(e) : void 0, r = t ? Object.keys(t) : void 0; if (!n || !r || n.length != r.length) return !1; let o; for (let i = 0; i < n.length; i++)if (o = n[i], !vw(e[o], t[o])) return !1; return !0 } function vw(e, t) { if (Array.isArray(e) && Array.isArray(t)) { if (e.length !== t.length) return !1; const n = [...e].sort(), r = [...t].sort(); return n.every((o, i) => r[i] === o) } return e === t } function _w(e) { return Array.prototype.concat.apply([], e) } function Cw(e) { return e.length > 0 ? e[e.length - 1] : null } function st(e, t) { for (const n in e) e.hasOwnProperty(n) && t(e[n], n) } function Cr(e) { return Ay(e) ? e : Ha(e) ? Ie(Promise.resolve(e)) : T(e) } const WA = { exact: function Dw(e, t, n) { if (!Br(e.segments, t.segments) || !Tc(e.segments, t.segments, n) || e.numberOfChildren !== t.numberOfChildren) return !1; for (const r in t.children) if (!e.children[r] || !Dw(e.children[r], t.children[r], n)) return !1; return !0 }, subset: Ew }, ww = { exact: function GA(e, t) { return Tn(e, t) }, subset: function ZA(e, t) { return Object.keys(t).length <= Object.keys(e).length && Object.keys(t).every(n => vw(e[n], t[n])) }, ignored: () => !0 }; function bw(e, t, n) { return WA[n.paths](e.root, t.root, n.matrixParams) && ww[n.queryParams](e.queryParams, t.queryParams) && !("exact" === n.fragment && e.fragment !== t.fragment) } function Ew(e, t, n) { return Mw(e, t, t.segments, n) } function Mw(e, t, n, r) { if (e.segments.length > n.length) { const o = e.segments.slice(0, n.length); return !(!Br(o, n) || t.hasChildren() || !Tc(o, n, r)) } if (e.segments.length === n.length) { if (!Br(e.segments, n) || !Tc(e.segments, n, r)) return !1; for (const o in t.children) if (!e.children[o] || !Ew(e.children[o], t.children[o], r)) return !1; return !0 } { const o = n.slice(0, e.segments.length), i = n.slice(e.segments.length); return !!(Br(e.segments, o) && Tc(e.segments, o, r) && e.children[G]) && Mw(e.children[G], t, i, r) } } function Tc(e, t, n) { return t.every((r, o) => ww[n](e[o].parameters, r.parameters)) } class Vr { constructor(t, n, r) { this.root = t, this.queryParams = n, this.fragment = r } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Jo(this.queryParams)), this._queryParamMap } toString() { return QA.serialize(this) } } class Y { constructor(t, n) { this.segments = t, this.children = n, this.parent = null, st(n, (r, o) => r.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return xc(this) } } class vs { constructor(t, n) { this.path = t, this.parameters = n } get parameterMap() { return this._parameterMap || (this._parameterMap = Jo(this.parameters)), this._parameterMap } toString() { return xw(this) } } function Br(e, t) { return e.length === t.length && e.every((n, r) => n.path === t[r].path) } let Sw = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: function () { return new Jf }, providedIn: "root" }), e })(); class Jf { parse(t) { const n = new sR(t); return new Vr(n.parseRootSegment(), n.parseQueryParams(), n.parseFragment()) } serialize(t) { const n = `/${_s(t.root, !0)}`, r = function eR(e) { const t = Object.keys(e).map(n => { const r = e[n]; return Array.isArray(r) ? r.map(o => `${Oc(n)}=${Oc(o)}`).join("&") : `${Oc(n)}=${Oc(r)}` }).filter(n => !!n); return t.length ? `?${t.join("&")}` : "" }(t.queryParams); return `${n}${r}${"string" == typeof t.fragment ? `#${function XA(e) { return encodeURI(e) }(t.fragment)}` : ""}` } } const QA = new Jf; function xc(e) { return e.segments.map(t => xw(t)).join("/") } function _s(e, t) { if (!e.hasChildren()) return xc(e); if (t) { const n = e.children[G] ? _s(e.children[G], !1) : "", r = []; return st(e.children, (o, i) => { i !== G && r.push(`${i}:${_s(o, !1)}`) }), r.length > 0 ? `${n}(${r.join("//")})` : n } { const n = function YA(e, t) { let n = []; return st(e.children, (r, o) => { o === G && (n = n.concat(t(r, o))) }), st(e.children, (r, o) => { o !== G && (n = n.concat(t(r, o))) }), n }(e, (r, o) => o === G ? [_s(e.children[G], !1)] : [`${o}:${_s(r, !1)}`]); return 1 === Object.keys(e.children).length && null != e.children[G] ? `${xc(e)}/${n[0]}` : `${xc(e)}/(${n.join("//")})` } } function Iw(e) { return encodeURIComponent(e).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function Oc(e) { return Iw(e).replace(/%3B/gi, ";") } function eh(e) { return Iw(e).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function Pc(e) { return decodeURIComponent(e) } function Tw(e) { return Pc(e.replace(/\+/g, "%20")) } function xw(e) { return `${eh(e.path)}${function JA(e) { return Object.keys(e).map(t => `;${eh(t)}=${eh(e[t])}`).join("") }(e.parameters)}` } const tR = /^[^\/()?;=#]+/; function kc(e) { const t = e.match(tR); return t ? t[0] : "" } const nR = /^[^=?&#]+/, oR = /^[^&#]+/; class sR { constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new Y([], {}) : new Y([], this.parseChildren()) } parseQueryParams() { const t = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(t) } while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let n = {}; this.peekStartsWith("/(") && (this.capture("/"), n = this.parseParens(!0)); let r = {}; return this.peekStartsWith("(") && (r = this.parseParens(!1)), (t.length > 0 || Object.keys(n).length > 0) && (r[G] = new Y(t, n)), r } parseSegment() { const t = kc(this.remaining); if ("" === t && this.peekStartsWith(";")) throw new M(4009, !1); return this.capture(t), new vs(Pc(t), this.parseMatrixParams()) } parseMatrixParams() { const t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { const n = kc(this.remaining); if (!n) return; this.capture(n); let r = ""; if (this.consumeOptional("=")) { const o = kc(this.remaining); o && (r = o, this.capture(r)) } t[Pc(n)] = Pc(r) } parseQueryParam(t) { const n = function rR(e) { const t = e.match(nR); return t ? t[0] : "" }(this.remaining); if (!n) return; this.capture(n); let r = ""; if (this.consumeOptional("=")) { const s = function iR(e) { const t = e.match(oR); return t ? t[0] : "" }(this.remaining); s && (r = s, this.capture(r)) } const o = Tw(n), i = Tw(r); if (t.hasOwnProperty(o)) { let s = t[o]; Array.isArray(s) || (s = [s], t[o] = s), s.push(i) } else t[o] = i } parseParens(t) { const n = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const r = kc(this.remaining), o = this.remaining[r.length]; if ("/" !== o && ")" !== o && ";" !== o) throw new M(4010, !1); let i; r.indexOf(":") > -1 ? (i = r.slice(0, r.indexOf(":")), this.capture(i), this.capture(":")) : t && (i = G); const s = this.parseChildren(); n[i] = 1 === Object.keys(s).length ? s[G] : new Y([], s), this.consumeOptional("//") } return n } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0) } capture(t) { if (!this.consumeOptional(t)) throw new M(4011, !1) } } function th(e) { return e.segments.length > 0 ? new Y([], { [G]: e }) : e } function Ac(e) { const t = {}; for (const r of Object.keys(e.children)) { const i = Ac(e.children[r]); (i.segments.length > 0 || i.hasChildren()) && (t[r] = i) } return function aR(e) { if (1 === e.numberOfChildren && e.children[G]) { const t = e.children[G]; return new Y(e.segments.concat(t.segments), t.children) } return e }(new Y(e.segments, t)) } function Hr(e) { return e instanceof Vr } function lR(e, t, n, r, o) { if (0 === n.length) return ei(t.root, t.root, t.root, r, o); const i = function kw(e) { if ("string" == typeof e[0] && 1 === e.length && "/" === e[0]) return new Pw(!0, 0, e); let t = 0, n = !1; const r = e.reduce((o, i, s) => { if ("object" == typeof i && null != i) { if (i.outlets) { const a = {}; return st(i.outlets, (c, u) => { a[u] = "string" == typeof c ? c.split("/") : c }), [...o, { outlets: a }] } if (i.segmentPath) return [...o, i.segmentPath] } return "string" != typeof i ? [...o, i] : 0 === s ? (i.split("/").forEach((a, c) => { 0 == c && "." === a || (0 == c && "" === a ? n = !0 : ".." === a ? t++ : "" != a && o.push(a)) }), o) : [...o, i] }, []); return new Pw(n, t, r) }(n); return i.toRoot() ? ei(t.root, t.root, new Y([], {}), r, o) : function s(c) { const u = function fR(e, t, n, r) { if (e.isAbsolute) return new ti(t.root, !0, 0); if (-1 === r) return new ti(n, n === t.root, 0); return function Aw(e, t, n) { let r = e, o = t, i = n; for (; i > o;) { if (i -= o, r = r.parent, !r) throw new M(4005, !1); o = r.segments.length } return new ti(r, !1, o - i) }(n, r + (Cs(e.commands[0]) ? 0 : 1), e.numberOfDoubleDots) }(i, t, e.snapshot?._urlSegment, c), l = u.processChildren ? bs(u.segmentGroup, u.index, i.commands) : rh(u.segmentGroup, u.index, i.commands); return ei(t.root, u.segmentGroup, l, r, o) }(e.snapshot?._lastPathIndex) } function Cs(e) { return "object" == typeof e && null != e && !e.outlets && !e.segmentPath } function ws(e) { return "object" == typeof e && null != e && e.outlets } function ei(e, t, n, r, o) { let s, i = {}; r && st(r, (c, u) => { i[u] = Array.isArray(c) ? c.map(l => `${l}`) : `${c}` }), s = e === t ? n : Ow(e, t, n); const a = th(Ac(s)); return new Vr(a, i, o) } function Ow(e, t, n) { const r = {}; return st(e.children, (o, i) => { r[i] = o === t ? n : Ow(o, t, n) }), new Y(e.segments, r) } class Pw { constructor(t, n, r) { if (this.isAbsolute = t, this.numberOfDoubleDots = n, this.commands = r, t && r.length > 0 && Cs(r[0])) throw new M(4003, !1); const o = r.find(ws); if (o && o !== Cw(r)) throw new M(4004, !1) } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class ti { constructor(t, n, r) { this.segmentGroup = t, this.processChildren = n, this.index = r } } function rh(e, t, n) { if (e || (e = new Y([], {})), 0 === e.segments.length && e.hasChildren()) return bs(e, t, n); const r = function pR(e, t, n) { let r = 0, o = t; const i = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; o < e.segments.length;) { if (r >= n.length) return i; const s = e.segments[o], a = n[r]; if (ws(a)) break; const c = `${a}`, u = r < n.length - 1 ? n[r + 1] : null; if (o > 0 && void 0 === c) break; if (c && u && "object" == typeof u && void 0 === u.outlets) { if (!Nw(c, u, s)) return i; r += 2 } else { if (!Nw(c, {}, s)) return i; r++ } o++ } return { match: !0, pathIndex: o, commandIndex: r } }(e, t, n), o = n.slice(r.commandIndex); if (r.match && r.pathIndex < e.segments.length) { const i = new Y(e.segments.slice(0, r.pathIndex), {}); return i.children[G] = new Y(e.segments.slice(r.pathIndex), e.children), bs(i, 0, o) } return r.match && 0 === o.length ? new Y(e.segments, {}) : r.match && !e.hasChildren() ? oh(e, t, n) : r.match ? bs(e, 0, o) : oh(e, t, n) } function bs(e, t, n) { if (0 === n.length) return new Y(e.segments, {}); { const r = function hR(e) { return ws(e[0]) ? e[0].outlets : { [G]: e } }(n), o = {}; return st(r, (i, s) => { "string" == typeof i && (i = [i]), null !== i && (o[s] = rh(e.children[s], t, i)) }), st(e.children, (i, s) => { void 0 === r[s] && (o[s] = i) }), new Y(e.segments, o) } } function oh(e, t, n) { const r = e.segments.slice(0, t); let o = 0; for (; o < n.length;) { const i = n[o]; if (ws(i)) { const c = gR(i.outlets); return new Y(r, c) } if (0 === o && Cs(n[0])) { r.push(new vs(e.segments[t].path, Rw(n[0]))), o++; continue } const s = ws(i) ? i.outlets[G] : `${i}`, a = o < n.length - 1 ? n[o + 1] : null; s && a && Cs(a) ? (r.push(new vs(s, Rw(a))), o += 2) : (r.push(new vs(s, {})), o++) } return new Y(r, {}) } function gR(e) { const t = {}; return st(e, (n, r) => { "string" == typeof n && (n = [n]), null !== n && (t[r] = oh(new Y([], {}), 0, n)) }), t } function Rw(e) { const t = {}; return st(e, (n, r) => t[r] = `${n}`), t } function Nw(e, t, n) { return e == n.path && Tn(t, n.parameters) } class er { constructor(t, n) { this.id = t, this.url = n } } class ih extends er { constructor(t, n, r = "imperative", o = null) { super(t, n), this.type = 0, this.navigationTrigger = r, this.restoredState = o } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class zr extends er { constructor(t, n, r) { super(t, n), this.urlAfterRedirects = r, this.type = 1 } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class Rc extends er { constructor(t, n, r, o) { super(t, n), this.reason = r, this.code = o, this.type = 2 } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class Fw extends er { constructor(t, n, r, o) { super(t, n), this.error = r, this.target = o, this.type = 3 } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class mR extends er { constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.type = 4 } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class yR extends er { constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.type = 7 } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class vR extends er { constructor(t, n, r, o, i) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.shouldActivate = i, this.type = 8 } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class _R extends er { constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.type = 5 } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class CR extends er { constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.type = 6 } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class wR { constructor(t) { this.route = t, this.type = 9 } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class bR { constructor(t) { this.route = t, this.type = 10 } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class DR { constructor(t) { this.snapshot = t, this.type = 11 } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class ER { constructor(t) { this.snapshot = t, this.type = 12 } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class MR { constructor(t) { this.snapshot = t, this.type = 13 } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class SR { constructor(t) { this.snapshot = t, this.type = 14 } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Lw { constructor(t, n, r) { this.routerEvent = t, this.position = n, this.anchor = r, this.type = 15 } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } class jw { constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { const n = this.pathFromRoot(t); return n.length > 1 ? n[n.length - 2] : null } children(t) { const n = sh(t, this._root); return n ? n.children.map(r => r.value) : [] } firstChild(t) { const n = sh(t, this._root); return n && n.children.length > 0 ? n.children[0].value : null } siblings(t) { const n = ah(t, this._root); return n.length < 2 ? [] : n[n.length - 2].children.map(o => o.value).filter(o => o !== t) } pathFromRoot(t) { return ah(t, this._root).map(n => n.value) } } function sh(e, t) { if (e === t.value) return t; for (const n of t.children) { const r = sh(e, n); if (r) return r } return null } function ah(e, t) { if (e === t.value) return [t]; for (const n of t.children) { const r = ah(e, n); if (r.length) return r.unshift(t), r } return [] } class tr { constructor(t, n) { this.value = t, this.children = n } toString() { return `TreeNode(${this.value})` } } function ni(e) { const t = {}; return e && e.children.forEach(n => t[n.value.outlet] = n), t } class $w extends jw { constructor(t, n) { super(t), this.snapshot = n, ch(this, t) } toString() { return this.snapshot.toString() } } function Uw(e, t) { const n = function TR(e, t) { const s = new Nc([], {}, {}, "", {}, G, t, null, e.root, -1, {}); return new Bw("", new tr(s, [])) }(e, t), r = new ht([new vs("", {})]), o = new ht({}), i = new ht({}), s = new ht({}), a = new ht(""), c = new qr(r, o, s, a, i, G, t, n.root); return c.snapshot = n.root, new $w(new tr(c, []), n) } class qr { constructor(t, n, r, o, i, s, a, c) { this.url = t, this.params = n, this.queryParams = r, this.fragment = o, this.data = i, this.outlet = s, this.component = a, this.title = this.data?.pipe(H(u => u[ys])) ?? T(void 0), this._futureSnapshot = c } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(H(t => Jo(t)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(H(t => Jo(t)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function Vw(e, t = "emptyOnly") { const n = e.pathFromRoot; let r = 0; if ("always" !== t) for (r = n.length - 1; r >= 1;) { const o = n[r], i = n[r - 1]; if (o.routeConfig && "" === o.routeConfig.path) r--; else { if (i.component) break; r-- } } return function xR(e) { return e.reduce((t, n) => ({ params: { ...t.params, ...n.params }, data: { ...t.data, ...n.data }, resolve: { ...n.data, ...t.resolve, ...n.routeConfig?.data, ...n._resolvedData } }), { params: {}, data: {}, resolve: {} }) }(n.slice(r)) } class Nc { constructor(t, n, r, o, i, s, a, c, u, l, d, f) { this.url = t, this.params = n, this.queryParams = r, this.fragment = o, this.data = i, this.outlet = s, this.component = a, this.title = this.data?.[ys], this.routeConfig = c, this._urlSegment = u, this._lastPathIndex = l, this._correctedLastPathIndex = f ?? l, this._resolve = d } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = Jo(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Jo(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(r => r.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class Bw extends jw { constructor(t, n) { super(n), this.url = t, ch(this, n) } toString() { return Hw(this._root) } } function ch(e, t) { t.value._routerState = e, t.children.forEach(n => ch(e, n)) } function Hw(e) { const t = e.children.length > 0 ? ` { ${e.children.map(Hw).join(", ")} } ` : ""; return `${e.value}${t}` } function uh(e) { if (e.snapshot) { const t = e.snapshot, n = e._futureSnapshot; e.snapshot = n, Tn(t.queryParams, n.queryParams) || e.queryParams.next(n.queryParams), t.fragment !== n.fragment && e.fragment.next(n.fragment), Tn(t.params, n.params) || e.params.next(n.params), function zA(e, t) { if (e.length !== t.length) return !1; for (let n = 0; n < e.length; ++n)if (!Tn(e[n], t[n])) return !1; return !0 }(t.url, n.url) || e.url.next(n.url), Tn(t.data, n.data) || e.data.next(n.data) } else e.snapshot = e._futureSnapshot, e.data.next(e._futureSnapshot.data) } function lh(e, t) { const n = Tn(e.params, t.params) && function KA(e, t) { return Br(e, t) && e.every((n, r) => Tn(n.parameters, t[r].parameters)) }(e.url, t.url); return n && !(!e.parent != !t.parent) && (!e.parent || lh(e.parent, t.parent)) } function Ds(e, t, n) { if (n && e.shouldReuseRoute(t.value, n.value.snapshot)) { const r = n.value; r._futureSnapshot = t.value; const o = function PR(e, t, n) { return t.children.map(r => { for (const o of n.children) if (e.shouldReuseRoute(r.value, o.value.snapshot)) return Ds(e, r, o); return Ds(e, r) }) }(e, t, n); return new tr(r, o) } { if (e.shouldAttach(t.value)) { const i = e.retrieve(t.value); if (null !== i) { const s = i.route; return s.value._futureSnapshot = t.value, s.children = t.children.map(a => Ds(e, a)), s } } const r = function kR(e) { return new qr(new ht(e.url), new ht(e.params), new ht(e.queryParams), new ht(e.fragment), new ht(e.data), e.outlet, e.component, e) }(t.value), o = t.children.map(i => Ds(e, i)); return new tr(r, o) } } const dh = "ngNavigationCancelingError"; function zw(e, t) { const { redirectTo: n, navigationBehaviorOptions: r } = Hr(t) ? { redirectTo: t, navigationBehaviorOptions: void 0 } : t, o = qw(!1, 0, t); return o.url = n, o.navigationBehaviorOptions = r, o } function qw(e, t, n) { const r = new Error("NavigationCancelingError: " + (e || "")); return r[dh] = !0, r.cancellationCode = t, n && (r.url = n), r } function Ww(e) { return Gw(e) && Hr(e.url) } function Gw(e) { return e && e[dh] } class AR { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.injector = null, this.children = new Es, this.attachRef = null } } let Es = (() => { class e { constructor() { this.contexts = new Map } onChildOutletCreated(n, r) { const o = this.getOrCreateContext(n); o.outlet = r, this.contexts.set(n, o) } onChildOutletDestroyed(n) { const r = this.getContext(n); r && (r.outlet = null, r.attachRef = null) } onOutletDeactivated() { const n = this.contexts; return this.contexts = new Map, n } onOutletReAttached(n) { this.contexts = n } getOrCreateContext(n) { let r = this.getContext(n); return r || (r = new AR, this.contexts.set(n, r)), r } getContext(n) { return this.contexts.get(n) || null } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const Fc = !1; let fh = (() => { class e { constructor(n, r, o, i, s) { this.parentContexts = n, this.location = r, this.changeDetector = i, this.environmentInjector = s, this.activated = null, this._activatedRoute = null, this.activateEvents = new bt, this.deactivateEvents = new bt, this.attachEvents = new bt, this.detachEvents = new bt, this.name = o || G, n.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.getContext(this.name)?.outlet === this && this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const n = this.parentContexts.getContext(this.name); n && n.route && (n.attachRef ? this.attach(n.attachRef, n.route) : this.activateWith(n.route, n.injector)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new M(4012, Fc); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new M(4012, Fc); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new M(4012, Fc); this.location.detach(); const n = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(n.instance), n } attach(n, r) { this.activated = n, this._activatedRoute = r, this.location.insert(n.hostView), this.attachEvents.emit(n.instance) } deactivate() { if (this.activated) { const n = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(n) } } activateWith(n, r) { if (this.isActivated) throw new M(4013, Fc); this._activatedRoute = n; const o = this.location, s = n._futureSnapshot.component, a = this.parentContexts.getOrCreateContext(this.name).children, c = new RR(n, a, o.injector); if (r && function NR(e) { return !!e.resolveComponentFactory }(r)) { const u = r.resolveComponentFactory(s); this.activated = o.createComponent(u, o.length, c) } else this.activated = o.createComponent(s, { index: o.length, injector: c, environmentInjector: r ?? this.environmentInjector }); this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return e.\u0275fac = function (n) { return new (n || e)(S(Es), S(fn), function Pi(e) { return function xE(e, t) { if ("class" === t) return e.classes; if ("style" === t) return e.styles; const n = e.attrs; if (n) { const r = n.length; let o = 0; for (; o < r;) { const i = n[o]; if (tg(i)) break; if (0 === i) o += 2; else if ("number" == typeof i) for (o++; o < r && "string" == typeof n[o];)o++; else { if (i === t) return n[o + 1]; o += 2 } } } return null }(He(), e) }("name"), S(sc), S(lr)) }, e.\u0275dir = at({ type: e, selectors: [["router-outlet"]], outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"], standalone: !0 }), e })(); class RR { constructor(t, n, r) { this.route = t, this.childContexts = n, this.parent = r } get(t, n) { return t === qr ? this.route : t === Es ? this.childContexts : this.parent.get(t, n) } } let hh = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = ot({ type: e, selectors: [["ng-component"]], standalone: !0, features: [t_], decls: 1, vars: 0, template: function (n, r) { 1 & n && me(0, "router-outlet") }, dependencies: [fh], encapsulation: 2 }), e })(); function Zw(e, t) { return e.providers && !e._injector && (e._injector = Qa(e.providers, t, `Route: ${e.path}`)), e._injector ?? t } function gh(e) { const t = e.children && e.children.map(gh), n = t ? { ...e, children: t } : { ...e }; return !n.component && !n.loadComponent && (t || n.loadChildren) && n.outlet && n.outlet !== G && (n.component = hh), n } function en(e) { return e.outlet || G } function Kw(e, t) { const n = e.filter(r => en(r) === t); return n.push(...e.filter(r => en(r) !== t)), n } function Ms(e) { if (!e) return null; if (e.routeConfig?._injector) return e.routeConfig._injector; for (let t = e.parent; t; t = t.parent) { const n = t.routeConfig; if (n?._loadedInjector) return n._loadedInjector; if (n?._injector) return n._injector } return null } class UR { constructor(t, n, r, o) { this.routeReuseStrategy = t, this.futureState = n, this.currState = r, this.forwardEvent = o } activate(t) { const n = this.futureState._root, r = this.currState ? this.currState._root : null; this.deactivateChildRoutes(n, r, t), uh(this.futureState.root), this.activateChildRoutes(n, r, t) } deactivateChildRoutes(t, n, r) { const o = ni(n); t.children.forEach(i => { const s = i.value.outlet; this.deactivateRoutes(i, o[s], r), delete o[s] }), st(o, (i, s) => { this.deactivateRouteAndItsChildren(i, r) }) } deactivateRoutes(t, n, r) { const o = t.value, i = n ? n.value : null; if (o === i) if (o.component) { const s = r.getContext(o.outlet); s && this.deactivateChildRoutes(t, n, s.children) } else this.deactivateChildRoutes(t, n, r); else i && this.deactivateRouteAndItsChildren(n, r) } deactivateRouteAndItsChildren(t, n) { t.value.component && this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, n) : this.deactivateRouteAndOutlet(t, n) } detachAndStoreRouteSubtree(t, n) { const r = n.getContext(t.value.outlet), o = r && t.value.component ? r.children : n, i = ni(t); for (const s of Object.keys(i)) this.deactivateRouteAndItsChildren(i[s], o); if (r && r.outlet) { const s = r.outlet.detach(), a = r.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: s, route: t, contexts: a }) } } deactivateRouteAndOutlet(t, n) { const r = n.getContext(t.value.outlet), o = r && t.value.component ? r.children : n, i = ni(t); for (const s of Object.keys(i)) this.deactivateRouteAndItsChildren(i[s], o); r && r.outlet && (r.outlet.deactivate(), r.children.onOutletDeactivated(), r.attachRef = null, r.resolver = null, r.route = null) } activateChildRoutes(t, n, r) { const o = ni(n); t.children.forEach(i => { this.activateRoutes(i, o[i.value.outlet], r), this.forwardEvent(new SR(i.value.snapshot)) }), t.children.length && this.forwardEvent(new ER(t.value.snapshot)) } activateRoutes(t, n, r) { const o = t.value, i = n ? n.value : null; if (uh(o), o === i) if (o.component) { const s = r.getOrCreateContext(o.outlet); this.activateChildRoutes(t, n, s.children) } else this.activateChildRoutes(t, n, r); else if (o.component) { const s = r.getOrCreateContext(o.outlet); if (this.routeReuseStrategy.shouldAttach(o.snapshot)) { const a = this.routeReuseStrategy.retrieve(o.snapshot); this.routeReuseStrategy.store(o.snapshot, null), s.children.onOutletReAttached(a.contexts), s.attachRef = a.componentRef, s.route = a.route.value, s.outlet && s.outlet.attach(a.componentRef, a.route.value), uh(a.route.value), this.activateChildRoutes(t, null, s.children) } else { const a = Ms(o.snapshot), c = a?.get(Gi) ?? null; s.attachRef = null, s.route = o, s.resolver = c, s.injector = a, s.outlet && s.outlet.activateWith(o, s.injector), this.activateChildRoutes(t, null, s.children) } } else this.activateChildRoutes(t, null, r) } } class Yw { constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } } class Lc { constructor(t, n) { this.component = t, this.route = n } } function VR(e, t, n) { const r = e._root; return Ss(r, t ? t._root : null, n, [r.value]) } function ri(e, t) { const n = Symbol(), r = t.get(e, n); return r === n ? "function" != typeof e || function kD(e) { return null !== Ks(e) }(e) ? t.get(e) : e : r } function Ss(e, t, n, r, o = { canDeactivateChecks: [], canActivateChecks: [] }) { const i = ni(t); return e.children.forEach(s => { (function HR(e, t, n, r, o = { canDeactivateChecks: [], canActivateChecks: [] }) { const i = e.value, s = t ? t.value : null, a = n ? n.getContext(e.value.outlet) : null; if (s && i.routeConfig === s.routeConfig) { const c = function zR(e, t, n) { if ("function" == typeof n) return n(e, t); switch (n) { case "pathParamsChange": return !Br(e.url, t.url); case "pathParamsOrQueryParamsChange": return !Br(e.url, t.url) || !Tn(e.queryParams, t.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !lh(e, t) || !Tn(e.queryParams, t.queryParams); default: return !lh(e, t) } }(s, i, i.routeConfig.runGuardsAndResolvers); c ? o.canActivateChecks.push(new Yw(r)) : (i.data = s.data, i._resolvedData = s._resolvedData), Ss(e, t, i.component ? a ? a.children : null : n, r, o), c && a && a.outlet && a.outlet.isActivated && o.canDeactivateChecks.push(new Lc(a.outlet.component, s)) } else s && Is(t, a, o), o.canActivateChecks.push(new Yw(r)), Ss(e, null, i.component ? a ? a.children : null : n, r, o) })(s, i[s.value.outlet], n, r.concat([s.value]), o), delete i[s.value.outlet] }), st(i, (s, a) => Is(s, n.getContext(a), o)), o } function Is(e, t, n) { const r = ni(e), o = e.value; st(r, (i, s) => { Is(i, o.component ? t ? t.children.getContext(s) : null : t, n) }), n.canDeactivateChecks.push(new Lc(o.component && t && t.outlet && t.outlet.isActivated ? t.outlet.component : null, o)) } function Ts(e) { return "function" == typeof e } function mh(e) { return e instanceof ms || "EmptyError" === e?.name } const jc = Symbol("INITIAL_VALUE"); function oi() { return Jt(e => hw(e.map(t => t.pipe(Xo(1), function LA(...e) { const t = Ci(e); return ke((n, r) => { (t ? Gf(e, n, t) : Gf(e, n)).subscribe(r) }) }(jc)))).pipe(H(t => { for (const n of t) if (!0 !== n) { if (n === jc) return jc; if (!1 === n || n instanceof Vr) return n } return !0 }), Ze(t => t !== jc), Xo(1))) } function Qw(e) { return function Jb(...e) { return rp(e) }(Fe(t => { if (Hr(t)) throw zw(0, t) }), H(t => !0 === t)) } const yh = { matched: !1, consumedSegments: [], remainingSegments: [], parameters: {}, positionalParamSegments: {} }; function Xw(e, t, n, r, o) { const i = vh(e, t, n); return i.matched ? function aN(e, t, n, r) { const o = t.canMatch; return o && 0 !== o.length ? T(o.map(s => { const a = ri(s, e); return Cr(function YR(e) { return e && Ts(e.canMatch) }(a) ? a.canMatch(t, n) : e.runInContext(() => a(t, n))) })).pipe(oi(), Qw()) : T(!0) }(r = Zw(t, r), t, n).pipe(H(s => !0 === s ? i : { ...yh })) : T(i) } function vh(e, t, n) { if ("" === t.path) return "full" === t.pathMatch && (e.hasChildren() || n.length > 0) ? { ...yh } : { matched: !0, consumedSegments: [], remainingSegments: n, parameters: {}, positionalParamSegments: {} }; const o = (t.matcher || HA)(n, e, t); if (!o) return { ...yh }; const i = {}; st(o.posParams, (a, c) => { i[c] = a.path }); const s = o.consumed.length > 0 ? { ...i, ...o.consumed[o.consumed.length - 1].parameters } : i; return { matched: !0, consumedSegments: o.consumed, remainingSegments: n.slice(o.consumed.length), parameters: s, positionalParamSegments: o.posParams ?? {} } } function $c(e, t, n, r, o = "corrected") { if (n.length > 0 && function lN(e, t, n) { return n.some(r => Uc(e, t, r) && en(r) !== G) }(e, n, r)) { const s = new Y(t, function uN(e, t, n, r) { const o = {}; o[G] = r, r._sourceSegment = e, r._segmentIndexShift = t.length; for (const i of n) if ("" === i.path && en(i) !== G) { const s = new Y([], {}); s._sourceSegment = e, s._segmentIndexShift = t.length, o[en(i)] = s } return o }(e, t, r, new Y(n, e.children))); return s._sourceSegment = e, s._segmentIndexShift = t.length, { segmentGroup: s, slicedSegments: [] } } if (0 === n.length && function dN(e, t, n) { return n.some(r => Uc(e, t, r)) }(e, n, r)) { const s = new Y(e.segments, function cN(e, t, n, r, o, i) { const s = {}; for (const a of r) if (Uc(e, n, a) && !o[en(a)]) { const c = new Y([], {}); c._sourceSegment = e, c._segmentIndexShift = "legacy" === i ? e.segments.length : t.length, s[en(a)] = c } return { ...o, ...s } }(e, t, n, r, e.children, o)); return s._sourceSegment = e, s._segmentIndexShift = t.length, { segmentGroup: s, slicedSegments: n } } const i = new Y(e.segments, e.children); return i._sourceSegment = e, i._segmentIndexShift = t.length, { segmentGroup: i, slicedSegments: n } } function Uc(e, t, n) { return (!(e.hasChildren() || t.length > 0) || "full" !== n.pathMatch) && "" === n.path } function Jw(e, t, n, r) { return !!(en(e) === r || r !== G && Uc(t, n, e)) && ("**" === e.path || vh(t, e, n).matched) } function e0(e, t, n) { return 0 === t.length && !e.children[n] } const Vc = !1; class Bc { constructor(t) { this.segmentGroup = t || null } } class t0 { constructor(t) { this.urlTree = t } } function xs(e) { return Ur(new Bc(e)) } function n0(e) { return Ur(new t0(e)) } class gN { constructor(t, n, r, o, i) { this.injector = t, this.configLoader = n, this.urlSerializer = r, this.urlTree = o, this.config = i, this.allowRedirects = !0 } apply() { const t = $c(this.urlTree.root, [], [], this.config).segmentGroup, n = new Y(t.segments, t.children); return this.expandSegmentGroup(this.injector, this.config, n, G).pipe(H(i => this.createUrlTree(Ac(i), this.urlTree.queryParams, this.urlTree.fragment))).pipe(yn(i => { if (i instanceof t0) return this.allowRedirects = !1, this.match(i.urlTree); throw i instanceof Bc ? this.noMatchError(i) : i })) } match(t) { return this.expandSegmentGroup(this.injector, this.config, t.root, G).pipe(H(o => this.createUrlTree(Ac(o), t.queryParams, t.fragment))).pipe(yn(o => { throw o instanceof Bc ? this.noMatchError(o) : o })) } noMatchError(t) { return new M(4002, Vc) } createUrlTree(t, n, r) { const o = th(t); return new Vr(o, n, r) } expandSegmentGroup(t, n, r, o) { return 0 === r.segments.length && r.hasChildren() ? this.expandChildren(t, n, r).pipe(H(i => new Y([], i))) : this.expandSegment(t, r, n, r.segments, o, !0) } expandChildren(t, n, r) { const o = []; for (const i of Object.keys(r.children)) "primary" === i ? o.unshift(i) : o.push(i); return Ie(o).pipe(mn(i => { const s = r.children[i], a = Kw(n, i); return this.expandSegmentGroup(t, a, s, i).pipe(H(c => ({ segment: c, outlet: i }))) }), Kf((i, s) => (i[s.outlet] = s.segment, i), {}), yw()) } expandSegment(t, n, r, o, i, s) { return Ie(r).pipe(mn(a => this.expandSegmentAgainstRoute(t, n, r, a, o, i, s).pipe(yn(u => { if (u instanceof Bc) return T(null); throw u }))), _r(a => !!a), yn((a, c) => { if (mh(a)) return e0(n, o, i) ? T(new Y([], {})) : xs(n); throw a })) } expandSegmentAgainstRoute(t, n, r, o, i, s, a) { return Jw(o, n, i, s) ? void 0 === o.redirectTo ? this.matchSegmentAgainstRoute(t, n, o, i, s) : a && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, n, r, o, i, s) : xs(n) : xs(n) } expandSegmentAgainstRouteUsingRedirect(t, n, r, o, i, s) { return "**" === o.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, r, o, s) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, n, r, o, i, s) } expandWildCardWithParamsAgainstRouteUsingRedirect(t, n, r, o) { const i = this.applyRedirectCommands([], r.redirectTo, {}); return r.redirectTo.startsWith("/") ? n0(i) : this.lineralizeSegments(r, i).pipe(Be(s => { const a = new Y(s, {}); return this.expandSegment(t, a, n, s, o, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(t, n, r, o, i, s) { const { matched: a, consumedSegments: c, remainingSegments: u, positionalParamSegments: l } = vh(n, o, i); if (!a) return xs(n); const d = this.applyRedirectCommands(c, o.redirectTo, l); return o.redirectTo.startsWith("/") ? n0(d) : this.lineralizeSegments(o, d).pipe(Be(f => this.expandSegment(t, n, r, f.concat(u), s, !1))) } matchSegmentAgainstRoute(t, n, r, o, i) { return "**" === r.path ? (t = Zw(r, t), r.loadChildren ? (r._loadedRoutes ? T({ routes: r._loadedRoutes, injector: r._loadedInjector }) : this.configLoader.loadChildren(t, r)).pipe(H(a => (r._loadedRoutes = a.routes, r._loadedInjector = a.injector, new Y(o, {})))) : T(new Y(o, {}))) : Xw(n, r, o, t).pipe(Jt(({ matched: s, consumedSegments: a, remainingSegments: c }) => s ? this.getChildConfig(t = r._injector ?? t, r, o).pipe(Be(l => { const d = l.injector ?? t, f = l.routes, { segmentGroup: h, slicedSegments: p } = $c(n, a, c, f), g = new Y(h.segments, h.children); if (0 === p.length && g.hasChildren()) return this.expandChildren(d, f, g).pipe(H(y => new Y(a, y))); if (0 === f.length && 0 === p.length) return T(new Y(a, {})); const m = en(r) === i; return this.expandSegment(d, g, f, p, m ? G : i, !0).pipe(H(_ => new Y(a.concat(_.segments), _.children))) })) : xs(n))) } getChildConfig(t, n, r) { return n.children ? T({ routes: n.children, injector: t }) : n.loadChildren ? void 0 !== n._loadedRoutes ? T({ routes: n._loadedRoutes, injector: n._loadedInjector }) : function sN(e, t, n, r) { const o = t.canLoad; return void 0 === o || 0 === o.length ? T(!0) : T(o.map(s => { const a = ri(s, e); return Cr(function WR(e) { return e && Ts(e.canLoad) }(a) ? a.canLoad(t, n) : e.runInContext(() => a(t, n))) })).pipe(oi(), Qw()) }(t, n, r).pipe(Be(o => o ? this.configLoader.loadChildren(t, n).pipe(Fe(i => { n._loadedRoutes = i.routes, n._loadedInjector = i.injector })) : function hN(e) { return Ur(qw(Vc, 3)) }())) : T({ routes: [], injector: t }) } lineralizeSegments(t, n) { let r = [], o = n.root; for (; ;) { if (r = r.concat(o.segments), 0 === o.numberOfChildren) return T(r); if (o.numberOfChildren > 1 || !o.children[G]) return Ur(new M(4e3, Vc)); o = o.children[G] } } applyRedirectCommands(t, n, r) { return this.applyRedirectCreateUrlTree(n, this.urlSerializer.parse(n), t, r) } applyRedirectCreateUrlTree(t, n, r, o) { const i = this.createSegmentGroup(t, n.root, r, o); return new Vr(i, this.createQueryParams(n.queryParams, this.urlTree.queryParams), n.fragment) } createQueryParams(t, n) { const r = {}; return st(t, (o, i) => { if ("string" == typeof o && o.startsWith(":")) { const a = o.substring(1); r[i] = n[a] } else r[i] = o }), r } createSegmentGroup(t, n, r, o) { const i = this.createSegments(t, n.segments, r, o); let s = {}; return st(n.children, (a, c) => { s[c] = this.createSegmentGroup(t, a, r, o) }), new Y(i, s) } createSegments(t, n, r, o) { return n.map(i => i.path.startsWith(":") ? this.findPosParam(t, i, o) : this.findOrReturn(i, r)) } findPosParam(t, n, r) { const o = r[n.path.substring(1)]; if (!o) throw new M(4001, Vc); return o } findOrReturn(t, n) { let r = 0; for (const o of n) { if (o.path === t.path) return n.splice(r), o; r++ } return t } } class yN { } class CN { constructor(t, n, r, o, i, s, a, c) { this.injector = t, this.rootComponentType = n, this.config = r, this.urlTree = o, this.url = i, this.paramsInheritanceStrategy = s, this.relativeLinkResolution = a, this.urlSerializer = c } recognize() { const t = $c(this.urlTree.root, [], [], this.config.filter(n => void 0 === n.redirectTo), this.relativeLinkResolution).segmentGroup; return this.processSegmentGroup(this.injector, this.config, t, G).pipe(H(n => { if (null === n) return null; const r = new Nc([], Object.freeze({}), Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, {}, G, this.rootComponentType, null, this.urlTree.root, -1, {}), o = new tr(r, n), i = new Bw(this.url, o); return this.inheritParamsAndData(i._root), i })) } inheritParamsAndData(t) { const n = t.value, r = Vw(n, this.paramsInheritanceStrategy); n.params = Object.freeze(r.params), n.data = Object.freeze(r.data), t.children.forEach(o => this.inheritParamsAndData(o)) } processSegmentGroup(t, n, r, o) { return 0 === r.segments.length && r.hasChildren() ? this.processChildren(t, n, r) : this.processSegment(t, n, r, r.segments, o) } processChildren(t, n, r) { return Ie(Object.keys(r.children)).pipe(mn(o => { const i = r.children[o], s = Kw(n, o); return this.processSegmentGroup(t, s, i, o) }), Kf((o, i) => o && i ? (o.push(...i), o) : null), function UA(e, t = !1) { return ke((n, r) => { let o = 0; n.subscribe(Se(r, i => { const s = e(i, o++); (s || t) && r.next(i), !s && r.complete() })) }) }(o => null !== o), Ic(null), yw(), H(o => { if (null === o) return null; const i = r0(o); return function wN(e) { e.sort((t, n) => t.value.outlet === G ? -1 : n.value.outlet === G ? 1 : t.value.outlet.localeCompare(n.value.outlet)) }(i), i })) } processSegment(t, n, r, o, i) { return Ie(n).pipe(mn(s => this.processSegmentAgainstRoute(s._injector ?? t, s, r, o, i)), _r(s => !!s), yn(s => { if (mh(s)) return e0(r, o, i) ? T([]) : T(null); throw s })) } processSegmentAgainstRoute(t, n, r, o, i) { if (n.redirectTo || !Jw(n, r, o, i)) return T(null); let s; if ("**" === n.path) { const a = o.length > 0 ? Cw(o).parameters : {}, c = s0(r) + o.length; s = T({ snapshot: new Nc(o, a, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, c0(n), en(n), n.component ?? n._loadedComponent ?? null, n, o0(r), c, u0(n), c), consumedSegments: [], remainingSegments: [] }) } else s = Xw(r, n, o, t).pipe(H(({ matched: a, consumedSegments: c, remainingSegments: u, parameters: l }) => { if (!a) return null; const d = s0(r) + c.length; return { snapshot: new Nc(c, l, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, c0(n), en(n), n.component ?? n._loadedComponent ?? null, n, o0(r), d, u0(n), d), consumedSegments: c, remainingSegments: u } })); return s.pipe(Jt(a => { if (null === a) return T(null); const { snapshot: c, consumedSegments: u, remainingSegments: l } = a; t = n._injector ?? t; const d = n._loadedInjector ?? t, f = function bN(e) { return e.children ? e.children : e.loadChildren ? e._loadedRoutes : [] }(n), { segmentGroup: h, slicedSegments: p } = $c(r, u, l, f.filter(m => void 0 === m.redirectTo), this.relativeLinkResolution); if (0 === p.length && h.hasChildren()) return this.processChildren(d, f, h).pipe(H(m => null === m ? null : [new tr(c, m)])); if (0 === f.length && 0 === p.length) return T([new tr(c, [])]); const g = en(n) === i; return this.processSegment(d, f, h, p, g ? G : i).pipe(H(m => null === m ? null : [new tr(c, m)])) })) } } function DN(e) { const t = e.value.routeConfig; return t && "" === t.path && void 0 === t.redirectTo } function r0(e) { const t = [], n = new Set; for (const r of e) { if (!DN(r)) { t.push(r); continue } const o = t.find(i => r.value.routeConfig === i.value.routeConfig); void 0 !== o ? (o.children.push(...r.children), n.add(o)) : t.push(r) } for (const r of n) { const o = r0(r.children); t.push(new tr(r.value, o)) } return t.filter(r => !n.has(r)) } function o0(e) { let t = e; for (; t._sourceSegment;)t = t._sourceSegment; return t } function s0(e) { let t = e, n = t._segmentIndexShift ?? 0; for (; t._sourceSegment;)t = t._sourceSegment, n += t._segmentIndexShift ?? 0; return n - 1 } function c0(e) { return e.data || {} } function u0(e) { return e.resolve || {} } function l0(e) { return "string" == typeof e.title || null === e.title } function _h(e) { return Jt(t => { const n = e(t); return n ? Ie(n).pipe(H(() => t)) : T(t) }) } let d0 = (() => { class e { buildTitle(n) { let r, o = n.root; for (; void 0 !== o;)r = this.getResolvedTitleForRoute(o) ?? r, o = o.children.find(i => i.outlet === G); return r } getResolvedTitleForRoute(n) { return n.data[ys] } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: function () { return Ae(f0) }, providedIn: "root" }), e })(), f0 = (() => { class e extends d0 { constructor(n) { super(), this.title = n } updateTitle(n) { const r = this.buildTitle(n); void 0 !== r && this.title.setTitle(r) } } return e.\u0275fac = function (n) { return new (n || e)(E(cw)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); class PN { } class AN extends class kN { shouldDetach(t) { return !1 } store(t, n) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, n) { return t.routeConfig === n.routeConfig } }{ } const zc = new O("", { providedIn: "root", factory: () => ({}) }), Ch = new O("ROUTES"); let wh = (() => { class e { constructor(n, r) { this.injector = n, this.compiler = r, this.componentLoaders = new WeakMap, this.childrenLoaders = new WeakMap } loadComponent(n) { if (this.componentLoaders.get(n)) return this.componentLoaders.get(n); if (n._loadedComponent) return T(n._loadedComponent); this.onLoadStartListener && this.onLoadStartListener(n); const r = Cr(n.loadComponent()).pipe(Fe(i => { this.onLoadEndListener && this.onLoadEndListener(n), n._loadedComponent = i }), Qf(() => { this.componentLoaders.delete(n) })), o = new gw(r, () => new Pt).pipe(Zf()); return this.componentLoaders.set(n, o), o } loadChildren(n, r) { if (this.childrenLoaders.get(r)) return this.childrenLoaders.get(r); if (r._loadedRoutes) return T({ routes: r._loadedRoutes, injector: r._loadedInjector }); this.onLoadStartListener && this.onLoadStartListener(r); const i = this.loadModuleFactoryOrRoutes(r.loadChildren).pipe(H(a => { this.onLoadEndListener && this.onLoadEndListener(r); let c, u, l = !1; Array.isArray(a) ? u = a : (c = a.create(n).injector, u = _w(c.get(Ch, [], k.Self | k.Optional))); return { routes: u.map(gh), injector: c } }), Qf(() => { this.childrenLoaders.delete(r) })), s = new gw(i, () => new Pt).pipe(Zf()); return this.childrenLoaders.set(r, s), s } loadModuleFactoryOrRoutes(n) { return Cr(n()).pipe(Be(r => r instanceof Jv || Array.isArray(r) ? T(r) : Ie(this.compiler.compileModuleAsync(r)))) } } return e.\u0275fac = function (n) { return new (n || e)(E(Vt), E(lf)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); class NN { } class FN { shouldProcessUrl(t) { return !0 } extract(t) { return t } merge(t, n) { return t } } function LN(e) { throw e } function jN(e, t, n) { return t.parse("/") } const $N = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, UN = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; function p0() { const e = Ae(Sw), t = Ae(Es), n = Ae(dc), r = Ae(Vt), o = Ae(lf), i = Ae(Ch, { optional: !0 }) ?? [], s = Ae(zc, { optional: !0 }) ?? {}, a = Ae(f0), c = Ae(d0, { optional: !0 }), u = Ae(NN, { optional: !0 }), l = Ae(PN, { optional: !0 }), d = new Ke(null, e, t, n, r, o, _w(i)); return u && (d.urlHandlingStrategy = u), l && (d.routeReuseStrategy = l), d.titleStrategy = c ?? a, function VN(e, t) { e.errorHandler && (t.errorHandler = e.errorHandler), e.malformedUriErrorHandler && (t.malformedUriErrorHandler = e.malformedUriErrorHandler), e.onSameUrlNavigation && (t.onSameUrlNavigation = e.onSameUrlNavigation), e.paramsInheritanceStrategy && (t.paramsInheritanceStrategy = e.paramsInheritanceStrategy), e.relativeLinkResolution && (t.relativeLinkResolution = e.relativeLinkResolution), e.urlUpdateStrategy && (t.urlUpdateStrategy = e.urlUpdateStrategy), e.canceledNavigationResolution && (t.canceledNavigationResolution = e.canceledNavigationResolution) }(s, d), d } let Ke = (() => { class e { constructor(n, r, o, i, s, a, c) { this.rootComponentType = n, this.urlSerializer = r, this.rootContexts = o, this.location = i, this.config = c, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.disposed = !1, this.navigationId = 0, this.currentPageId = 0, this.isNgZoneEnabled = !1, this.events = new Pt, this.errorHandler = LN, this.malformedUriErrorHandler = jN, this.navigated = !1, this.lastSuccessfulId = -1, this.afterPreactivation = () => T(void 0), this.urlHandlingStrategy = new FN, this.routeReuseStrategy = new AN, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "corrected", this.canceledNavigationResolution = "replace", this.configLoader = s.get(wh), this.configLoader.onLoadEndListener = f => this.triggerEvent(new bR(f)), this.configLoader.onLoadStartListener = f => this.triggerEvent(new wR(f)), this.ngModule = s.get(Lr), this.console = s.get(hO); const d = s.get(We); this.isNgZoneEnabled = d instanceof We && We.isInAngularZone(), this.resetConfig(c), this.currentUrlTree = function qA() { return new Vr(new Y([], {}), {}, null) }(), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.routerState = Uw(this.currentUrlTree, this.rootComponentType), this.transitions = new ht({ id: 0, targetPageId: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } get browserPageId() { return this.location.getState()?.\u0275routerPageId } setupNavigations(n) { const r = this.events; return n.pipe(Ze(o => 0 !== o.id), H(o => ({ ...o, extractedUrl: this.urlHandlingStrategy.extract(o.rawUrl) })), Jt(o => { let i = !1, s = !1; return T(o).pipe(Fe(a => { this.currentNavigation = { id: a.id, initialUrl: a.rawUrl, extractedUrl: a.extractedUrl, trigger: a.source, extras: a.extras, previousNavigation: this.lastSuccessfulNavigation ? { ...this.lastSuccessfulNavigation, previousNavigation: null } : null } }), Jt(a => { const c = this.browserUrlTree.toString(), u = !this.navigated || a.extractedUrl.toString() !== c || c !== this.currentUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || u) && this.urlHandlingStrategy.shouldProcessUrl(a.rawUrl)) return g0(a.source) && (this.browserUrlTree = a.extractedUrl), T(a).pipe(Jt(d => { const f = this.transitions.getValue(); return r.next(new ih(d.id, this.serializeUrl(d.extractedUrl), d.source, d.restoredState)), f !== this.transitions.getValue() ? Fn : Promise.resolve(d) }), function mN(e, t, n, r) { return Jt(o => function pN(e, t, n, r, o) { return new gN(e, t, n, r, o).apply() }(e, t, n, o.extractedUrl, r).pipe(H(i => ({ ...o, urlAfterRedirects: i })))) }(this.ngModule.injector, this.configLoader, this.urlSerializer, this.config), Fe(d => { this.currentNavigation = { ...this.currentNavigation, finalUrl: d.urlAfterRedirects }, o.urlAfterRedirects = d.urlAfterRedirects }), function MN(e, t, n, r, o, i) { return Be(s => function _N(e, t, n, r, o, i, s = "emptyOnly", a = "legacy") { return new CN(e, t, n, r, o, s, a, i).recognize().pipe(Jt(c => null === c ? function vN(e) { return new _e(t => t.error(e)) }(new yN) : T(c))) }(e, t, n, s.urlAfterRedirects, r.serialize(s.urlAfterRedirects), r, o, i).pipe(H(a => ({ ...s, targetSnapshot: a })))) }(this.ngModule.injector, this.rootComponentType, this.config, this.urlSerializer, this.paramsInheritanceStrategy, this.relativeLinkResolution), Fe(d => { if (o.targetSnapshot = d.targetSnapshot, "eager" === this.urlUpdateStrategy) { if (!d.extras.skipLocationChange) { const h = this.urlHandlingStrategy.merge(d.urlAfterRedirects, d.rawUrl); this.setBrowserUrl(h, d) } this.browserUrlTree = d.urlAfterRedirects } const f = new mR(d.id, this.serializeUrl(d.extractedUrl), this.serializeUrl(d.urlAfterRedirects), d.targetSnapshot); r.next(f) })); if (u && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: f, extractedUrl: h, source: p, restoredState: g, extras: m } = a, v = new ih(f, this.serializeUrl(h), p, g); r.next(v); const _ = Uw(h, this.rootComponentType).snapshot; return T(o = { ...a, targetSnapshot: _, urlAfterRedirects: h, extras: { ...m, skipLocationChange: !1, replaceUrl: !1 } }) } return this.rawUrlTree = a.rawUrl, a.resolve(null), Fn }), Fe(a => { const c = new yR(a.id, this.serializeUrl(a.extractedUrl), this.serializeUrl(a.urlAfterRedirects), a.targetSnapshot); this.triggerEvent(c) }), H(a => o = { ...a, guards: VR(a.targetSnapshot, a.currentSnapshot, this.rootContexts) }), function XR(e, t) { return Be(n => { const { targetSnapshot: r, currentSnapshot: o, guards: { canActivateChecks: i, canDeactivateChecks: s } } = n; return 0 === s.length && 0 === i.length ? T({ ...n, guardsResult: !0 }) : function JR(e, t, n, r) { return Ie(e).pipe(Be(o => function iN(e, t, n, r, o) { const i = t && t.routeConfig ? t.routeConfig.canDeactivate : null; return i && 0 !== i.length ? T(i.map(a => { const c = Ms(t) ?? o, u = ri(a, c); return Cr(function KR(e) { return e && Ts(e.canDeactivate) }(u) ? u.canDeactivate(e, t, n, r) : c.runInContext(() => u(e, t, n, r))).pipe(_r()) })).pipe(oi()) : T(!0) }(o.component, o.route, n, t, r)), _r(o => !0 !== o, !0)) }(s, r, o, e).pipe(Be(a => a && function qR(e) { return "boolean" == typeof e }(a) ? function eN(e, t, n, r) { return Ie(t).pipe(mn(o => Gf(function nN(e, t) { return null !== e && t && t(new DR(e)), T(!0) }(o.route.parent, r), function tN(e, t) { return null !== e && t && t(new MR(e)), T(!0) }(o.route, r), function oN(e, t, n) { const r = t[t.length - 1], i = t.slice(0, t.length - 1).reverse().map(s => function BR(e) { const t = e.routeConfig ? e.routeConfig.canActivateChild : null; return t && 0 !== t.length ? { node: e, guards: t } : null }(s)).filter(s => null !== s).map(s => Qo(() => T(s.guards.map(c => { const u = Ms(s.node) ?? n, l = ri(c, u); return Cr(function ZR(e) { return e && Ts(e.canActivateChild) }(l) ? l.canActivateChild(r, e) : u.runInContext(() => l(r, e))).pipe(_r()) })).pipe(oi()))); return T(i).pipe(oi()) }(e, o.path, n), function rN(e, t, n) { const r = t.routeConfig ? t.routeConfig.canActivate : null; if (!r || 0 === r.length) return T(!0); const o = r.map(i => Qo(() => { const s = Ms(t) ?? n, a = ri(i, s); return Cr(function GR(e) { return e && Ts(e.canActivate) }(a) ? a.canActivate(t, e) : s.runInContext(() => a(t, e))).pipe(_r()) })); return T(o).pipe(oi()) }(e, o.route, n))), _r(o => !0 !== o, !0)) }(r, i, e, t) : T(a)), H(a => ({ ...n, guardsResult: a }))) }) }(this.ngModule.injector, a => this.triggerEvent(a)), Fe(a => { if (o.guardsResult = a.guardsResult, Hr(a.guardsResult)) throw zw(0, a.guardsResult); const c = new vR(a.id, this.serializeUrl(a.extractedUrl), this.serializeUrl(a.urlAfterRedirects), a.targetSnapshot, !!a.guardsResult); this.triggerEvent(c) }), Ze(a => !!a.guardsResult || (this.restoreHistory(a), this.cancelNavigationTransition(a, "", 3), !1)), _h(a => { if (a.guards.canActivateChecks.length) return T(a).pipe(Fe(c => { const u = new _R(c.id, this.serializeUrl(c.extractedUrl), this.serializeUrl(c.urlAfterRedirects), c.targetSnapshot); this.triggerEvent(u) }), Jt(c => { let u = !1; return T(c).pipe(function SN(e, t) { return Be(n => { const { targetSnapshot: r, guards: { canActivateChecks: o } } = n; if (!o.length) return T(n); let i = 0; return Ie(o).pipe(mn(s => function IN(e, t, n, r) { const o = e.routeConfig, i = e._resolve; return void 0 !== o?.title && !l0(o) && (i[ys] = o.title), function TN(e, t, n, r) { const o = function xN(e) { return [...Object.keys(e), ...Object.getOwnPropertySymbols(e)] }(e); if (0 === o.length) return T({}); const i = {}; return Ie(o).pipe(Be(s => function ON(e, t, n, r) { const o = Ms(t) ?? r, i = ri(e, o); return Cr(i.resolve ? i.resolve(t, n) : o.runInContext(() => i(t, n))) }(e[s], t, n, r).pipe(_r(), Fe(a => { i[s] = a }))), Yf(1), function VA(e) { return H(() => e) }(i), yn(s => mh(s) ? Fn : Ur(s))) }(i, e, t, r).pipe(H(s => (e._resolvedData = s, e.data = Vw(e, n).resolve, o && l0(o) && (e.data[ys] = o.title), null))) }(s.route, r, e, t)), Fe(() => i++), Yf(1), Be(s => i === o.length ? T(n) : Fn)) }) }(this.paramsInheritanceStrategy, this.ngModule.injector), Fe({ next: () => u = !0, complete: () => { u || (this.restoreHistory(c), this.cancelNavigationTransition(c, "", 2)) } })) }), Fe(c => { const u = new CR(c.id, this.serializeUrl(c.extractedUrl), this.serializeUrl(c.urlAfterRedirects), c.targetSnapshot); this.triggerEvent(u) })) }), _h(a => { const c = u => { const l = []; u.routeConfig?.loadComponent && !u.routeConfig._loadedComponent && l.push(this.configLoader.loadComponent(u.routeConfig).pipe(Fe(d => { u.component = d }), H(() => { }))); for (const d of u.children) l.push(...c(d)); return l }; return hw(c(a.targetSnapshot.root)).pipe(Ic(), Xo(1)) }), _h(() => this.afterPreactivation()), H(a => { const c = function OR(e, t, n) { const r = Ds(e, t._root, n ? n._root : void 0); return new $w(r, t) }(this.routeReuseStrategy, a.targetSnapshot, a.currentRouterState); return o = { ...a, targetRouterState: c } }), Fe(a => { this.currentUrlTree = a.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(a.urlAfterRedirects, a.rawUrl), this.routerState = a.targetRouterState, "deferred" === this.urlUpdateStrategy && (a.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, a), this.browserUrlTree = a.urlAfterRedirects) }), ((e, t, n) => H(r => (new UR(t, r.targetRouterState, r.currentRouterState, n).activate(e), r)))(this.rootContexts, this.routeReuseStrategy, a => this.triggerEvent(a)), Fe({ next() { i = !0 }, complete() { i = !0 } }), Qf(() => { i || s || this.cancelNavigationTransition(o, "", 1), this.currentNavigation?.id === o.id && (this.currentNavigation = null) }), yn(a => { if (s = !0, Gw(a)) { Ww(a) || (this.navigated = !0, this.restoreHistory(o, !0)); const c = new Rc(o.id, this.serializeUrl(o.extractedUrl), a.message, a.cancellationCode); if (r.next(c), Ww(a)) { const u = this.urlHandlingStrategy.merge(a.url, this.rawUrlTree), l = { skipLocationChange: o.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy || g0(o.source) }; this.scheduleNavigation(u, "imperative", null, l, { resolve: o.resolve, reject: o.reject, promise: o.promise }) } else o.resolve(!1) } else { this.restoreHistory(o, !0); const c = new Fw(o.id, this.serializeUrl(o.extractedUrl), a, o.targetSnapshot ?? void 0); r.next(c); try { o.resolve(this.errorHandler(a)) } catch (u) { o.reject(u) } } return Fn })) })) } resetRootComponentType(n) { this.rootComponentType = n, this.routerState.root.component = this.rootComponentType } setTransition(n) { this.transitions.next({ ...this.transitions.value, ...n }) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(n => { const r = "popstate" === n.type ? "popstate" : "hashchange"; "popstate" === r && setTimeout(() => { const o = { replaceUrl: !0 }, i = n.state?.navigationId ? n.state : null; if (i) { const a = { ...i }; delete a.navigationId, delete a.\u0275routerPageId, 0 !== Object.keys(a).length && (o.state = a) } const s = this.parseUrl(n.url); this.scheduleNavigation(s, r, i, o) }, 0) })) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(n) { this.events.next(n) } resetConfig(n) { this.config = n.map(gh), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.transitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0 } createUrlTree(n, r = {}) { const { relativeTo: o, queryParams: i, fragment: s, queryParamsHandling: a, preserveFragment: c } = r, u = o || this.routerState.root, l = c ? this.currentUrlTree.fragment : s; let d = null; switch (a) { case "merge": d = { ...this.currentUrlTree.queryParams, ...i }; break; case "preserve": d = this.currentUrlTree.queryParams; break; default: d = i || null }return null !== d && (d = this.removeEmptyProps(d)), lR(u, this.currentUrlTree, n, d, l ?? null) } navigateByUrl(n, r = { skipLocationChange: !1 }) { const o = Hr(n) ? n : this.parseUrl(n), i = this.urlHandlingStrategy.merge(o, this.rawUrlTree); return this.scheduleNavigation(i, "imperative", null, r) } navigate(n, r = { skipLocationChange: !1 }) { return function BN(e) { for (let t = 0; t < e.length; t++) { if (null == e[t]) throw new M(4008, false) } }(n), this.navigateByUrl(this.createUrlTree(n, r), r) } serializeUrl(n) { return this.urlSerializer.serialize(n) } parseUrl(n) { let r; try { r = this.urlSerializer.parse(n) } catch (o) { r = this.malformedUriErrorHandler(o, this.urlSerializer, n) } return r } isActive(n, r) { let o; if (o = !0 === r ? { ...$N } : !1 === r ? { ...UN } : r, Hr(n)) return bw(this.currentUrlTree, n, o); const i = this.parseUrl(n); return bw(this.currentUrlTree, i, o) } removeEmptyProps(n) { return Object.keys(n).reduce((r, o) => { const i = n[o]; return null != i && (r[o] = i), r }, {}) } processNavigations() { this.navigations.subscribe(n => { this.navigated = !0, this.lastSuccessfulId = n.id, this.currentPageId = n.targetPageId, this.events.next(new zr(n.id, this.serializeUrl(n.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, this.titleStrategy?.updateTitle(this.routerState.snapshot), n.resolve(!0) }, n => { this.console.warn(`Unhandled Navigation Error: ${n}`) }) } scheduleNavigation(n, r, o, i, s) { if (this.disposed) return Promise.resolve(!1); let a, c, u; s ? (a = s.resolve, c = s.reject, u = s.promise) : u = new Promise((f, h) => { a = f, c = h }); const l = ++this.navigationId; let d; return "computed" === this.canceledNavigationResolution ? (0 === this.currentPageId && (o = this.location.getState()), d = o && o.\u0275routerPageId ? o.\u0275routerPageId : i.replaceUrl || i.skipLocationChange ? this.browserPageId ?? 0 : (this.browserPageId ?? 0) + 1) : d = 0, this.setTransition({ id: l, targetPageId: d, source: r, restoredState: o, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: n, extras: i, resolve: a, reject: c, promise: u, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), u.catch(f => Promise.reject(f)) } setBrowserUrl(n, r) { const o = this.urlSerializer.serialize(n), i = { ...r.extras.state, ...this.generateNgRouterState(r.id, r.targetPageId) }; this.location.isCurrentPathEqualTo(o) || r.extras.replaceUrl ? this.location.replaceState(o, "", i) : this.location.go(o, "", i) } restoreHistory(n, r = !1) { if ("computed" === this.canceledNavigationResolution) { const o = this.currentPageId - n.targetPageId; "popstate" !== n.source && "eager" !== this.urlUpdateStrategy && this.currentUrlTree !== this.currentNavigation?.finalUrl || 0 === o ? this.currentUrlTree === this.currentNavigation?.finalUrl && 0 === o && (this.resetState(n), this.browserUrlTree = n.currentUrlTree, this.resetUrlToCurrentUrlTree()) : this.location.historyGo(o) } else "replace" === this.canceledNavigationResolution && (r && this.resetState(n), this.resetUrlToCurrentUrlTree()) } resetState(n) { this.routerState = n.currentRouterState, this.currentUrlTree = n.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n.rawUrl) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } cancelNavigationTransition(n, r, o) { const i = new Rc(n.id, this.serializeUrl(n.extractedUrl), r, o); this.triggerEvent(i), n.resolve(!1) } generateNgRouterState(n, r) { return "computed" === this.canceledNavigationResolution ? { navigationId: n, \u0275routerPageId: r } : { navigationId: n } } } return e.\u0275fac = function (n) { od() }, e.\u0275prov = x({ token: e, factory: function () { return p0() }, providedIn: "root" }), e })(); function g0(e) { return "imperative" !== e } class m0 { } let qN = (() => { class e { constructor(n, r, o, i, s) { this.router = n, this.injector = o, this.preloadingStrategy = i, this.loader = s } setUpPreloading() { this.subscription = this.router.events.pipe(Ze(n => n instanceof zr), mn(() => this.preload())).subscribe(() => { }) } preload() { return this.processRoutes(this.injector, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(n, r) { const o = []; for (const i of r) { i.providers && !i._injector && (i._injector = Qa(i.providers, n, `Route: ${i.path}`)); const s = i._injector ?? n, a = i._loadedInjector ?? s; i.loadChildren && !i._loadedRoutes && void 0 === i.canLoad || i.loadComponent && !i._loadedComponent ? o.push(this.preloadConfig(s, i)) : (i.children || i._loadedRoutes) && o.push(this.processRoutes(a, i.children ?? i._loadedRoutes)) } return Ie(o).pipe(so()) } preloadConfig(n, r) { return this.preloadingStrategy.preload(r, () => { let o; o = r.loadChildren && void 0 === r.canLoad ? this.loader.loadChildren(n, r) : T(null); const i = o.pipe(Be(s => null === s ? T(void 0) : (r._loadedRoutes = s.routes, r._loadedInjector = s.injector, this.processRoutes(s.injector ?? n, s.routes)))); return r.loadComponent && !r._loadedComponent ? Ie([i, this.loader.loadComponent(r)]).pipe(so()) : i }) } } return e.\u0275fac = function (n) { return new (n || e)(E(Ke), E(lf), E(lr), E(m0), E(wh)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const Eh = new O(""); let y0 = (() => { class e { constructor(n, r, o = {}) { this.router = n, this.viewportScroller = r, this.options = o, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, o.scrollPositionRestoration = o.scrollPositionRestoration || "disabled", o.anchorScrolling = o.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(n => { n instanceof ih ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = n.navigationTrigger, this.restoredId = n.restoredState ? n.restoredState.navigationId : 0) : n instanceof zr && (this.lastId = n.id, this.scheduleScrollEvent(n, this.router.parseUrl(n.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(n => { n instanceof Lw && (n.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(n.position) : n.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(n.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(n, r) { this.router.triggerEvent(new Lw(n, "popstate" === this.lastSource ? this.store[this.restoredId] : null, r)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } return e.\u0275fac = function (n) { od() }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); function ii(e, t) { return { \u0275kind: e, \u0275providers: t } } function Mh(e) { return [{ provide: Ch, multi: !0, useValue: e }] } function _0() { const e = Ae(Vt); return t => { const n = e.get(oc); if (t !== n.components[0]) return; const r = e.get(Ke), o = e.get(C0); 1 === e.get(Sh) && r.initialNavigation(), e.get(w0, null, k.Optional)?.setUpPreloading(), e.get(Eh, null, k.Optional)?.init(), r.resetRootComponentType(n.componentTypes[0]), o.closed || (o.next(), o.unsubscribe()) } } const C0 = new O("", { factory: () => new Pt }), Sh = new O("", { providedIn: "root", factory: () => 1 }); const w0 = new O(""); function KN(e) { return ii(0, [{ provide: w0, useExisting: qN }, { provide: m0, useExisting: e }]) } const b0 = new O("ROUTER_FORROOT_GUARD"), YN = [dc, { provide: Sw, useClass: Jf }, { provide: Ke, useFactory: p0 }, Es, { provide: qr, useFactory: function v0(e) { return e.routerState.root }, deps: [Ke] }, wh]; function QN() { return new K_("Router", Ke) } let D0 = (() => { class e { constructor(n) { } static forRoot(n, r) { return { ngModule: e, providers: [YN, [], Mh(n), { provide: b0, useFactory: tF, deps: [[Ke, new ji, new $i]] }, { provide: zc, useValue: r || {} }, r?.useHash ? { provide: $r, useClass: tP } : { provide: $r, useClass: CC }, { provide: Eh, useFactory: () => { const e = Ae(Ke), t = Ae(VC), n = Ae(zc); return n.scrollOffset && t.setOffset(n.scrollOffset), new y0(e, t, n) } }, r?.preloadingStrategy ? KN(r.preloadingStrategy).\u0275providers : [], { provide: K_, multi: !0, useFactory: QN }, r?.initialNavigation ? nF(r) : [], [{ provide: E0, useFactory: _0 }, { provide: B_, multi: !0, useExisting: E0 }]] } } static forChild(n) { return { ngModule: e, providers: [Mh(n)] } } } return e.\u0275fac = function (n) { return new (n || e)(E(b0, 8)) }, e.\u0275mod = $n({ type: e }), e.\u0275inj = _n({ imports: [hh] }), e })(); function tF(e) { return "guarded" } function nF(e) { return ["disabled" === e.initialNavigation ? ii(3, [{ provide: tc, multi: !0, useFactory: () => { const t = Ae(Ke); return () => { t.setUpLocationChangeListener() } } }, { provide: Sh, useValue: 2 }]).\u0275providers : [], "enabledBlocking" === e.initialNavigation ? ii(2, [{ provide: Sh, useValue: 0 }, { provide: tc, multi: !0, deps: [Vt], useFactory: t => { const n = t.get(JO, Promise.resolve()); let r = !1; return () => n.then(() => new Promise(i => { const s = t.get(Ke), a = t.get(C0); (function o(i) { t.get(Ke).events.pipe(Ze(a => a instanceof zr || a instanceof Rc || a instanceof Fw), H(a => a instanceof zr || a instanceof Rc && (0 === a.code || 1 === a.code) && null), Ze(a => null !== a), Xo(1)).subscribe(() => { i() }) })(() => { i(!0), r = !0 }), s.afterPreactivation = () => (i(!0), r || a.closed ? T(void 0) : a), s.initialNavigation() })) } }]).\u0275providers : []] } const E0 = new O(""); function M0(e, t, n, r, o, i, s) { try { var a = e[i](s), c = a.value } catch (u) { return void n(u) } a.done ? t(c) : Promise.resolve(c).then(r, o) } function Z(e) { return function () { var t = this, n = arguments; return new Promise(function (r, o) { var i = e.apply(t, n); function s(c) { M0(i, r, o, s, a, "next", c) } function a(c) { M0(i, r, o, s, a, "throw", c) } s(void 0) }) } } const Ih = { timeout: typeof navigator > "u" || "ReactNative" !== navigator.product ? 12e4 : 6e4 }; function oF(e) { const t = "string" == typeof e ? Object.assign({ url: e }, Ih) : Object.assign({}, Ih, e), n = new URL(t.url, "http://localhost"); if (t.timeout = S0(t.timeout), t.query) for (const [r, o] of Object.entries(t.query)) if (void 0 !== o) if (Array.isArray(o)) for (const i of o) n.searchParams.append(r, i); else n.searchParams.append(r, o); return t.method = t.body && !t.method ? "POST" : (t.method || "GET").toUpperCase(), t.url = "http://localhost" === n.origin ? "".concat(n.pathname, "?").concat(n.searchParams) : n.toString(), t } function S0(e) { if (!1 === e || 0 === e) return !1; if (e.connect || e.socket) return e; const t = Number(e); return isNaN(t) ? S0(Ih.timeout) : { connect: t, socket: t } } const iF = /^https?:\/\//i; function sF(e) { if (!iF.test(e.url)) throw new Error('"'.concat(e.url, '" is not a valid URL')) } var aF = Ve(689); const lF = ["request", "response", "progress", "error", "abort"], I0 = ["processOptions", "validateOptions", "interceptRequest", "finalizeOptions", "onRequest", "onResponse", "onError", "onReturn", "onHeaders"]; function T0(e, t) { const n = [], r = I0.reduce((i, s) => (i[s] = i[s] || [], i), { processOptions: [oF], validateOptions: [sF] }); function o(i) { const s = lF.reduce((p, g) => (p[g] = function uF() { const e = Object.create(null); let t = 0; return { publish: function r(o) { for (const i in e) e[i](o) }, subscribe: function n(o) { const i = t++; return e[i] = o, function () { delete e[i] } } } }(), p), {}), a = (e => function (n, r) { const o = "onError" === n; let i = r; for (var s = arguments.length, a = new Array(s > 2 ? s - 2 : 0), c = 2; c < s; c++)a[c - 2] = arguments[c]; for (let u = 0; u < e[n].length && (i = (0, e[n][u])(i, ...a), !o || i); u++); return i })(r), c = a("processOptions", i); a("validateOptions", c); const u = { options: c, channels: s, applyMiddleware: a }; let l = null; const d = s.request.subscribe(p => { l = t(p, (g, m) => function h(p, g, m) { let v = p, _ = g; if (!v) try { _ = a("onResponse", g, m) } catch (y) { _ = null, v = y } v = v && a("onError", v, m), v ? s.error.publish(v) : _ && s.response.publish(_) }(g, m, p)) }); s.abort.subscribe(() => { d(), l && l.abort() }); const f = a("onReturn", s, u); return f === s && s.request.publish(u), f } return o.use = function (s) { if (!s) throw new Error("Tried to add middleware that resolved to falsey value"); if ("function" == typeof s) throw new Error("Tried to add middleware that was a function. It probably expects you to pass options to it."); if (s.onReturn && r.onReturn.length > 0) throw new Error("Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event"); return I0.forEach(a => { s[a] && r[a].push(s[a]) }), n.push(s), o }, o.clone = function () { return T0(n, t) }, e.forEach(o.use), o } var Zc, Kc, ai, Yc, wr, x0 = (e, t, n) => { if (!t.has(e)) throw TypeError("Cannot " + n) }, xn = (e, t, n) => (x0(e, t, "read from private field"), n ? n.call(e) : t.get(e)), Os = (e, t, n) => { if (t.has(e)) throw TypeError("Cannot add the same private member more than once"); t instanceof WeakSet ? t.add(e) : t.set(e, n) }, si = (e, t, n, r) => (x0(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n); Zc = new WeakMap, Kc = new WeakMap, ai = new WeakMap, Yc = new WeakMap, wr = new WeakMap; const Th = "function" == typeof XMLHttpRequest ? "xhr" : "fetch", fF = "xhr" === Th ? XMLHttpRequest : class dF { constructor() { this.readyState = 0, this.responseType = "", Os(this, Zc, void 0), Os(this, Kc, void 0), Os(this, ai, void 0), Os(this, Yc, {}), Os(this, wr, void 0) } open(t, n, r) { si(this, Zc, t), si(this, Kc, n), si(this, ai, ""), this.readyState = 1, this.onreadystatechange(), si(this, wr, void 0) } abort() { xn(this, wr) && xn(this, wr).abort() } getAllResponseHeaders() { return xn(this, ai) } setRequestHeader(t, n) { xn(this, Yc)[t] = n } send(t) { const n = "arraybuffer" !== this.responseType, r = { method: xn(this, Zc), headers: xn(this, Yc), body: t }; "function" == typeof AbortController && (si(this, wr, new AbortController), typeof EventTarget < "u" && xn(this, wr).signal instanceof EventTarget && (r.signal = xn(this, wr).signal)), typeof document < "u" && (r.credentials = this.withCredentials ? "include" : "omit"), fetch(xn(this, Kc), r).then(o => (o.headers.forEach((i, s) => { si(this, ai, xn(this, ai) + "".concat(s, ": ").concat(i, "\r\n")) }), this.status = o.status, this.statusText = o.statusText, this.readyState = 3, n ? o.text() : o.arrayBuffer())).then(o => { "string" == typeof o ? this.responseText = o : this.response = o, this.readyState = 4, this.onreadystatechange() }).catch(o => { var i; "AbortError" !== o.name ? null == (i = this.onerror) || i.call(this, o) : this.onabort() }) } }; var hF = (e, t) => { const r = e.applyMiddleware("finalizeOptions", e.options), o = {}, i = e.applyMiddleware("interceptRequest", void 0, { adapter: Th, context: e }); if (i) { const y = setTimeout(t, 0, null, i); return { abort: () => clearTimeout(y) } } let s = new fF; const a = r.headers, c = r.timeout; let u = !1, l = !1, d = !1; if (s.onerror = y => { m(new Error("Request error while attempting to reach ".concat(r.url).concat(y.lengthComputable ? "(".concat(y.loaded, " of ").concat(y.total, " bytes transferred)") : ""))) }, s.ontimeout = y => { m(new Error("Request timeout while attempting to reach ".concat(r.url).concat(y.lengthComputable ? "(".concat(y.loaded, " of ").concat(y.total, " bytes transferred)") : ""))) }, s.onabort = () => { g(!0), u = !0 }, s.onreadystatechange = () => { (function p() { !c || (g(), o.socket = setTimeout(() => h("ESOCKETTIMEDOUT"), c.socket)) })(), !u && 4 === s.readyState && 0 !== s.status && function _() { if (!(u || l || d)) { if (0 === s.status) return void m(new Error("Unknown XHR error")); g(), l = !0, t(null, function v() { return { body: s.response || ("" === s.responseType || "text" === s.responseType ? s.responseText : ""), url: r.url, method: r.method, headers: aF(s.getAllResponseHeaders()), statusCode: s.status, statusMessage: s.statusText } }()) } }() }, s.open(r.method, r.url, !0), s.withCredentials = !!r.withCredentials, a && s.setRequestHeader) for (const y in a) a.hasOwnProperty(y) && s.setRequestHeader(y, a[y]); return r.rawBody && (s.responseType = "arraybuffer"), e.applyMiddleware("onRequest", { options: r, adapter: Th, request: s, context: e }), s.send(r.body || null), c && (o.connect = setTimeout(() => h("ETIMEDOUT"), c.connect)), { abort: function f() { u = !0, s && s.abort() } }; function h(y) { d = !0, s.abort(); const w = new Error("ESOCKETTIMEDOUT" === y ? "Socket timed out on request to ".concat(r.url) : "Connection timed out on request to ".concat(r.url)); w.code = y, e.channels.error.publish(w) } function g(y) { (y || u || s.readyState >= 2 && o.connect) && clearTimeout(o.connect), o.socket && clearTimeout(o.socket) } function m(y) { if (l) return; g(!0), l = !0, s = null; const w = y || new Error("Network error while attempting to reach ".concat(r.url)); w.isNetworkError = !0, w.request = r, t(w) } }; function O0(e) { return "[object Object]" === Object.prototype.toString.call(e) } Ve(455), Error; const P0 = typeof Buffer > "u" ? () => !1 : e => Buffer.isBuffer(e), EF = ["boolean", "string", "number"]; function SF(e) { return { onResponse: n => { const r = n.headers["content-type"] || "", o = e && e.force || -1 !== r.indexOf("application/json"); return n.body && r && o ? Object.assign({}, n, { body: t(n.body) }) : n }, processOptions: n => Object.assign({}, n, { headers: Object.assign({ Accept: "application/json" }, n.headers) }) }; function t(n) { try { return JSON.parse(n) } catch (r) { throw r.message = "Failed to parsed response body as JSON: ".concat(r.message), r } } } let ci; ci = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; var IF = ci; function TF() { const t = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).implementation || IF.Observable; if (!t) throw new Error("`Observable` is not available in global scope, and no implementation was passed"); return { onReturn: (n, r) => new t(o => (n.error.subscribe(i => o.error(i)), n.progress.subscribe(i => o.next(Object.assign({ type: "progress" }, i))), n.response.subscribe(i => { o.next(Object.assign({ type: "response" }, i)), o.complete() }), n.request.publish(r), () => n.abort.publish())) } } const xh = function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.implementation || Promise; if (!t) throw new Error("`Promise` is not available in global scope, and no implementation was passed"); return { onReturn: (n, r) => new t((o, i) => { const s = r.options.cancelToken; s && s.promise.then(a => { n.abort.publish(a), i(a) }), n.error.subscribe(i), n.response.subscribe(a => { o(e.onlyBody ? a.body : a) }), setTimeout(() => { try { n.request.publish(r) } catch (a) { i(a) } }, 0) }) } }; class k0 { constructor(t) { this.__CANCEL__ = !0, this.message = t } toString() { return "Cancel".concat(this.message ? ": ".concat(this.message) : "") } } const A0 = class { constructor(e) { if ("function" != typeof e) throw new TypeError("executor must be a function."); let t = null; this.promise = new Promise(n => { t = n }), e(n => { this.reason || (this.reason = new k0(n), t(this.reason)) }) } }; let R0 = A0; R0.source = () => { let e; return { token: new A0(n => { e = n }), cancel: e } }, xh.Cancel = k0, xh.CancelToken = R0, xh.isCancel = e => !(!e || !e?.__CANCEL__); var N0 = (e, t, n) => ("GET" === n.method || "HEAD" === n.method) && (e.isNetworkError || !1), kF = e => { const t = e.maxRetries || 5, n = e.retryDelay || AF, r = e.shouldRetry; return { onError: (o, i) => { const s = i.options, a = s.maxRetries || t, c = s.shouldRetry || r, u = s.attemptNumber || 0; if ((e => null !== e && "object" == typeof e && "function" == typeof e.pipe)(s.body) || !c(o, u, s) || u >= a) return o; const l = Object.assign({}, i, { options: Object.assign({}, s, { attemptNumber: u + 1 }) }); return setTimeout(() => i.channels.request.publish(l), n(u)), null } } }; function AF(e) { return 100 * Math.pow(2, e) + 100 * Math.random() } const Oh = function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return kF({ shouldRetry: N0, ...e }) }; function tt(e, t) { const n = "object" == typeof t; return new Promise((r, o) => { let s, i = !1; e.subscribe({ next: a => { s = a, i = !0 }, error: o, complete: () => { i ? r(s) : n ? r(t.defaultValue) : o(new ms) } }) }) } Oh.shouldRetry = N0; var F0 = []; class NF extends Error { constructor(t) { const n = L0(t); super(n.message), this.statusCode = 400, Object.assign(this, n) } } class FF extends Error { constructor(t) { const n = L0(t); super(n.message), this.statusCode = 500, Object.assign(this, n) } } function L0(e) { const t = e.body, n = { response: e, statusCode: e.statusCode, responseBody: $F(t, e), message: "", details: void 0 }; if (t.error && t.message) return n.message = "".concat(t.error, " - ").concat(t.message), n; if (function LF(e) { return j0(e) && j0(e.error) && "mutationError" === e.error.type && "string" == typeof e.error.description }(t)) { const r = t.error.items || [], o = r.slice(0, 5).map(s => { var a; return null == (a = s.error) ? void 0 : a.description }).filter(Boolean); let i = o.length ? ":\n- ".concat(o.join("\n- ")) : ""; return r.length > 5 && (i += "\n...and ".concat(r.length - 5, " more")), n.message = "".concat(t.error.description).concat(i), n.details = t.error, n } return t.error && t.error.description ? (n.message = t.error.description, n.details = t.error, n) : (n.message = t.error || t.message || function jF(e) { const t = e.statusMessage ? " ".concat(e.statusMessage) : ""; return "".concat(e.method, "-request to ").concat(e.url, " resulted in HTTP ").concat(e.statusCode).concat(t) }(e), n) } function j0(e) { return "object" == typeof e && null !== e && !Array.isArray(e) } function $F(e, t) { return -1 !== (t.headers["content-type"] || "").toLowerCase().indexOf("application/json") ? JSON.stringify(e, null, 2) : e } const UF = { onResponse: e => { if (e.statusCode >= 500) throw new FF(e); if (e.statusCode >= 400) throw new NF(e); return e } }, VF = { onResponse: e => { const t = e.headers["x-sanity-warning"]; return (Array.isArray(t) ? t : [t]).filter(Boolean).forEach(r => console.warn(r)), e } }; function $0(e, t) { let { maxRetries: n = 5, retryDelay: r } = t; const o = function () { return T0(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : hF) }([n > 0 ? Oh({ retryDelay: r, maxRetries: n, shouldRetry: BF }) : {}, ...e, VF, { processOptions: e => { const t = e.body; return !t || "function" == typeof t.pipe || P0(t) || -1 === EF.indexOf(typeof t) && !Array.isArray(t) && !function gF(e) { var t, n; return !1 !== O0(e) && (void 0 === (t = e.constructor) || !(!1 === O0(n = t.prototype) || !1 === n.hasOwnProperty("isPrototypeOf"))) }(t) ? e : Object.assign({}, e, { body: JSON.stringify(e.body), headers: Object.assign({}, e.headers, { "Content-Type": "application/json" }) }) } }, SF(), { onRequest: e => { if ("xhr" !== e.adapter) return; const t = e.request, n = e.context; function r(o) { return i => { n.channels.progress.publish({ stage: o, percent: i.lengthComputable ? i.loaded / i.total * 100 : -1, total: i.total, loaded: i.loaded, lengthComputable: i.lengthComputable }) } } "upload" in t && "onprogress" in t.upload && (t.upload.onprogress = r("upload")), "onprogress" in t && (t.onprogress = r("download")) } }, UF, TF({ implementation: _e })]); function i(s) { return (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : o)({ maxRedirects: 0, ...s }) } return i.defaultRequester = o, i } function BF(e, t, n) { const r = "GET" === n.method || "HEAD" === n.method, i = (n.uri || n.url).startsWith("/data/query"); return !(!r && !i || !e.response || 429 !== e.response.statusCode && 502 !== e.response.statusCode && 503 !== e.response.statusCode) || Oh.shouldRetry(e, t, n) } const HF = "X-Sanity-Project-ID"; function U0(e) { if ("string" == typeof e || Array.isArray(e)) return { id: e }; if ("object" == typeof e && null !== e && "query" in e && "string" == typeof e.query) return "params" in e && "object" == typeof e.params && null !== e.params ? { query: e.query, params: e.params } : { query: e.query }; const t = ["* Document ID (<docId>)", "* Array of document IDs", "* Object containing `query`"].join("\n"); throw new Error("Unknown selection - must be one of:\n\n".concat(t)) } const V0 = ["image", "file"], B0 = ["before", "after", "replace"], H0 = e => { if (!/^(~[a-z0-9]{1}[-\w]{0,63}|[a-z0-9]{1}[-\w]{0,63})$/.test(e)) throw new Error("Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 64 characters") }, WF = e => { if (-1 === V0.indexOf(e)) throw new Error("Invalid asset type: ".concat(e, ". Must be one of ").concat(V0.join(", "))) }, Ps = (e, t) => { if (null === t || "object" != typeof t || Array.isArray(t)) throw new Error("".concat(e, "() takes an object of properties")) }, z0 = (e, t) => { if ("string" != typeof t || !/^[a-z0-9_][a-z0-9_.-]{0,127}$/i.test(t) || t.includes("..")) throw new Error("".concat(e, '(): "').concat(t, '" is not a valid document ID')) }, Qc = (e, t) => { if (!t._id) throw new Error("".concat(e, '() requires that the document contains an ID ("_id" property)')); z0(e, t._id) }, q0 = e => { if (!e.dataset) throw new Error("`dataset` must be provided to perform queries"); return e.dataset || "" }, W0 = e => { if ("string" != typeof e || !/^[a-z0-9._-]{1,75}$/i.test(e)) throw new Error("Tag can only contain alphanumeric characters, underscores, dashes and dots, and be between one and 75 characters long."); return e }, G0 = e => { let { query: t, params: n = {}, options: r = {} } = e; const o = new URLSearchParams, { tag: i, ...s } = r; i && o.set("tag", i), o.set("query", t); for (const [a, c] of Object.entries(n)) o.set("$".concat(a), JSON.stringify(c)); for (const [a, c] of Object.entries(s)) c && o.set(a, "".concat(c)); return "?".concat(o) }; var li, di, Z0 = (e, t, n) => { if (!t.has(e)) throw TypeError("Cannot " + n) }, ui = (e, t, n) => (Z0(e, t, "read from private field"), n ? n.call(e) : t.get(e)), K0 = (e, t, n) => { if (t.has(e)) throw TypeError("Cannot add the same private member more than once"); t instanceof WeakSet ? t.add(e) : t.set(e, n) }, Y0 = (e, t, n, r) => (Z0(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n); class Q0 { constructor(t) { let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; this.selection = t, this.operations = n } set(t) { return this._assign("set", t) } setIfMissing(t) { return this._assign("setIfMissing", t) } diffMatchPatch(t) { return Ps("diffMatchPatch", t), this._assign("diffMatchPatch", t) } unset(t) { if (!Array.isArray(t)) throw new Error("unset(attrs) takes an array of attributes to unset, non-array given"); return this.operations = Object.assign({}, this.operations, { unset: t }), this } inc(t) { return this._assign("inc", t) } dec(t) { return this._assign("dec", t) } insert(t, n, r) { return ((e, t, n) => { const r = "insert(at, selector, items)"; if (-1 === B0.indexOf(e)) { const o = B0.map(i => '"'.concat(i, '"')).join(", "); throw new Error("".concat(r, ' takes an "at"-argument which is one of: ').concat(o)) } if ("string" != typeof t) throw new Error("".concat(r, ' takes a "selector"-argument which must be a string')); if (!Array.isArray(n)) throw new Error("".concat(r, ' takes an "items"-argument which must be an array')) })(t, n, r), this._assign("insert", { [t]: n, items: r }) } append(t, n) { return this.insert("after", "".concat(t, "[-1]"), n) } prepend(t, n) { return this.insert("before", "".concat(t, "[0]"), n) } splice(t, n, r, o) { const s = n < 0 ? n - 1 : n, a = typeof r > "u" || -1 === r ? -1 : Math.max(0, n + r), c = s < 0 && a >= 0 ? "" : a, u = "".concat(t, "[").concat(s, ":").concat(c, "]"); return this.insert("replace", u, o || []) } ifRevisionId(t) { return this.operations.ifRevisionID = t, this } serialize() { return { ...U0(this.selection), ...this.operations } } toJSON() { return this.serialize() } reset() { return this.operations = {}, this } _assign(t, n) { let r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; return Ps(t, n), this.operations = Object.assign({}, this.operations, { [t]: Object.assign({}, r && this.operations[t] || {}, n) }), this } _set(t, n) { return this._assign(t, n, !1) } } const X0 = class extends Q0 { constructor(e, t, n) { super(e, t), K0(this, li, void 0), Y0(this, li, n) } clone() { return new X0(this.selection, { ...this.operations }, ui(this, li)) } commit(e) { if (!ui(this, li)) throw new Error("No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method"); const n = Object.assign({ returnFirst: "string" == typeof this.selection, returnDocuments: !0 }, e); return ui(this, li).mutate({ patch: this.serialize() }, n) } }; let ks = X0; li = new WeakMap; const J0 = class extends Q0 { constructor(e, t, n) { super(e, t), K0(this, di, void 0), Y0(this, di, n) } clone() { return new J0(this.selection, { ...this.operations }, ui(this, di)) } commit(e) { if (!ui(this, di)) throw new Error("No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method"); const n = Object.assign({ returnFirst: "string" == typeof this.selection, returnDocuments: !0 }, e); return ui(this, di).mutate({ patch: this.serialize() }, n) } }; let As = J0; di = new WeakMap; var Wr, Gr, eb = (e, t, n) => { if (!t.has(e)) throw TypeError("Cannot " + n) }, br = (e, t, n) => (eb(e, t, "read from private field"), n ? n.call(e) : t.get(e)), tb = (e, t, n) => { if (t.has(e)) throw TypeError("Cannot add the same private member more than once"); t instanceof WeakSet ? t.add(e) : t.set(e, n) }, nb = (e, t, n, r) => (eb(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n); const rb = { returnDocuments: !1 }; class ob { constructor() { let n = arguments.length > 1 ? arguments[1] : void 0; this.operations = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], this.trxId = n } create(t) { return Ps("create", t), this._add({ create: t }) } createIfNotExists(t) { const n = "createIfNotExists"; return Ps(n, t), Qc(n, t), this._add({ [n]: t }) } createOrReplace(t) { const n = "createOrReplace"; return Ps(n, t), Qc(n, t), this._add({ [n]: t }) } delete(t) { return z0("delete", t), this._add({ delete: { id: t } }) } transactionId(t) { return t ? (this.trxId = t, this) : this.trxId } serialize() { return [...this.operations] } toJSON() { return this.serialize() } reset() { return this.operations = [], this } _add(t) { return this.operations.push(t), this } } const ib = class extends ob { constructor(e, t, n) { super(e, n), tb(this, Wr, void 0), nb(this, Wr, t) } clone() { return new ib([...this.operations], br(this, Wr), this.trxId) } commit(e) { if (!br(this, Wr)) throw new Error("No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method"); return br(this, Wr).mutate(this.serialize(), Object.assign({ transactionId: this.trxId }, rb, e || {})) } patch(e, t) { const n = "function" == typeof t; if ("string" != typeof e && e instanceof As) return this._add({ patch: e.serialize() }); if (n) { const o = t(new As(e, {}, br(this, Wr))); if (!(o instanceof As)) throw new Error("function passed to `patch()` must return the patch"); return this._add({ patch: o.serialize() }) } return this._add({ patch: { id: e, ...t } }) } }; let sb = ib; Wr = new WeakMap; const ab = class extends ob { constructor(e, t, n) { super(e, n), tb(this, Gr, void 0), nb(this, Gr, t) } clone() { return new ab([...this.operations], br(this, Gr), this.trxId) } commit(e) { if (!br(this, Gr)) throw new Error("No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method"); return br(this, Gr).mutate(this.serialize(), Object.assign({ transactionId: this.trxId }, rb, e || {})) } patch(e, t) { const n = "function" == typeof t; if ("string" != typeof e && e instanceof ks) return this._add({ patch: e.serialize() }); if (n) { const o = t(new ks(e, {}, br(this, Gr))); if (!(o instanceof ks)) throw new Error("function passed to `patch()` must return the patch"); return this._add({ patch: o.serialize() }) } return this._add({ patch: { id: e, ...t } }) } }; let cb = ab; Gr = new WeakMap; const ZF = (e, t) => !1 === e ? void 0 : typeof e > "u" ? t : e, KF = function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return { dryRun: e.dryRun, returnIds: !0, returnDocuments: ZF(e.returnDocuments, !0), visibility: e.visibility || "sync", autoGenerateArrayKeys: e.autoGenerateArrayKeys, skipCrossDatasetReferenceValidation: e.skipCrossDatasetReferenceValidation } }, kh = e => "response" === e.type, YF = e => e.body, QF = (e, t) => e.reduce((n, r) => (n[t(r)] = r, n), Object.create(null)); function ub(e, t, n, r) { let o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {}; const i = !1 === o.filterResponse ? s => s : s => s.result; return Rs(e, t, "query", { query: n, params: r }, o).pipe(H(i)) } function lb(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; const o = { uri: fi(e, "doc", n), json: !0, tag: r.tag }; return Ns(e, t, o).pipe(Ze(kh), H(i => i.body.documents && i.body.documents[0])) } function db(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; const o = { uri: fi(e, "doc", n.join(",")), json: !0, tag: r.tag }; return Ns(e, t, o).pipe(Ze(kh), H(i => { const s = QF(i.body.documents || [], a => a._id); return n.map(a => s[a] || null) })) } function fb(e, t, n, r) { return Qc("createIfNotExists", n), Xc(e, t, n, "createIfNotExists", r) } function hb(e, t, n, r) { return Qc("createOrReplace", n), Xc(e, t, n, "createOrReplace", r) } function pb(e, t, n, r) { return Rs(e, t, "mutate", { mutations: [{ delete: U0(n) }] }, r) } function gb(e, t, n, r) { let o; return o = n instanceof As || n instanceof ks ? { patch: n.serialize() } : n instanceof sb || n instanceof cb ? n.serialize() : n, Rs(e, t, "mutate", { mutations: Array.isArray(o) ? o : [o], transactionId: r && r.transactionId || void 0 }, r) } function Rs(e, t, n, r) { let o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {}; const i = "mutate" === n, s = "query" === n, a = i ? "" : G0(r), c = !i && a.length < 11264, u = c ? a : "", l = o.returnFirst, { timeout: d, token: f, tag: h, headers: p } = o, g = fi(e, n, u), m = { method: c ? "GET" : "POST", uri: g, json: !0, body: c ? void 0 : r, query: i && KF(o), timeout: d, headers: p, token: f, tag: h, canUseCdn: s, signal: o.signal }; return Ns(e, t, m).pipe(Ze(kh), H(YF), H(v => { if (!i) return v; const _ = v.results || []; if (o.returnDocuments) return l ? _[0] && _[0].document : _.map(N => N.document); const y = l ? "documentId" : "documentIds", w = l ? _[0] && _[0].id : _.map(N => N.id); return { transactionId: v.transactionId, results: _, [y]: w } })) } function Xc(e, t, n, r) { let o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {}; const i = { [r]: n }, s = Object.assign({ returnFirst: !0, returnDocuments: !0 }, o); return Rs(e, t, "mutate", { mutations: [i] }, s) } function Ns(e, t, n) { const r = n.url || n.uri, o = e.config(), i = typeof n.canUseCdn > "u" ? ["GET", "HEAD"].indexOf(n.method || "GET") >= 0 && 0 === r.indexOf("/data/") : n.canUseCdn, s = o.useCdn && i, a = n.tag && o.requestTagPrefix ? [o.requestTagPrefix, n.tag].join(".") : n.tag || o.requestTagPrefix; a && (n.query = { tag: W0(a), ...n.query }), ["GET", "HEAD"].indexOf(n.method || "GET") >= 0 && 0 === r.indexOf("/data/query/") && (o.resultSourceMap && (n.query = { resultSourceMap: !0, ...n.query }), "string" == typeof o.perspective && "all" !== o.perspective && (n.query = { perspective: o.perspective, ...n.query })); const c = function zF(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = {}, r = t.token || e.token; r && (n.Authorization = "Bearer ".concat(r)), !t.useGlobalApi && !e.useProjectHostname && e.projectId && (n[HF] = e.projectId); const o = Boolean(typeof t.withCredentials > "u" ? e.token || e.withCredentials : t.withCredentials), i = typeof t.timeout > "u" ? e.timeout : t.timeout; return Object.assign({}, t, { headers: Object.assign({}, n, t.headers || {}), timeout: typeof i > "u" ? 3e5 : i, proxy: t.proxy || e.proxy, json: !0, withCredentials: o }) }(o, Object.assign({}, n, { url: Ah(e, r, s) })), u = new _e(l => t(c, o.requester).subscribe(l)); return n.signal ? u.pipe(function JF(e) { return t => new _e(n => { const r = () => n.error(function tL(e) { var t, n; if (eL) return new DOMException(null != (t = e?.reason) ? t : "The operation was aborted.", "AbortError"); const r = new Error(null != (n = e?.reason) ? n : "The operation was aborted."); return r.name = "AbortError", r }(e)); if (e && e.aborted) return void r(); const o = t.subscribe(n); return e.addEventListener("abort", r), () => { e.removeEventListener("abort", r), o.unsubscribe() } }) }(n.signal)) : u } function vn(e, t, n) { return Ns(e, t, n).pipe(Ze(o => "response" === o.type), H(o => o.body)) } function fi(e, t, n) { const r = e.config(), o = q0(r), i = "/".concat(t, "/").concat(o), s = n ? "".concat(i, "/").concat(n) : i; return "/data".concat(s).replace(/\/($|\?)/, "$1") } function Ah(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const { url: r, cdnUrl: o } = e.config(), i = n ? o : r; return "".concat(i, "/").concat(t.replace(/^\//, "")) } const eL = Boolean(globalThis.DOMException); var nu, ru, ou, iu, mb = (e, t, n) => { if (!t.has(e)) throw TypeError("Cannot " + n) }, Jc = (e, t, n) => (mb(e, t, "read from private field"), n ? n.call(e) : t.get(e)), eu = (e, t, n) => { if (t.has(e)) throw TypeError("Cannot add the same private member more than once"); t instanceof WeakSet ? t.add(e) : t.set(e, n) }, tu = (e, t, n, r) => (mb(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n); class nL { constructor(t, n) { eu(this, nu, void 0), eu(this, ru, void 0), tu(this, nu, t), tu(this, ru, n) } upload(t, n, r) { return yb(Jc(this, nu), Jc(this, ru), t, n, r) } } nu = new WeakMap, ru = new WeakMap; class rL { constructor(t, n) { eu(this, ou, void 0), eu(this, iu, void 0), tu(this, ou, t), tu(this, iu, n) } upload(t, n, r) { return tt(yb(Jc(this, ou), Jc(this, iu), t, n, r).pipe(Ze(i => "response" === i.type), H(i => i.body.document))) } } function yb(e, t, n, r) { let o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {}; WF(n); let i = o.extract || void 0; i && !i.length && (i = ["none"]); const s = q0(e.config()), a = "image" === n ? "images" : "files", c = oL(o, r), { tag: u, label: l, title: d, description: f, creditLine: h, filename: p, source: g } = c, m = { label: l, title: d, description: f, filename: p, meta: i, creditLine: h }; return g && (m.sourceId = g.id, m.sourceName = g.name, m.sourceUrl = g.url), Ns(e, t, { tag: u, method: "POST", timeout: c.timeout || 0, uri: "/assets/".concat(a, "/").concat(s), headers: c.contentType ? { "Content-Type": c.contentType } : {}, query: m, body: r }) } function oL(e, t) { return typeof File > "u" || !(t instanceof File) ? e : Object.assign({ filename: !1 === e.preserveFilename ? void 0 : t.name, contentType: t.type }, e) } function Rh(e) { return "https://www.sanity.io/help/" + e } ou = new WeakMap, iu = new WeakMap; const su = e => function sL(e) { let n, t = !1; return function () { return t || (n = e(...arguments), t = !0), n } }(function () { for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)n[r] = arguments[r]; return console.warn(e.join(" "), ...n) }), aL = su(["Since you haven't set a value for `useCdn`, we will deliver content using our", "global, edge-cached API-CDN. If you wish to have content delivered faster, set", "`useCdn: false` to use the Live API. Note: You may incur higher costs using the live API."]), cL = su(["You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.", "See ".concat(Rh("js-client-browser-token"), " for more information and how to hide this warning.")]), uL = su(["Using the Sanity client without specifying an API version is deprecated.", "See ".concat(Rh("js-client-api-version"))]), au = (su(["The default export of @sanity/client has been deprecated. Use the named export `createClient` instead."]), { apiHost: "https://api.sanity.io", apiVersion: "1", useProjectHostname: !0 }), fL = ["localhost", "127.0.0.1", "0.0.0.0"], vb = (e, t) => { const n = Object.assign({}, t, e); n.apiVersion || uL(); const r = Object.assign({}, au, n), o = r.useProjectHostname; if (typeof Promise > "u") { const d = Rh("js-client-promise-polyfill"); throw new Error("No native Promise-implementation found, polyfill needed - see ".concat(d)) } if (o && !r.projectId) throw new Error("Configuration must contain `projectId`"); const i = typeof window < "u" && window.location && window.location.hostname, s = i && (e => -1 !== fL.indexOf(e))(window.location.hostname); i && s && r.token && !0 !== r.ignoreBrowserTokenWarning ? cL() : typeof r.useCdn > "u" && aL(), o && (e => { if (!/^[-a-z0-9]+$/i.test(e)) throw new Error("`projectId` can only contain only a-z, 0-9 and dashes") })(r.projectId), r.dataset && H0(r.dataset), "requestTagPrefix" in r && (r.requestTagPrefix = r.requestTagPrefix ? W0(r.requestTagPrefix).replace(/\.+$/, "") : void 0), r.apiVersion = "".concat(r.apiVersion).replace(/^v/, ""), r.isDefaultApi = r.apiHost === au.apiHost, r.useCdn = !1 !== r.useCdn && !r.withCredentials, function (t) { if ("1" === t || "X" === t) return; const n = new Date(t); if (!(/^\d{4}-\d{2}-\d{2}$/.test(t) && n instanceof Date && n.getTime() > 0)) throw new Error("Invalid API version string, expected `1` or date in format `YYYY-MM-DD`") }(r.apiVersion); const a = r.apiHost.split("://", 2), c = a[0], u = a[1], l = r.isDefaultApi ? "apicdn.sanity.io" : u; return r.useProjectHostname ? (r.url = "".concat(c, "://").concat(r.projectId, ".").concat(u, "/v").concat(r.apiVersion), r.cdnUrl = "".concat(c, "://").concat(r.projectId, ".").concat(l, "/v").concat(r.apiVersion)) : (r.url = "".concat(r.apiHost, "/v").concat(r.apiVersion), r.cdnUrl = r.url), r }; var gL = (e, t) => Object.keys(t).concat(Object.keys(e)).reduce((n, r) => (n[r] = typeof e[r] > "u" ? t[r] : e[r], n), {}); const mL = (e, t) => t.reduce((n, r) => (typeof e[r] > "u" || (n[r] = e[r]), n), {}), vL = ["includePreviousRevision", "includeResult", "visibility", "effectFormat", "tag"], _L = { includeResult: !0 }; function _b(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const { url: r, token: o, withCredentials: i, requestTagPrefix: s } = this.config(), a = n.tag && s ? [s, n.tag].join(".") : n.tag, c = { ...gL(n, _L), tag: a }, u = mL(c, vL), l = G0({ query: e, params: t, options: { tag: a, ...u } }), d = "".concat(r).concat(fi(this, "listen", l)); if (d.length > 14800) return new _e(g => g.error(new Error("Query too large for listener"))); const f = c.events ? c.events : ["mutation"], h = -1 !== f.indexOf("reconnect"), p = {}; return (o || i) && (p.withCredentials = !0), o && (p.headers = { Authorization: "Bearer ".concat(o) }), new _e(g => { let m; Mt().then(Qe => { m = Qe }).catch(Qe => { g.error(Qe), no() }); let v, _ = !1; function y() { _ || (function Et() { h && g.next({ type: "reconnect" }) }(), !_ && m.readyState === m.CLOSED && (gt(), clearTimeout(v), v = setTimeout(zs, 100))) } function w(Qe) { g.error(CL(Qe)) } function N(Qe) { const zt = Cb(Qe); return zt instanceof Error ? g.error(zt) : g.next(zt) } function ne() { _ = !0, gt(), g.complete() } function gt() { !m || (m.removeEventListener("error", y), m.removeEventListener("channelError", w), m.removeEventListener("disconnect", ne), f.forEach(Qe => m.removeEventListener(Qe, N)), m.close()) } function Mt() { return nr.apply(this, arguments) } function nr() { return (nr = Z(function* () { const { default: Qe } = yield Ve.e(111).then(Ve.t.bind(Ve, 111, 19)), zt = new Qe(d, p); return zt.addEventListener("error", y), zt.addEventListener("channelError", w), zt.addEventListener("disconnect", ne), f.forEach(qs => zt.addEventListener(qs, N)), zt })).apply(this, arguments) } function zs() { Mt().then(Qe => { m = Qe }).catch(Qe => { g.error(Qe), no() }) } function no() { _ = !0, gt() } return no }) } function Cb(e) { try { const t = e.data && JSON.parse(e.data) || {}; return Object.assign({ type: e.type }, t) } catch (t) { return t } } function CL(e) { if (e instanceof Error) return e; const t = Cb(e); return t instanceof Error ? t : new Error(function wL(e) { return e.error ? e.error.description ? e.error.description : "string" == typeof e.error ? e.error : JSON.stringify(e.error, null, 2) : e.message || "Unknown listener error" }(t)) } var Zr, Kr, Yr, Qr, wb = (e, t, n) => { if (!t.has(e)) throw TypeError("Cannot " + n) }, pt = (e, t, n) => (wb(e, t, "read from private field"), n ? n.call(e) : t.get(e)), cu = (e, t, n) => { if (t.has(e)) throw TypeError("Cannot add the same private member more than once"); t instanceof WeakSet ? t.add(e) : t.set(e, n) }, uu = (e, t, n, r) => (wb(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n); class bL { constructor(t, n) { cu(this, Zr, void 0), cu(this, Kr, void 0), uu(this, Zr, t), uu(this, Kr, n) } create(t, n) { return hi(pt(this, Zr), pt(this, Kr), "PUT", t, n) } edit(t, n) { return hi(pt(this, Zr), pt(this, Kr), "PATCH", t, n) } delete(t) { return hi(pt(this, Zr), pt(this, Kr), "DELETE", t) } list() { return vn(pt(this, Zr), pt(this, Kr), { uri: "/datasets" }) } } Zr = new WeakMap, Kr = new WeakMap; class DL { constructor(t, n) { cu(this, Yr, void 0), cu(this, Qr, void 0), uu(this, Yr, t), uu(this, Qr, n) } create(t, n) { return tt(hi(pt(this, Yr), pt(this, Qr), "PUT", t, n)) } edit(t, n) { return tt(hi(pt(this, Yr), pt(this, Qr), "PATCH", t, n)) } delete(t) { return tt(hi(pt(this, Yr), pt(this, Qr), "DELETE", t)) } list() { return tt(vn(pt(this, Yr), pt(this, Qr), { uri: "/datasets" })) } } function hi(e, t, n, r, o) { return H0(r), vn(e, t, { method: n, uri: "/datasets/".concat(r), body: o }) } Yr = new WeakMap, Qr = new WeakMap; var Fs, Ls, js, $s, bb = (e, t, n) => { if (!t.has(e)) throw TypeError("Cannot " + n) }, Dr = (e, t, n) => (bb(e, t, "read from private field"), n ? n.call(e) : t.get(e)), lu = (e, t, n) => { if (t.has(e)) throw TypeError("Cannot add the same private member more than once"); t instanceof WeakSet ? t.add(e) : t.set(e, n) }, du = (e, t, n, r) => (bb(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n); class EL { constructor(t, n) { lu(this, Fs, void 0), lu(this, Ls, void 0), du(this, Fs, t), du(this, Ls, n) } list() { return vn(Dr(this, Fs), Dr(this, Ls), { uri: "/projects" }) } getById(t) { return vn(Dr(this, Fs), Dr(this, Ls), { uri: "/projects/".concat(t) }) } } Fs = new WeakMap, Ls = new WeakMap; class ML { constructor(t, n) { lu(this, js, void 0), lu(this, $s, void 0), du(this, js, t), du(this, $s, n) } list() { return tt(vn(Dr(this, js), Dr(this, $s), { uri: "/projects" })) } getById(t) { return tt(vn(Dr(this, js), Dr(this, $s), { uri: "/projects/".concat(t) })) } } js = new WeakMap, $s = new WeakMap; var gu, mu, yu, vu, Db = (e, t, n) => { if (!t.has(e)) throw TypeError("Cannot " + n) }, fu = (e, t, n) => (Db(e, t, "read from private field"), n ? n.call(e) : t.get(e)), hu = (e, t, n) => { if (t.has(e)) throw TypeError("Cannot add the same private member more than once"); t instanceof WeakSet ? t.add(e) : t.set(e, n) }, pu = (e, t, n, r) => (Db(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n); class SL { constructor(t, n) { hu(this, gu, void 0), hu(this, mu, void 0), pu(this, gu, t), pu(this, mu, n) } getById(t) { return vn(fu(this, gu), fu(this, mu), { uri: "/users/".concat(t) }) } } gu = new WeakMap, mu = new WeakMap; class IL { constructor(t, n) { hu(this, yu, void 0), hu(this, vu, void 0), pu(this, yu, t), pu(this, vu, n) } getById(t) { return tt(vn(fu(this, yu), fu(this, vu), { uri: "/users/".concat(t) })) } } yu = new WeakMap, vu = new WeakMap; var Xr, nt, Jr, Ye, Eb = (e, t, n) => { if (!t.has(e)) throw TypeError("Cannot " + n) }, K = (e, t, n) => (Eb(e, t, "read from private field"), n ? n.call(e) : t.get(e)), _u = (e, t, n) => { if (t.has(e)) throw TypeError("Cannot add the same private member more than once"); t instanceof WeakSet ? t.add(e) : t.set(e, n) }, Cu = (e, t, n, r) => (Eb(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n); const Nh = class { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : au; _u(this, Xr, void 0), _u(this, nt, void 0), this.listen = _b, this.config(t), Cu(this, nt, e), this.assets = new nL(this, K(this, nt)), this.datasets = new bL(this, K(this, nt)), this.projects = new EL(this, K(this, nt)), this.users = new SL(this, K(this, nt)) } clone() { return new Nh(K(this, nt), this.config()) } config(e) { if (void 0 === e) return { ...K(this, Xr) }; if (K(this, Xr) && !1 === K(this, Xr).allowReconfigure) throw new Error("Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client"); return Cu(this, Xr, vb(e, K(this, Xr) || {})), this } withConfig(e) { return new Nh(K(this, nt), { ...this.config(), ...e }) } fetch(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return ub(this, K(this, nt), e, t, n) } getDocument(e, t) { return lb(this, K(this, nt), e, t) } getDocuments(e, t) { return db(this, K(this, nt), e, t) } create(e, t) { return Xc(this, K(this, nt), e, "create", t) } createIfNotExists(e, t) { return fb(this, K(this, nt), e, t) } createOrReplace(e, t) { return hb(this, K(this, nt), e, t) } delete(e, t) { return pb(this, K(this, nt), e, t) } mutate(e, t) { return gb(this, K(this, nt), e, t) } patch(e, t) { return new ks(e, t, this) } transaction(e) { return new cb(e, this) } request(e) { return vn(this, K(this, nt), e) } getUrl(e, t) { return Ah(this, e, t) } getDataUrl(e, t) { return fi(this, e, t) } }; let TL = Nh; Xr = new WeakMap, nt = new WeakMap; const Fh = class { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : au; _u(this, Jr, void 0), _u(this, Ye, void 0), this.listen = _b, this.config(t), Cu(this, Ye, e), this.assets = new rL(this, K(this, Ye)), this.datasets = new DL(this, K(this, Ye)), this.projects = new ML(this, K(this, Ye)), this.users = new IL(this, K(this, Ye)), this.observable = new TL(e, t) } clone() { return new Fh(K(this, Ye), this.config()) } config(e) { if (void 0 === e) return { ...K(this, Jr) }; if (K(this, Jr) && !1 === K(this, Jr).allowReconfigure) throw new Error("Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client"); return this.observable && this.observable.config(e), Cu(this, Jr, vb(e, K(this, Jr) || {})), this } withConfig(e) { return new Fh(K(this, Ye), { ...this.config(), ...e }) } fetch(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return tt(ub(this, K(this, Ye), e, t, n)) } getDocument(e, t) { return tt(lb(this, K(this, Ye), e, t)) } getDocuments(e, t) { return tt(db(this, K(this, Ye), e, t)) } create(e, t) { return tt(Xc(this, K(this, Ye), e, "create", t)) } createIfNotExists(e, t) { return tt(fb(this, K(this, Ye), e, t)) } createOrReplace(e, t) { return tt(hb(this, K(this, Ye), e, t)) } delete(e, t) { return tt(pb(this, K(this, Ye), e, t)) } mutate(e, t) { return tt(gb(this, K(this, Ye), e, t)) } patch(e, t) { return new As(e, t, this) } transaction(e) { return new sb(e, this) } request(e) { return tt(vn(this, K(this, Ye), e)) } dataRequest(e, t, n) { return tt(Rs(this, K(this, Ye), e, t, n)) } getUrl(e, t) { return Ah(this, e, t) } getDataUrl(e, t) { return fi(this, e, t) } }; let Mb = Fh; Jr = new WeakMap, Ye = new WeakMap, $0(F0, {}); const OL = { option: (e = { projectId: "s672gy3w", dataset: "production", apiVersion: "2022-11-15" }, new Mb($0(F0, { maxRetries: e.maxRetries, retryDelay: e.retryDelay }), e)) }; var e; let Ib = (() => { class e { constructor() { } getClient() { return OL } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), Tb = (() => { class e { constructor() { this.locales = [{ name: "en", icon: "EN", default: !0 }, { name: "bg", icon: "BG", default: !1 }], this.selectedLocale = this.locales.find(n => n.name === navigator.language.split("-")[0]) } setLocale(n) { this.selectedLocale = this.locales[n] } getLocale() { return this.selectedLocale ? this.selectedLocale : this.locales.find(n => 1 == n.default) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), PL = (() => { class e { constructor(n, r) { this.sanityService = n, this.localeService = r, this.selectedLocale = r.getLocale() } getHomePage() { return this.sanityService.getClient().option.fetch(`*[_type == "homePage"]{\n        title,\n        content[]{ \n          title{\n            "text":${this.selectedLocale.name}\n          },\n          text{\n            "text":${this.selectedLocale.name}\n          },\n          key,\n          display,\n          mainImage{\n             asset->{\n              url\n            },\n          },\n          buttonText{\n            "text":${this.selectedLocale.name}\n          },\n          buttonHREF,\n          boxItems[]{\n            title{\n              "text":${this.selectedLocale.name}\n            },\n            text{\n              "text":${this.selectedLocale.name}\n            },\n            icon,\n            link,\n            image{\n             asset->{\n                url\n              }\n            }\n          }\n      }\n}[0]`) } } return e.\u0275fac = function (n) { return new (n || e)(E(Ib), E(Tb)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function kL(e, t) { if (1 & e && me(0, "div", 9), 2 & e) { const n = ft(); gr("height", n.pbThickness, "px")("color", n.pbColor), Xi("ngx-position-absolute", n.loaderId !== n.defaultConfig.masterLoaderId)("loading-foreground", n.showForeground)("foreground-closing", n.foregroundClosing)("fast-closing", n.foregroundClosing && n.fastFadeOut), J("ngClass", "ngx-progress-bar-" + n.pbDirection) } } function AL(e, t) { if (1 & e && me(0, "img", 10), 2 & e) { const n = ft(); gr("width", n.logoSize, "px")("height", n.logoSize, "px")("top", n.logoTop), J("ngClass", n.logoPosition)("src", n.trustedLogoUrl, zn) } } function RL(e, t) { 1 & e && me(0, "div") } function NL(e, t) { if (1 & e && (ee(0, "div"), we(1, RL, 1, 0, "div", 11), Q()), 2 & e) { const n = ft(); za(n.fgSpinnerClass), A(1), J("ngForOf", n.fgDivs) } } function FL(e, t) { 1 & e && Ba(0) } function LL(e, t) { 1 & e && we(0, FL, 1, 0, "ng-container", 12), 2 & e && J("ngTemplateOutlet", ft().fgsTemplate) } function jL(e, t) { 1 & e && me(0, "div") } function $L(e, t) { if (1 & e && (ee(0, "div"), we(1, jL, 1, 0, "div", 11), Q()), 2 & e) { const n = ft(); za(n.bgSpinnerClass), A(1), J("ngForOf", n.bgDivs) } } function UL(e, t) { 1 & e && Ba(0) } function VL(e, t) { 1 & e && we(0, UL, 1, 0, "ng-container", 12), 2 & e && J("ngTemplateOutlet", ft().bgsTemplate) } var Us = (() => (function (e) { e.ballScaleMultiple = "ball-scale-multiple", e.ballSpin = "ball-spin", e.ballSpinClockwise = "ball-spin-clockwise", e.ballSpinClockwiseFadeRotating = "ball-spin-clockwise-fade-rotating", e.ballSpinFadeRotating = "ball-spin-fade-rotating", e.chasingDots = "chasing-dots", e.circle = "circle", e.cubeGrid = "cube-grid", e.doubleBounce = "double-bounce", e.fadingCircle = "fading-circle", e.foldingCube = "folding-cube", e.pulse = "pulse", e.rectangleBounce = "rectangle-bounce", e.rectangleBounceParty = "rectangle-bounce-party", e.rectangleBouncePulseOut = "rectangle-bounce-pulse-out", e.rectangleBouncePulseOutRapid = "rectangle-bounce-pulse-out-rapid", e.rotatingPlane = "rotating-plane", e.squareJellyBox = "square-jelly-box", e.squareLoader = "square-loader", e.threeBounce = "three-bounce", e.threeStrings = "three-strings", e.wanderingCubes = "wandering-cubes" }(Us || (Us = {})), Us))(), Ht = (() => (function (e) { e.bottomCenter = "bottom-center", e.bottomLeft = "bottom-left", e.bottomRight = "bottom-right", e.centerCenter = "center-center", e.centerLeft = "center-left", e.centerRight = "center-right", e.topCenter = "top-center", e.topLeft = "top-left", e.topRight = "top-right" }(Ht || (Ht = {})), Ht))(), wu = (() => (function (e) { e.leftToRight = "ltr", e.rightToLeft = "rtl" }(wu || (wu = {})), wu))(); const bu = "fg-default", Du = "bg-default", HL = {}, gi = !1, Vs = !0, Eu = { "ball-scale-multiple": { divs: 3, class: "sk-ball-scale-multiple" }, "ball-spin": { divs: 8, class: "sk-ball-spin" }, "ball-spin-clockwise": { divs: 8, class: "sk-ball-spin-clockwise" }, "ball-spin-clockwise-fade-rotating": { divs: 8, class: "sk-ball-spin-clockwise-fade-rotating" }, "ball-spin-fade-rotating": { divs: 8, class: "sk-ball-spin-fade-rotating" }, "chasing-dots": { divs: 2, class: "sk-chasing-dots" }, circle: { divs: 12, class: "sk-circle" }, "cube-grid": { divs: 9, class: "sk-cube-grid" }, "double-bounce": { divs: 2, class: "sk-double-bounce" }, "fading-circle": { divs: 12, class: "sk-fading-circle" }, "folding-cube": { divs: 4, class: "sk-folding-cube" }, pulse: { divs: 1, class: "sk-pulse" }, "rectangle-bounce": { divs: 5, class: "sk-rectangle-bounce" }, "rectangle-bounce-party": { divs: 5, class: "sk-rectangle-bounce-party" }, "rectangle-bounce-pulse-out": { divs: 5, class: "sk-rectangle-bounce-pulse-out" }, "rectangle-bounce-pulse-out-rapid": { divs: 5, class: "sk-rectangle-bounce-pulse-out-rapid" }, "rotating-plane": { divs: 1, class: "sk-rotating-plane" }, "square-jelly-box": { divs: 2, class: "sk-square-jelly-box" }, "square-loader": { divs: 1, class: "sk-square-loader" }, "three-bounce": { divs: 3, class: "sk-three-bounce" }, "three-strings": { divs: 3, class: "sk-three-strings" }, "wandering-cubes": { divs: 2, class: "sk-wandering-cubes" } }, WL = { bgsColor: "#00ACC1", bgsOpacity: .5, bgsPosition: Ht.bottomRight, bgsSize: 60, bgsType: Us.ballSpinClockwise, blur: 5, delay: 0, fastFadeOut: !1, fgsColor: "#00ACC1", fgsPosition: Ht.centerCenter, fgsSize: 60, fgsType: Us.ballSpinClockwise, gap: 24, logoPosition: Ht.centerCenter, logoSize: 120, logoUrl: "", masterLoaderId: "master", overlayBorderRadius: "0", overlayColor: "rgba(40, 40, 40, 0.8)", pbColor: "#00ACC1", pbDirection: wu.leftToRight, pbThickness: 3, hasProgressBar: !0, text: "", textColor: "#FFFFFF", textPosition: Ht.centerCenter, maxTime: -1, minTime: 300 }, kb = new O("ngxUiLoaderCustom.config"); let Ab = (() => { class e { constructor(n) { this.config = n, this.defaultConfig = { ...WL }, this.config && (this.config.minTime && this.config.minTime < 0 && (this.config.minTime = 0), this.defaultConfig = { ...this.defaultConfig, ...this.config }), this.loaders = {}, this.showForeground = new ht({ loaderId: "", isShow: !1 }), this.showForeground$ = this.showForeground.asObservable(), this.showBackground = new ht({ loaderId: "", isShow: !1 }), this.showBackground$ = this.showBackground.asObservable(), this.fgClosing = new ht({ loaderId: "", isShow: !1 }), this.foregroundClosing$ = this.fgClosing.asObservable(), this.bgClosing = new ht({ loaderId: "", isShow: !1 }), this.backgroundClosing$ = this.bgClosing.asObservable() } bindLoaderData(n) { const r = n === this.defaultConfig.masterLoaderId; if (this.loaders[n]) { if (this.loaders[n].isBound) throw new Error(`[ngx-ui-loader] - loaderId "${n}" is duplicated.`); this.loaders[n].isBound = !0, this.loaders[n].isMaster = r, this.hasRunningTask(Vs, n) ? this.showForeground.next({ loaderId: n, isShow: !0 }) : this.hasRunningTask(gi, n) && this.showBackground.next({ loaderId: n, isShow: !0 }) } else this.createLoaderData(n, r, !0) } destroyLoaderData(n) { this.stopAllLoader(n), delete this.loaders[n] } getDefaultConfig() { return { ...this.defaultConfig } } getLoaders() { return JSON.parse(JSON.stringify(this.loaders)) } getLoader(n) { return this.loaders[n = n || this.defaultConfig.masterLoaderId] ? JSON.parse(JSON.stringify(this.loaders[n])) : null } startLoader(n, r = bu, o) { !this.readyToStart(n, r, !0, o) || this.loaders[n].tasks[r].isOtherRunning || (this.hasRunningTask(gi, n) && (this.backgroundCloseout(n), this.showBackground.next({ loaderId: n, isShow: !1 })), this.showForeground.next({ loaderId: n, isShow: !0 })) } start(n = bu, r) { this.startLoader(this.defaultConfig.masterLoaderId, n, r) } startBackgroundLoader(n, r = Du, o) { !this.readyToStart(n, r, !1, o) || !this.hasRunningTask(Vs, n) && !this.loaders[n].tasks[r].isOtherRunning && this.showBackground.next({ loaderId: n, isShow: !0 }) } startBackground(n = Du, r) { this.startBackgroundLoader(this.defaultConfig.masterLoaderId, n, r) } stopLoader(n, r = bu) { !this.readyToStop(n, r) || this.hasRunningTask(Vs, n) || (this.foregroundCloseout(n), this.showForeground.next({ loaderId: n, isShow: !1 }), this.hasRunningTask(gi, n) && setTimeout(() => { this.hasRunningTask(gi, n) && this.showBackground.next({ loaderId: n, isShow: !0 }) }, this.defaultConfig.fastFadeOut ? 300 : 500)) } stop(n = bu) { this.stopLoader(this.defaultConfig.masterLoaderId, n) } stopBackgroundLoader(n, r = Du) { !this.readyToStop(n, r) || !this.hasRunningTask(Vs, n) && !this.hasRunningTask(gi, n) && (this.backgroundCloseout(n), this.showBackground.next({ loaderId: n, isShow: !1 })) } stopBackground(n = Du) { this.stopBackgroundLoader(this.defaultConfig.masterLoaderId, n) } stopAllLoader(n) { this.loaders[n] ? (this.hasRunningTask(Vs, n) ? (this.foregroundCloseout(n), this.showForeground.next({ loaderId: n, isShow: !1 })) : this.hasRunningTask(gi, n) && (this.backgroundCloseout(n), this.showBackground.next({ loaderId: n, isShow: !1 })), this.clearAllTimers(this.loaders[n].tasks), this.loaders[n].tasks = {}) : console.warn(`[ngx-ui-loader] - loaderId "${n}" does not exist.`) } stopAll() { this.stopAllLoader(this.defaultConfig.masterLoaderId) } hasRunningTask(n, r, o) { if (this.loaders[r]) { const i = this.loaders[r].tasks; return o ? !!i[o] && !!i[o].startAt : Object.keys(i).some(s => !!i[s].startAt && i[s].isForeground === n) } return !1 } createLoaderData(n, r, o) { this.loaders[n] || (this.loaders[n] = { loaderId: n, tasks: {}, isMaster: r, isBound: o }) } foregroundCloseout(n) { this.fgClosing.next({ loaderId: n, isShow: !0 }), setTimeout(() => { this.fgClosing.next({ loaderId: n, isShow: !1 }) }, this.defaultConfig.fastFadeOut ? 601 : 1001) } backgroundCloseout(n) { this.bgClosing.next({ loaderId: n, isShow: !0 }), setTimeout(() => { this.bgClosing.next({ loaderId: n, isShow: !1 }) }, this.defaultConfig.fastFadeOut ? 601 : 1001) } clearTimers(n) { clearTimeout(n.delayTimer), clearTimeout(n.maxTimer), clearTimeout(n.minTimer) } clearAllTimers(n) { Object.keys(n).map(r => { this.clearTimers(n[r]) }) } readyToStart(n, r, o, i = HL) { this.createLoaderData(n, void 0, !1); const s = this.hasRunningTask(o, n); if (this.loaders[n].tasks[r]) { if (this.loaders[n].tasks[r].isForeground !== o) throw new Error(`[ngx-ui-loader] - taskId "${r}" is duplicated.`) } else this.loaders[n].tasks[r] = { taskId: r, isForeground: o, minTime: i.minTime >= 0 ? i.minTime : this.defaultConfig.minTime, maxTime: i.maxTime ? i.maxTime : this.defaultConfig.maxTime, delay: i.delay >= 0 ? i.delay : this.defaultConfig.delay }; return !(this.setDelayTimer(this.loaders[n].tasks[r], n) || (this.loaders[n].tasks[r] = { ...this.loaders[n].tasks[r], isOtherRunning: s, startAt: Date.now() }, this.setMaxTimer(this.loaders[n].tasks[r], n), !this.loaders[n].isBound)) } readyToStop(n, r) { if (!this.loaders[n]) return console.warn(`[ngx-ui-loader] - loaderId "${n}" does not exist.`), !1; const o = this.loaders[n].tasks[r]; return !(!o || (o.isDelayed ? (this.clearTimers(o), delete this.loaders[n].tasks[r], 1) : this.setMinTimer(o, n) || (this.clearTimers(o), delete this.loaders[n].tasks[r], 0))) } setDelayTimer(n, r) { if (n.delay > 0) { if (n.isDelayed) return !0; if (!n.delayTimer) return n.isDelayed = !0, n.delayTimer = setTimeout(() => { n.isDelayed = !1, n.isForeground ? this.startLoader(r, n.taskId) : this.startBackgroundLoader(r, n.taskId) }, n.delay), !0 } return !1 } setMaxTimer(n, r) { n.maxTime > n.minTime && (clearTimeout(n.maxTimer), n.maxTimer = setTimeout(() => { n.isForeground ? this.stopLoader(r, n.taskId) : this.stopBackgroundLoader(r, n.taskId) }, n.maxTime)) } setMinTimer(n, r) { const o = Date.now(); return !!(n.startAt && n.startAt + n.minTime > o) && (n.minTimer = setTimeout(() => { n.isForeground ? this.stopLoader(r, n.taskId) : this.stopBackgroundLoader(r, n.taskId) }, n.startAt + n.minTime - o), !0) } } return e.\u0275fac = function (n) { return new (n || e)(E(kb, 8)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), GL = (() => { class e { constructor(n, r, o) { this.domSanitizer = n, this.changeDetectorRef = r, this.ngxService = o, this.initialized = !1, this.defaultConfig = this.ngxService.getDefaultConfig(), this.bgsColor = this.defaultConfig.bgsColor, this.bgsOpacity = this.defaultConfig.bgsOpacity, this.bgsPosition = this.defaultConfig.bgsPosition, this.bgsSize = this.defaultConfig.bgsSize, this.bgsType = this.defaultConfig.bgsType, this.fastFadeOut = this.defaultConfig.fastFadeOut, this.fgsColor = this.defaultConfig.fgsColor, this.fgsPosition = this.defaultConfig.fgsPosition, this.fgsSize = this.defaultConfig.fgsSize, this.fgsType = this.defaultConfig.fgsType, this.gap = this.defaultConfig.gap, this.loaderId = this.defaultConfig.masterLoaderId, this.logoPosition = this.defaultConfig.logoPosition, this.logoSize = this.defaultConfig.logoSize, this.logoUrl = this.defaultConfig.logoUrl, this.overlayBorderRadius = this.defaultConfig.overlayBorderRadius, this.overlayColor = this.defaultConfig.overlayColor, this.pbColor = this.defaultConfig.pbColor, this.pbDirection = this.defaultConfig.pbDirection, this.pbThickness = this.defaultConfig.pbThickness, this.hasProgressBar = this.defaultConfig.hasProgressBar, this.text = this.defaultConfig.text, this.textColor = this.defaultConfig.textColor, this.textPosition = this.defaultConfig.textPosition } ngOnInit() { this.initializeSpinners(), this.ngxService.bindLoaderData(this.loaderId), this.determinePositions(), this.trustedLogoUrl = this.domSanitizer.bypassSecurityTrustResourceUrl(this.logoUrl), this.showForegroundWatcher = this.ngxService.showForeground$.pipe(Ze(n => this.loaderId === n.loaderId)).subscribe(n => { this.showForeground = n.isShow, this.changeDetectorRef.markForCheck() }), this.showBackgroundWatcher = this.ngxService.showBackground$.pipe(Ze(n => this.loaderId === n.loaderId)).subscribe(n => { this.showBackground = n.isShow, this.changeDetectorRef.markForCheck() }), this.foregroundClosingWatcher = this.ngxService.foregroundClosing$.pipe(Ze(n => this.loaderId === n.loaderId)).subscribe(n => { this.foregroundClosing = n.isShow, this.changeDetectorRef.markForCheck() }), this.backgroundClosingWatcher = this.ngxService.backgroundClosing$.pipe(Ze(n => this.loaderId === n.loaderId)).subscribe(n => { this.backgroundClosing = n.isShow, this.changeDetectorRef.markForCheck() }), this.initialized = !0 } ngOnChanges(n) { if (!this.initialized) return; const i = n.logoUrl; (n.fgsType || n.bgsType) && this.initializeSpinners(), this.determinePositions(), i && (this.trustedLogoUrl = this.domSanitizer.bypassSecurityTrustResourceUrl(this.logoUrl)) } ngOnDestroy() { this.ngxService.destroyLoaderData(this.loaderId), this.showForegroundWatcher && this.showForegroundWatcher.unsubscribe(), this.showBackgroundWatcher && this.showBackgroundWatcher.unsubscribe(), this.foregroundClosingWatcher && this.foregroundClosingWatcher.unsubscribe(), this.backgroundClosingWatcher && this.backgroundClosingWatcher.unsubscribe() } initializeSpinners() { this.fgDivs = Array(Eu[this.fgsType].divs).fill(1), this.fgSpinnerClass = Eu[this.fgsType].class, this.bgDivs = Array(Eu[this.bgsType].divs).fill(1), this.bgSpinnerClass = Eu[this.bgsType].class } determinePositions() { this.logoTop = "initial", this.spinnerTop = "initial", this.textTop = "initial", this.logoPosition.startsWith("center") ? this.logoTop = "50%" : this.logoPosition.startsWith("top") && (this.logoTop = "30px"), this.fgsPosition.startsWith("center") ? this.spinnerTop = "50%" : this.fgsPosition.startsWith("top") && (this.spinnerTop = "30px"), this.textPosition.startsWith("center") ? this.textTop = "50%" : this.textPosition.startsWith("top") && (this.textTop = "30px"), this.fgsPosition === Ht.centerCenter ? this.logoUrl && this.logoPosition === Ht.centerCenter ? this.text && this.textPosition === Ht.centerCenter ? (this.logoTop = this.domSanitizer.bypassSecurityTrustStyle(`calc(50% - ${this.fgsSize / 2}px - 12px - ${this.gap}px)`), this.spinnerTop = this.domSanitizer.bypassSecurityTrustStyle(`calc(50% + ${this.logoSize / 2}px - 12px)`), this.textTop = this.domSanitizer.bypassSecurityTrustStyle(`calc(50% + ${this.logoSize / 2}px + ${this.gap}px + ${this.fgsSize / 2}px)`)) : (this.logoTop = this.domSanitizer.bypassSecurityTrustStyle(`calc(50% - ${this.fgsSize / 2}px - ${this.gap / 2}px)`), this.spinnerTop = this.domSanitizer.bypassSecurityTrustStyle(`calc(50% + ${this.logoSize / 2}px + ${this.gap / 2}px)`)) : this.text && this.textPosition === Ht.centerCenter && (this.spinnerTop = this.domSanitizer.bypassSecurityTrustStyle(`calc(50% - 12px - ${this.gap / 2}px)`), this.textTop = this.domSanitizer.bypassSecurityTrustStyle(`calc(50% + ${this.fgsSize / 2}px + ${this.gap / 2}px)`)) : this.logoUrl && this.logoPosition === Ht.centerCenter && this.text && this.textPosition === Ht.centerCenter && (this.logoTop = this.domSanitizer.bypassSecurityTrustStyle(`calc(50% - 12px - ${this.gap / 2}px)`), this.textTop = this.domSanitizer.bypassSecurityTrustStyle(`calc(50% + ${this.logoSize / 2}px + ${this.gap / 2}px)`)) } } return e.\u0275fac = function (n) { return new (n || e)(S(dw), S(sc), S(Ab)) }, e.\u0275cmp = ot({ type: e, selectors: [["ngx-ui-loader"]], inputs: { bgsColor: "bgsColor", bgsOpacity: "bgsOpacity", bgsPosition: "bgsPosition", bgsSize: "bgsSize", bgsTemplate: "bgsTemplate", bgsType: "bgsType", fgsColor: "fgsColor", fgsPosition: "fgsPosition", fgsSize: "fgsSize", fgsTemplate: "fgsTemplate", fgsType: "fgsType", gap: "gap", loaderId: "loaderId", logoPosition: "logoPosition", logoSize: "logoSize", logoUrl: "logoUrl", overlayBorderRadius: "overlayBorderRadius", overlayColor: "overlayColor", pbColor: "pbColor", pbDirection: "pbDirection", pbThickness: "pbThickness", hasProgressBar: "hasProgressBar", text: "text", textColor: "textColor", textPosition: "textPosition" }, features: [sr], decls: 14, vars: 50, consts: [["class", "ngx-progress-bar", 3, "ngx-position-absolute", "ngClass", "height", "color", "loading-foreground", "foreground-closing", "fast-closing", 4, "ngIf"], [1, "ngx-overlay"], ["class", "ngx-loading-logo", 3, "ngClass", "src", "width", "height", "top", 4, "ngIf"], [1, "ngx-foreground-spinner", 3, "ngClass"], [3, "class", 4, "ngIf", "ngIfElse"], ["foregroundTemplate", ""], [1, "ngx-loading-text", 3, "ngClass"], [1, "ngx-background-spinner", 3, "ngClass"], ["backgroundTemplate", ""], [1, "ngx-progress-bar", 3, "ngClass"], [1, "ngx-loading-logo", 3, "ngClass", "src"], [4, "ngFor", "ngForOf"], [4, "ngTemplateOutlet"]], template: function (n, r) { if (1 & n && (we(0, kL, 1, 13, "div", 0), ee(1, "div", 1), we(2, AL, 1, 8, "img", 2), ee(3, "div", 3), we(4, NL, 2, 3, "div", 4), we(5, LL, 1, 1, "ng-template", null, 5, nf), Q(), ee(7, "div", 6)(8, "span"), De(9), Q()()(), ee(10, "div", 7), we(11, $L, 2, 3, "div", 4), we(12, VL, 1, 1, "ng-template", null, 8, nf), Q()), 2 & n) { const o = Od(6), i = Od(13); J("ngIf", r.hasProgressBar), A(1), gr("background-color", r.overlayColor)("border-radius", r.overlayBorderRadius), Xi("ngx-position-absolute", r.loaderId !== r.defaultConfig.masterLoaderId)("loading-foreground", r.showForeground)("foreground-closing", r.foregroundClosing)("fast-closing", r.foregroundClosing && r.fastFadeOut), A(1), J("ngIf", r.logoUrl), A(1), gr("color", r.fgsColor)("width", r.fgsSize, "px")("height", r.fgsSize, "px")("top", r.spinnerTop), J("ngClass", r.fgsPosition), A(1), J("ngIf", !r.fgsTemplate)("ngIfElse", o), A(3), gr("top", r.textTop)("color", r.textColor), J("ngClass", r.textPosition), A(2), et(r.text), A(1), gr("width", r.bgsSize, "px")("height", r.bgsSize, "px")("color", r.bgsColor)("opacity", r.bgsOpacity), Xi("ngx-position-absolute", r.loaderId !== r.defaultConfig.masterLoaderId)("loading-background", r.showBackground)("background-closing", r.backgroundClosing)("fast-closing", r.backgroundClosing && r.fastFadeOut), J("ngClass", r.bgsPosition), A(1), J("ngIf", !r.bgsTemplate)("ngIfElse", i) } }, dependencies: [fs, OC, Yo, FC], styles: ['.ngx-progress-bar[_ngcontent-%COMP%]{position:fixed;top:0;left:0;width:100%;height:3px;z-index:99999!important;display:none;color:#00acc1;overflow:hidden}.ngx-progress-bar.loading-foreground[_ngcontent-%COMP%], .ngx-progress-bar.foreground-closing[_ngcontent-%COMP%]{display:block}.ngx-progress-bar.foreground-closing[_ngcontent-%COMP%]{opacity:0!important;transition:opacity .5s ease-out .5s}.ngx-progress-bar.fast-closing[_ngcontent-%COMP%]{transition:opacity .3s ease-out .3s!important}.ngx-progress-bar[_ngcontent-%COMP%]:before, .ngx-progress-bar[_ngcontent-%COMP%]:after{background-color:currentColor;content:"";display:block;width:100%;height:100%;position:absolute;top:0}.ngx-progress-bar-ltr[_ngcontent-%COMP%]:before{transform:translate3d(-100%,0,0)}.ngx-progress-bar-ltr[_ngcontent-%COMP%]:after{animation:progressBar-slide-ltr 12s ease-out 0s 1 normal;transform:translate3d(-5%,0,0)}.ngx-progress-bar-rtl[_ngcontent-%COMP%]:before{transform:translate3d(100%,0,0)}.ngx-progress-bar-rtl[_ngcontent-%COMP%]:after{animation:progressBar-slide-rtl 12s ease-out 0s 1 normal;transform:translate3d(5%,0,0)}.foreground-closing.ngx-progress-bar-ltr[_ngcontent-%COMP%]:before{animation:progressBar-slide-complete-ltr 1s ease-out 0s 1;transform:translateZ(0)}.fast-closing.ngx-progress-bar-ltr[_ngcontent-%COMP%]:before{animation:progressBar-slide-complete-ltr .6s ease-out 0s 1!important}.foreground-closing.ngx-progress-bar-rtl[_ngcontent-%COMP%]:before{animation:progressBar-slide-complete-rtl 1s ease-out 0s 1;transform:translateZ(0)}.fast-closing.ngx-progress-bar-rtl[_ngcontent-%COMP%]:before{animation:progressBar-slide-complete-rtl .6s ease-out 0s 1!important}@keyframes progressBar-slide-ltr{0%{transform:translate3d(-100%,0,0)}to{transform:translate3d(-5%,0,0)}}@keyframes progressBar-slide-rtl{0%{transform:translate3d(100%,0,0)}to{transform:translate3d(5%,0,0)}}@keyframes progressBar-slide-complete-ltr{0%{transform:translate3d(-75%,0,0)}50%{transform:translateZ(0)}}@keyframes progressBar-slide-complete-rtl{0%{transform:translate3d(75%,0,0)}50%{transform:translateZ(0)}}.ngx-overlay[_ngcontent-%COMP%]{position:fixed;top:0;left:0;width:100%;height:100%;z-index:99998!important;background-color:#282828cc;cursor:progress;display:none}.ngx-overlay.loading-foreground[_ngcontent-%COMP%], .ngx-overlay.foreground-closing[_ngcontent-%COMP%]{display:block}.ngx-overlay.foreground-closing[_ngcontent-%COMP%]{opacity:0!important;transition:opacity .5s ease-out .5s}.ngx-overlay.fast-closing[_ngcontent-%COMP%]{transition:opacity .3s ease-out .3s!important}.ngx-overlay[_ngcontent-%COMP%] > .ngx-foreground-spinner[_ngcontent-%COMP%]{position:fixed;width:60px;height:60px;margin:0;color:#00acc1}.ngx-overlay[_ngcontent-%COMP%] > .ngx-loading-logo[_ngcontent-%COMP%]{position:fixed;margin:0;width:120px;height:120px}.ngx-overlay[_ngcontent-%COMP%] > .ngx-loading-text[_ngcontent-%COMP%]{position:fixed;margin:0;font-family:sans-serif;font-weight:400;font-size:1.2em;color:#fff}.ngx-background-spinner[_ngcontent-%COMP%]{position:fixed;z-index:99997!important;width:60px;height:60px;margin:0;color:#00acc1;opacity:.6;display:none}.ngx-background-spinner.loading-background[_ngcontent-%COMP%], .ngx-background-spinner.background-closing[_ngcontent-%COMP%]{display:block}.ngx-background-spinner.background-closing[_ngcontent-%COMP%]{opacity:0!important;transition:opacity .7s ease-out}.ngx-background-spinner.fast-closing[_ngcontent-%COMP%]{transition:opacity .4s ease-out!important}.ngx-position-absolute[_ngcontent-%COMP%]{position:absolute!important}.ngx-position-absolute[_ngcontent-%COMP%] > .ngx-foreground-spinner[_ngcontent-%COMP%], .ngx-position-absolute[_ngcontent-%COMP%] > .ngx-loading-logo[_ngcontent-%COMP%], .ngx-position-absolute[_ngcontent-%COMP%] > .ngx-loading-text[_ngcontent-%COMP%]{position:absolute!important}.ngx-position-absolute.ngx-progress-bar[_ngcontent-%COMP%]{z-index:99996!important}.ngx-position-absolute.ngx-overlay[_ngcontent-%COMP%]{z-index:99995!important}.ngx-position-absolute.ngx-background-spinner[_ngcontent-%COMP%]{z-index:99994!important}.ngx-position-absolute[_ngcontent-%COMP%]   .sk-square-jelly-box[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(1){z-index:99994!important}.top-left[_ngcontent-%COMP%]{top:30px;left:30px}.top-center[_ngcontent-%COMP%]{top:30px;left:50%;transform:translate(-50%)}.top-right[_ngcontent-%COMP%]{top:30px;right:30px}.center-left[_ngcontent-%COMP%]{top:50%;left:30px;transform:translateY(-50%)}.center-center[_ngcontent-%COMP%]{top:50%;left:50%;transform:translate(-50%,-50%)}.center-right[_ngcontent-%COMP%]{top:50%;right:30px;transform:translateY(-50%)}.bottom-left[_ngcontent-%COMP%]{bottom:30px;left:30px}.bottom-center[_ngcontent-%COMP%]{bottom:30px;left:50%;transform:translate(-50%)}.bottom-right[_ngcontent-%COMP%]{bottom:30px;right:30px}.sk-ball-scale-multiple[_ngcontent-%COMP%], .sk-ball-scale-multiple[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{position:relative;box-sizing:border-box}.sk-ball-scale-multiple[_ngcontent-%COMP%]{width:100%;height:100%;font-size:0}.sk-ball-scale-multiple[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{display:inline-block;float:none;background-color:currentColor;border:0 solid currentColor}.sk-ball-scale-multiple[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%;border-radius:100%;opacity:0;animation:ball-scale-multiple 1s 0s linear infinite}.sk-ball-scale-multiple[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2){animation-delay:.2s}.sk-ball-scale-multiple[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(3){animation-delay:.4s}@keyframes ball-scale-multiple{0%{opacity:0;transform:scale(0)}5%{opacity:.75}to{opacity:0;transform:scale(1)}}.sk-ball-spin[_ngcontent-%COMP%], .sk-ball-spin[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{position:relative;box-sizing:border-box}.sk-ball-spin[_ngcontent-%COMP%]{width:100%;height:100%;font-size:0}.sk-ball-spin[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{display:inline-block;float:none;background-color:currentColor;border:0 solid currentColor}.sk-ball-spin[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;width:25%;height:25%;margin-top:-12.5%;margin-left:-12.5%;border-radius:100%;animation:ball-spin-clockwise 1s infinite ease-in-out}.sk-ball-spin[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(1){top:5%;left:50%;animation-delay:-1.125s}.sk-ball-spin[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2){top:18.1801948466%;left:81.8198051534%;animation-delay:-1.25s}.sk-ball-spin[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(3){top:50%;left:95%;animation-delay:-1.375s}.sk-ball-spin[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(4){top:81.8198051534%;left:81.8198051534%;animation-delay:-1.5s}.sk-ball-spin[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(5){top:94.9999999966%;left:50.0000000005%;animation-delay:-1.625s}.sk-ball-spin[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(6){top:81.8198046966%;left:18.1801949248%;animation-delay:-1.75s}.sk-ball-spin[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(7){top:49.9999750815%;left:5.0000051215%;animation-delay:-1.875s}.sk-ball-spin[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(8){top:18.179464974%;left:18.1803700518%;animation-delay:-2s}@keyframes ball-spin{0%,to{opacity:1;transform:scale(1)}20%{opacity:1}80%{opacity:0;transform:scale(0)}}.sk-ball-spin-clockwise[_ngcontent-%COMP%], .sk-ball-spin-clockwise[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{position:relative;box-sizing:border-box}.sk-ball-spin-clockwise[_ngcontent-%COMP%]{width:100%;height:100%;font-size:0}.sk-ball-spin-clockwise[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{display:inline-block;float:none;background-color:currentColor;border:0 solid currentColor}.sk-ball-spin-clockwise[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;width:25%;height:25%;margin-top:-12.5%;margin-left:-12.5%;border-radius:100%;animation:ball-spin-clockwise 1s infinite ease-in-out}.sk-ball-spin-clockwise[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(1){top:5%;left:50%;animation-delay:-.875s}.sk-ball-spin-clockwise[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2){top:18.1801948466%;left:81.8198051534%;animation-delay:-.75s}.sk-ball-spin-clockwise[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(3){top:50%;left:95%;animation-delay:-.625s}.sk-ball-spin-clockwise[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(4){top:81.8198051534%;left:81.8198051534%;animation-delay:-.5s}.sk-ball-spin-clockwise[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(5){top:94.9999999966%;left:50.0000000005%;animation-delay:-.375s}.sk-ball-spin-clockwise[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(6){top:81.8198046966%;left:18.1801949248%;animation-delay:-.25s}.sk-ball-spin-clockwise[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(7){top:49.9999750815%;left:5.0000051215%;animation-delay:-.125s}.sk-ball-spin-clockwise[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(8){top:18.179464974%;left:18.1803700518%;animation-delay:0s}@keyframes ball-spin-clockwise{0%,to{opacity:1;transform:scale(1)}20%{opacity:1}80%{opacity:0;transform:scale(0)}}.sk-ball-spin-clockwise-fade-rotating[_ngcontent-%COMP%], .sk-ball-spin-clockwise-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{position:relative;box-sizing:border-box}.sk-ball-spin-clockwise-fade-rotating[_ngcontent-%COMP%]{font-size:0;width:100%;height:100%;animation:ball-spin-clockwise-fade-rotating-rotate 6s infinite linear}.sk-ball-spin-clockwise-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{display:inline-block;float:none;background-color:currentColor;border:0 solid currentColor}.sk-ball-spin-clockwise-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;width:25%;height:25%;margin-top:-12.5%;margin-left:-12.5%;border-radius:100%;animation:ball-spin-clockwise-fade-rotating 1s infinite linear}.sk-ball-spin-clockwise-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(1){top:5%;left:50%;animation-delay:-.875s}.sk-ball-spin-clockwise-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2){top:18.1801948466%;left:81.8198051534%;animation-delay:-.75s}.sk-ball-spin-clockwise-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(3){top:50%;left:95%;animation-delay:-.625s}.sk-ball-spin-clockwise-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(4){top:81.8198051534%;left:81.8198051534%;animation-delay:-.5s}.sk-ball-spin-clockwise-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(5){top:94.9999999966%;left:50.0000000005%;animation-delay:-.375s}.sk-ball-spin-clockwise-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(6){top:81.8198046966%;left:18.1801949248%;animation-delay:-.25s}.sk-ball-spin-clockwise-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(7){top:49.9999750815%;left:5.0000051215%;animation-delay:-.125s}.sk-ball-spin-clockwise-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(8){top:18.179464974%;left:18.1803700518%;animation-delay:0s}@keyframes ball-spin-clockwise-fade-rotating-rotate{to{transform:rotate(-360deg)}}@keyframes ball-spin-clockwise-fade-rotating{50%{opacity:.25;transform:scale(.5)}to{opacity:1;transform:scale(1)}}.sk-ball-spin-fade-rotating[_ngcontent-%COMP%], .sk-ball-spin-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{position:relative;box-sizing:border-box}.sk-ball-spin-fade-rotating[_ngcontent-%COMP%]{width:100%;height:100%;font-size:0;animation:ball-spin-fade-rotate 6s infinite linear}.sk-ball-spin-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{display:inline-block;float:none;background-color:currentColor;border:0 solid currentColor}.sk-ball-spin-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;width:25%;height:25%;margin-top:-12.5%;margin-left:-12.5%;border-radius:100%;animation:ball-spin-fade 1s infinite linear}.sk-ball-spin-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(1){top:5%;left:50%;animation-delay:-1.125s}.sk-ball-spin-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2){top:18.1801948466%;left:81.8198051534%;animation-delay:-1.25s}.sk-ball-spin-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(3){top:50%;left:95%;animation-delay:-1.375s}.sk-ball-spin-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(4){top:81.8198051534%;left:81.8198051534%;animation-delay:-1.5s}.sk-ball-spin-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(5){top:94.9999999966%;left:50.0000000005%;animation-delay:-1.625s}.sk-ball-spin-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(6){top:81.8198046966%;left:18.1801949248%;animation-delay:-1.75s}.sk-ball-spin-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(7){top:49.9999750815%;left:5.0000051215%;animation-delay:-1.875s}.sk-ball-spin-fade-rotating[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(8){top:18.179464974%;left:18.1803700518%;animation-delay:-2s}@keyframes ball-spin-fade-rotate{to{transform:rotate(360deg)}}@keyframes ball-spin-fade{0%,to{opacity:1;transform:scale(1)}50%{opacity:.25;transform:scale(.5)}}.sk-chasing-dots[_ngcontent-%COMP%]{margin:auto;width:100%;height:100%;position:absolute;text-align:center;animation:sk-chasingDots-rotate 2s infinite linear}.sk-chasing-dots[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{width:60%;height:60%;display:inline-block;position:absolute;top:0;background-color:currentColor;border-radius:100%;animation:sk-chasingDots-bounce 2s infinite ease-in-out}.sk-chasing-dots[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2){top:auto;bottom:0;animation-delay:-1s}@keyframes sk-chasingDots-rotate{to{transform:rotate(360deg)}}@keyframes sk-chasingDots-bounce{0%,to{transform:scale(0)}50%{transform:scale(1)}}.sk-circle[_ngcontent-%COMP%]{margin:auto;width:100%;height:100%;position:relative}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{width:100%;height:100%;position:absolute;left:0;top:0}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:before{content:"";display:block;margin:0 auto;width:15%;height:15%;background-color:currentColor;border-radius:100%;animation:sk-circle-bounceDelay 1.2s infinite ease-in-out both}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2){transform:rotate(30deg)}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(3){transform:rotate(60deg)}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(4){transform:rotate(90deg)}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(5){transform:rotate(120deg)}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(6){transform:rotate(150deg)}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(7){transform:rotate(180deg)}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(8){transform:rotate(210deg)}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(9){transform:rotate(240deg)}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(10){transform:rotate(270deg)}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(11){transform:rotate(300deg)}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(12){transform:rotate(330deg)}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2):before{animation-delay:-1.1s}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(3):before{animation-delay:-1s}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(4):before{animation-delay:-.9s}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(5):before{animation-delay:-.8s}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(6):before{animation-delay:-.7s}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(7):before{animation-delay:-.6s}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(8):before{animation-delay:-.5s}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(9):before{animation-delay:-.4s}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(10):before{animation-delay:-.3s}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(11):before{animation-delay:-.2s}.sk-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(12):before{animation-delay:-.1s}@keyframes sk-circle-bounceDelay{0%,80%,to{transform:scale(0)}40%{transform:scale(1)}}.sk-cube-grid[_ngcontent-%COMP%]{width:100%;height:100%;margin:auto}.sk-cube-grid[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{width:33%;height:33%;background-color:currentColor;float:left;animation:sk-cubeGrid-scaleDelay 1.3s infinite ease-in-out}.sk-cube-grid[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(1){animation-delay:.2s}.sk-cube-grid[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2){animation-delay:.3s}.sk-cube-grid[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(3){animation-delay:.4s}.sk-cube-grid[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(4){animation-delay:.1s}.sk-cube-grid[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(5){animation-delay:.2s}.sk-cube-grid[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(6){animation-delay:.3s}.sk-cube-grid[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(7){animation-delay:0s}.sk-cube-grid[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(8){animation-delay:.1s}.sk-cube-grid[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(9){animation-delay:.2s}@keyframes sk-cubeGrid-scaleDelay{0%,70%,to{transform:scaleZ(1)}35%{transform:scale3D(0,0,1)}}.sk-double-bounce[_ngcontent-%COMP%]{width:100%;height:100%;position:relative;margin:auto}.sk-double-bounce[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{width:100%;height:100%;border-radius:50%;background-color:currentColor;opacity:.6;position:absolute;top:0;left:0;animation:sk-doubleBounce-bounce 2s infinite ease-in-out}.sk-double-bounce[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2){animation-delay:-1s}@keyframes sk-doubleBounce-bounce{0%,to{transform:scale(0)}50%{transform:scale(1)}}.sk-fading-circle[_ngcontent-%COMP%]{margin:auto;width:100%;height:100%;position:relative}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{width:100%;height:100%;position:absolute;left:0;top:0}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:before{content:"";display:block;margin:0 auto;width:15%;height:15%;background-color:currentColor;border-radius:100%;animation:sk-fadingCircle-FadeDelay 1.2s infinite ease-in-out both}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2){transform:rotate(30deg)}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(3){transform:rotate(60deg)}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(4){transform:rotate(90deg)}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(5){transform:rotate(120deg)}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(6){transform:rotate(150deg)}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(7){transform:rotate(180deg)}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(8){transform:rotate(210deg)}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(9){transform:rotate(240deg)}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(10){transform:rotate(270deg)}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(11){transform:rotate(300deg)}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(12){transform:rotate(330deg)}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2):before{animation-delay:-1.1s}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(3):before{animation-delay:-1s}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(4):before{animation-delay:-.9s}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(5):before{animation-delay:-.8s}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(6):before{animation-delay:-.7s}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(7):before{animation-delay:-.6s}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(8):before{animation-delay:-.5s}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(9):before{animation-delay:-.4s}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(10):before{animation-delay:-.3s}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(11):before{animation-delay:-.2s}.sk-fading-circle[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(12):before{animation-delay:-.1s}@keyframes sk-fadingCircle-FadeDelay{0%,39%,to{opacity:0}40%{opacity:1}}.sk-folding-cube[_ngcontent-%COMP%]{margin:auto;width:100%;height:100%;position:relative;transform:rotate(45deg)}.sk-folding-cube[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{float:left;width:50%;height:50%;position:relative;transform:scale(1.1)}.sk-folding-cube[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;background-color:currentColor;animation:sk-foldingCube-angle 2.4s infinite linear both;transform-origin:100% 100%}.sk-folding-cube[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2){transform:scale(1.1) rotate(90deg)}.sk-folding-cube[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(3){transform:scale(1.1) rotate(270deg)}.sk-folding-cube[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(4){transform:scale(1.1) rotate(180deg)}.sk-folding-cube[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2):before{animation-delay:.3s}.sk-folding-cube[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(3):before{animation-delay:.9s}.sk-folding-cube[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(4):before{animation-delay:.6s}@keyframes sk-foldingCube-angle{0%,10%{transform:perspective(140px) rotateX(-180deg);opacity:0}25%,75%{transform:perspective(140px) rotateX(0);opacity:1}90%,to{transform:perspective(140px) rotateY(180deg);opacity:0}}.sk-pulse[_ngcontent-%COMP%]{width:100%;height:100%;margin:auto}.sk-pulse[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{width:100%;height:100%;background-color:currentColor;border-radius:100%;animation:sk-pulse-scaleOut 1s infinite ease-in-out}@keyframes sk-pulse-scaleOut{0%{transform:scale(0)}to{transform:scale(1);opacity:0}}.sk-rectangle-bounce[_ngcontent-%COMP%]{margin:auto;width:100%;height:100%;text-align:center;font-size:0}.sk-rectangle-bounce[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{background-color:currentColor;height:100%;width:10%;margin:0 5%;display:inline-block;animation:sk-rectangleBounce-stretchDelay 1.2s infinite ease-in-out}.sk-rectangle-bounce[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2){animation-delay:-1.1s}.sk-rectangle-bounce[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(3){animation-delay:-1s}.sk-rectangle-bounce[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(4){animation-delay:-.9s}.sk-rectangle-bounce[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(5){animation-delay:-.8s}@keyframes sk-rectangleBounce-stretchDelay{0%,40%,to{transform:scaleY(.4)}20%{transform:scaleY(1)}}.sk-rectangle-bounce-party[_ngcontent-%COMP%], .sk-rectangle-bounce-party[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{position:relative;box-sizing:border-box}.sk-rectangle-bounce-party[_ngcontent-%COMP%]{margin:auto;width:100%;height:100%;text-align:center;font-size:0}.sk-rectangle-bounce-party[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{display:inline-block;float:none;background-color:currentColor;border:0 solid currentColor}.sk-rectangle-bounce-party[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{width:10%;height:100%;margin:0 5%;border-radius:0;animation-name:rectangle-bounce-party;animation-iteration-count:infinite}.sk-rectangle-bounce-party[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(1){animation-duration:.43s;animation-delay:-.23s}.sk-rectangle-bounce-party[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2){animation-duration:.62s;animation-delay:-.32s}.sk-rectangle-bounce-party[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(3){animation-duration:.43s;animation-delay:-.44s}.sk-rectangle-bounce-party[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(4){animation-duration:.8s;animation-delay:-.31s}.sk-rectangle-bounce-party[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(5){animation-duration:.74s;animation-delay:-.24s}@keyframes rectangle-bounce-party{0%{transform:scaleY(1)}50%{transform:scaleY(.4)}to{transform:scaleY(1)}}.sk-rectangle-bounce-pulse-out[_ngcontent-%COMP%], .sk-rectangle-bounce-pulse-out[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{position:relative;box-sizing:border-box}.sk-rectangle-bounce-pulse-out[_ngcontent-%COMP%]{margin:auto;width:100%;height:100%;text-align:center;font-size:0}.sk-rectangle-bounce-pulse-out[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{display:inline-block;float:none;background-color:currentColor;border:0 solid currentColor}.sk-rectangle-bounce-pulse-out[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{width:10%;height:100%;margin:0 5%;border-radius:0;animation:rectangle-bounce-pulse-out .9s infinite cubic-bezier(.85,.25,.37,.85)}.sk-rectangle-bounce-pulse-out[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(3){animation-delay:-.9s}.sk-rectangle-bounce-pulse-out[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2), .sk-rectangle-bounce-pulse-out[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(4){animation-delay:-.7s}.sk-rectangle-bounce-pulse-out[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(1), .sk-rectangle-bounce-pulse-out[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(5){animation-delay:-.5s}@keyframes rectangle-bounce-pulse-out{0%{transform:scaley(1)}50%{transform:scaley(.4)}to{transform:scaley(1)}}.sk-rectangle-bounce-pulse-out-rapid[_ngcontent-%COMP%], .sk-rectangle-bounce-pulse-out-rapid[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{position:relative;box-sizing:border-box}.sk-rectangle-bounce-pulse-out-rapid[_ngcontent-%COMP%]{margin:auto;width:100%;height:100%;text-align:center;font-size:0}.sk-rectangle-bounce-pulse-out-rapid[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{display:inline-block;float:none;background-color:currentColor;border:0 solid currentColor}.sk-rectangle-bounce-pulse-out-rapid[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{width:10%;height:100%;margin:0 5%;border-radius:0;animation:rectangle-bounce-pulse-out-rapid .9s infinite cubic-bezier(.11,.49,.38,.78)}.sk-rectangle-bounce-pulse-out-rapid[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(3){animation-delay:-.9s}.sk-rectangle-bounce-pulse-out-rapid[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2), .sk-rectangle-bounce-pulse-out-rapid[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(4){animation-delay:-.65s}.sk-rectangle-bounce-pulse-out-rapid[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(1), .sk-rectangle-bounce-pulse-out-rapid[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(5){animation-delay:-.4s}@keyframes rectangle-bounce-pulse-out-rapid{0%{transform:scaley(1)}80%{transform:scaley(.4)}90%{transform:scaley(1)}}.sk-rotating-plane[_ngcontent-%COMP%]{width:100%;height:100%;text-align:center;margin:auto}.sk-rotating-plane[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{width:100%;height:100%;background-color:currentColor;animation:sk-rotatePlane 1.2s infinite ease-in-out}@keyframes sk-rotatePlane{0%{transform:perspective(120px) rotateX(0) rotateY(0)}50%{transform:perspective(120px) rotateX(-180.1deg) rotateY(0)}to{transform:perspective(120px) rotateX(-180deg) rotateY(-179.9deg)}}.sk-square-jelly-box[_ngcontent-%COMP%], .sk-square-jelly-box[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{position:relative;box-sizing:border-box}.sk-square-jelly-box[_ngcontent-%COMP%]{width:100%;height:100%;font-size:0}.sk-square-jelly-box[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{display:inline-block;float:none;background-color:currentColor;border:0 solid currentColor}.sk-square-jelly-box[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(1), .sk-square-jelly-box[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2){position:absolute;left:0;width:100%}.sk-square-jelly-box[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(1){top:-25%;z-index:99997;height:100%;border-radius:10%;animation:square-jelly-box-animate .6s -.1s linear infinite}.sk-square-jelly-box[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2){bottom:-9%;height:10%;background:#000;border-radius:50%;opacity:.2;animation:square-jelly-box-shadow .6s -.1s linear infinite}@keyframes square-jelly-box-animate{17%{border-bottom-right-radius:10%}25%{transform:translateY(25%) rotate(22.5deg)}50%{border-bottom-right-radius:100%;transform:translateY(50%) scaleY(.9) rotate(45deg)}75%{transform:translateY(25%) rotate(67.5deg)}to{transform:translateY(0) rotate(90deg)}}@keyframes square-jelly-box-shadow{50%{transform:scaleX(1.25)}}.sk-square-loader[_ngcontent-%COMP%], .sk-square-loader[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{position:relative;box-sizing:border-box}.sk-square-loader[_ngcontent-%COMP%]{font-size:0;width:100%;height:100%}.sk-square-loader[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{display:inline-block;float:none;background-color:currentColor;border:0 solid currentColor}.sk-square-loader[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{width:100%;height:100%;background:transparent;border-width:3px;border-radius:0;animation:square-loader 2s infinite ease}.sk-square-loader[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:after{display:inline-block;width:100%;vertical-align:top;content:"";background-color:currentColor;animation:square-loader-inner 2s infinite ease-in}@keyframes square-loader{0%{transform:rotate(0)}25%{transform:rotate(180deg)}50%{transform:rotate(180deg)}75%{transform:rotate(360deg)}to{transform:rotate(360deg)}}@keyframes square-loader-inner{0%{height:0}25%{height:0}50%{height:100%}75%{height:100%}to{height:0}}.sk-three-bounce[_ngcontent-%COMP%]{margin:auto;width:100%;height:100%;text-align:center}.sk-three-bounce[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{margin-top:35%;width:30%;height:30%;background-color:currentColor;border-radius:100%;display:inline-block;animation:sk-threeBounce-bounceDelay 1.4s infinite ease-in-out both}.bottom-center[_ngcontent-%COMP%] > .sk-three-bounce[_ngcontent-%COMP%] > div[_ngcontent-%COMP%], .bottom-left[_ngcontent-%COMP%] > .sk-three-bounce[_ngcontent-%COMP%] > div[_ngcontent-%COMP%], .bottom-right[_ngcontent-%COMP%] > .sk-three-bounce[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{margin-top:70%!important}.top-center[_ngcontent-%COMP%] > .sk-three-bounce[_ngcontent-%COMP%] > div[_ngcontent-%COMP%], .top-left[_ngcontent-%COMP%] > .sk-three-bounce[_ngcontent-%COMP%] > div[_ngcontent-%COMP%], .top-right[_ngcontent-%COMP%] > .sk-three-bounce[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{margin-top:0!important}.sk-three-bounce[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(1){animation-delay:-.32s}.sk-three-bounce[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2){animation-delay:-.16s}@keyframes sk-threeBounce-bounceDelay{0%,80%,to{transform:scale(0)}40%{transform:scale(1)}}.sk-three-strings[_ngcontent-%COMP%]{width:100%;height:100%}.sk-three-strings[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{position:absolute;box-sizing:border-box;width:100%;height:100%;border-radius:50%}.sk-three-strings[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(1){left:0%;top:0%;animation:sk-threeStrings-rotateOne 1s linear infinite;border-bottom:3px solid currentColor}.sk-three-strings[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2){right:0%;top:0%;animation:sk-threeStrings-rotateTwo 1s linear infinite;border-right:3px solid currentColor}.sk-three-strings[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(3){right:0%;bottom:0%;animation:sk-threeStrings-rotateThree 1s linear infinite;border-top:3px solid currentColor}@keyframes sk-threeStrings-rotateOne{0%{transform:rotateX(35deg) rotateY(-45deg) rotate(0)}to{transform:rotateX(35deg) rotateY(-45deg) rotate(360deg)}}@keyframes sk-threeStrings-rotateTwo{0%{transform:rotateX(50deg) rotateY(10deg) rotate(0)}to{transform:rotateX(50deg) rotateY(10deg) rotate(360deg)}}@keyframes sk-threeStrings-rotateThree{0%{transform:rotateX(35deg) rotateY(55deg) rotate(0)}to{transform:rotateX(35deg) rotateY(55deg) rotate(360deg)}}.sk-wandering-cubes[_ngcontent-%COMP%]{margin:auto;width:100%;height:100%;position:relative;text-align:center}.sk-wandering-cubes[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{background-color:currentColor;width:25%;height:25%;position:absolute;top:0;left:0;animation:sk-wanderingCubes-cubeMove 1.8s infinite ease-in-out}.sk-wandering-cubes[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:nth-child(2){animation-delay:-.9s}@keyframes sk-wanderingCubes-cubeMove{25%{transform:translate(290%) rotate(-90deg) scale(.5)}50%{transform:translate(290%) translateY(290%) rotate(-179deg)}50.1%{transform:translate(290%) translateY(290%) rotate(-180deg)}75%{transform:translate(0) translateY(290%) rotate(-270deg) scale(.5)}to{transform:rotate(-360deg)}}'], changeDetection: 0 }), e })(), ZL = (() => { class e { static forRoot(n) { return { ngModule: e, providers: [{ provide: kb, useValue: n }] } } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = $n({ type: e }), e.\u0275inj = _n({ imports: [[$C]] }), e })(); new O("ngxUiLoaderRouterCustom.config"), new O("ngxUiLoaderHttpCustom.config"); let KL = (() => { class e { constructor(n, r) { this.sanityService = n, this.localeService = r, this.selectedLocale = r.getLocale() } mainNavigation() { return this.sanityService.getClient().option.fetch(`*[_type == "siteConfig"]{\n      mainNav->{ \n        _id,\n        title{\n          "text":${this.selectedLocale.name}\n        },\n        items[]{\n          internalHref,\n          text{\n            "text":${this.selectedLocale.name}\n          },\n          navigationItemUrl\n        }\n      }\n}[0]`) } } return e.\u0275fac = function (n) { return new (n || e)(E(Ib), E(Tb)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function YL(e, t) { if (1 & e) { const n = function Py() { return C() }(); ee(0, "li")(1, "a", 11), pr("click", function () { const i = function Bp(e) { return L.lFrame.contextLView = e, e[8] }(n).$implicit; return function Hp(e) { return L.lFrame.contextLView = null, e }(ft(2).scrollTo(i.internalHref)) }), De(2), Q()() } if (2 & e) { const n = t.$implicit; A(2), et(n.text.text) } } function QL(e, t) { if (1 & e && (ee(0, "nav", 1)(1, "div", 2)(2, "div", 3)(3, "button", 4)(4, "span", 5), De(5, "Toggle navigation"), Q(), me(6, "span", 6)(7, "span", 6)(8, "span", 6), Q(), ee(9, "a", 7), De(10), Q()(), ee(11, "div", 8)(12, "ul", 9), we(13, YL, 3, 1, "li", 10), Q()()()()), 2 & e) { const n = ft(); A(10), et(n.nav.title.text), A(3), J("ngForOf", n.nav.items) } } let XL = (() => { class e { constructor(n, r) { this.viewportScroller = n, this.navigationService = r } ngOnInit() { this.navigationService.mainNavigation().then(n => { this.nav = n.mainNav, this.isLoaded = !0 }).catch(n => { console.log("API ERROR"), console.log(n) }) } scrollTo(n) { this.viewportScroller.scrollToAnchor(n) } onWindowScroll() { let n = document.getElementById("mainNav"); window.pageYOffset > 100 ? (n.classList.remove("affix-top"), n.classList.add("affix")) : (n.classList.remove("affix"), n.classList.add("affix-top")) } } return e.\u0275fac = function (n) { return new (n || e)(S(VC), S(KL)) }, e.\u0275cmp = ot({ type: e, selectors: [["app-nav"]], hostBindings: function (n, r) { 1 & n && pr("scroll", function (i) { return r.onWindowScroll(i) }, 0, Sm) }, decls: 1, vars: 1, consts: [["id", "mainNav", "class", "navbar navbar-default navbar-fixed-top", 4, "ngIf"], ["id", "mainNav", 1, "navbar", "navbar-default", "navbar-fixed-top"], [1, "container-fluid"], [1, "navbar-header"], ["type", "button", "data-toggle", "collapse", "data-target", "#bs-example-navbar-collapse-1", 1, "navbar-toggle", "collapsed"], [1, "sr-only"], [1, "icon-bar"], ["href", "/", 1, "navbar-brand", "page-scroll"], ["id", "bs-example-navbar-collapse-1", 1, "collapse", "navbar-collapse"], [1, "nav", "navbar-nav", "navbar-right"], [4, "ngFor", "ngForOf"], [1, "page-scroll", 3, "click"]], template: function (n, r) { 1 & n && we(0, QL, 14, 2, "nav", 0), 2 & n && J("ngIf", r.isLoaded) }, dependencies: [Yo, fs], encapsulation: 2 }), e })(), JL = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = ot({ type: e, selectors: [["app-header"]], inputs: { header: "header" }, decls: 10, vars: 7, consts: [[1, "header-content"], [1, "header-content-inner"], [1, "btn", "btn-primary", "btn-xl", "page-scroll", 3, "href"]], template: function (n, r) { 1 & n && (ee(0, "header")(1, "div", 0)(2, "div", 1)(3, "h1"), De(4), Q(), me(5, "hr"), ee(6, "p"), De(7), Q(), ee(8, "a", 2), De(9), Q()()()()), 2 & n && (hv("background-image: url('", r.header.mainImage.asset.url, "');"), A(4), et(r.header.title.text), A(3), et(r.header.text.text), A(1), Bo("href", "#", r.header.buttonHREF, "", zn), A(1), et(r.header.buttonText.text)) }, encapsulation: 2 }), e })(), e2 = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = ot({ type: e, selectors: [["app-call-to-action"]], inputs: { cta: "cta" }, decls: 11, vars: 5, consts: [[1, "bg-primary", 3, "id"], [1, "container"], [1, "row"], [1, "col-lg-8", "col-lg-offset-2", "text-center"], [1, "section-heading"], [1, "light"], [1, "text-faded"], [1, "btn", "btn-default", "btn-xl", 3, "href"]], template: function (n, r) { 1 & n && (ee(0, "section", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "h2", 4), De(5), Q(), me(6, "hr", 5), ee(7, "p", 6), De(8), Q(), ee(9, "a", 7), De(10), Q()()()()()), 2 & n && (Zn("id", r.cta.key), A(5), et(r.cta.title.text), A(3), et(r.cta.text.text), A(1), Bo("href", "#", r.cta.buttonHREF, "", zn), A(1), et(r.cta.buttonText.text)) }, encapsulation: 2 }), e })(); function t2(e, t) { if (1 & e && (ee(0, "div", 7)(1, "div", 8), me(2, "i"), ee(3, "h3"), De(4), Q(), ee(5, "p", 9), De(6), Q()()()), 2 & e) { const n = t.$implicit; A(2), Wa("fa fa-4x ", n.icon, " wow bounceIn text-primary"), A(2), et(n.title.text), A(2), et(n.text.text) } } let n2 = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = ot({ type: e, selectors: [["app-services"]], inputs: { services: "services" }, decls: 10, vars: 3, consts: [[3, "id"], [1, "container"], [1, "row"], [1, "col-lg-12", "text-center"], [1, "section-heading"], [1, "primary"], ["class", "col-lg-3 col-md-6 text-center", 4, "ngFor", "ngForOf"], [1, "col-lg-3", "col-md-6", "text-center"], [1, "service-box"], [1, "text-muted"]], template: function (n, r) { 1 & n && (ee(0, "section", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "h2", 4), De(5), Q(), me(6, "hr", 5), Q()()(), ee(7, "div", 1)(8, "div", 2), we(9, t2, 7, 5, "div", 6), Q()()()), 2 & n && (Zn("id", r.services.key), A(5), et(r.services.title.text), A(4), J("ngForOf", r.services.boxItems)) }, dependencies: [Yo], encapsulation: 2 }), e })(); function r2(e, t) { if (1 & e && (ee(0, "div", 4)(1, "a", 5)(2, "div", 6)(3, "div", 7)(4, "div", 8), De(5), Q(), ee(6, "div", 9), De(7), Q()()(), me(8, "img", 10), Q()()), 2 & e) { const n = t.$implicit; A(1), Bo("href", "# ", n.link, "", zn), A(4), zo(" ", n.title.text, " "), A(2), zo(" ", n.text.text, " "), A(1), Zn("src", n.image.asset.url, zn) } } let o2 = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = ot({ type: e, selectors: [["app-portfolio"]], inputs: { portfolio: "portfolio" }, decls: 4, vars: 2, consts: [[1, "no-padding", 3, "id"], [1, "container-fluid"], [1, "row", "no-gutter"], ["class", "col-lg-4 col-sm-6", 4, "ngFor", "ngForOf"], [1, "col-lg-4", "col-sm-6"], [1, "portfolio-box", 3, "href"], [1, "portfolio-box-caption"], [1, "portfolio-box-caption-content"], [1, "project-category", "text-faded"], [1, "project-name"], ["alt", "", 1, "img-responsive", 3, "src"]], template: function (n, r) { 1 & n && (ee(0, "section", 0)(1, "div", 1)(2, "div", 2), we(3, r2, 9, 4, "div", 3), Q()()()), 2 & n && (Zn("id", r.portfolio.key), A(3), J("ngForOf", r.portfolio.boxItems)) }, dependencies: [Yo], encapsulation: 2 }), e })(); const Rb = { now: () => (Rb.delegate || Date).now(), delegate: void 0 }; class Mu extends Pt { constructor(t = 1 / 0, n = 1 / 0, r = Rb) { super(), this._bufferSize = t, this._windowTime = n, this._timestampProvider = r, this._buffer = [], this._infiniteTimeWindow = !0, this._infiniteTimeWindow = n === 1 / 0, this._bufferSize = Math.max(1, t), this._windowTime = Math.max(1, n) } next(t) { const { isStopped: n, _buffer: r, _infiniteTimeWindow: o, _timestampProvider: i, _windowTime: s } = this; n || (r.push(t), !o && r.push(i.now() + s)), this._trimBuffer(), super.next(t) } _subscribe(t) { this._throwIfClosed(), this._trimBuffer(); const n = this._innerSubscribe(t), { _infiniteTimeWindow: r, _buffer: o } = this, i = o.slice(); for (let s = 0; s < i.length && !t.closed; s += r ? 1 : 2)t.next(i[s]); return this._checkFinalizedStatuses(t), n } _trimBuffer() { const { _bufferSize: t, _timestampProvider: n, _buffer: r, _infiniteTimeWindow: o } = this, i = (o ? 1 : 2) * t; if (t < 1 / 0 && i < r.length && r.splice(0, r.length - i), !o) { const s = n.now(); let a = 0; for (let c = 1; c < r.length && r[c] <= s; c += 2)a = c; a && r.splice(0, a + 1) } } } function jh(e, t = Rn) { return e = e ?? s2, ke((n, r) => { let o, i = !0; n.subscribe(Se(r, s => { const a = t(s); (i || !e(o, a)) && (i = !1, o = a, r.next(s)) })) }) } function s2(e, t) { return e === t } function On(e, t) { var n = {}; for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]); if (null != e && "function" == typeof Object.getOwnPropertySymbols) { var o = 0; for (r = Object.getOwnPropertySymbols(e); o < r.length; o++)t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]) } return n } var mi = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function $h(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } function Uh(e, t) { return e(t = { exports: {} }, t.exports), t.exports } var eo = Uh(function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }); var n = function () { function r() { var o = this; this.locked = new Map, this.addToLocked = function (i, s) { var a = o.locked.get(i); void 0 === a ? o.locked.set(i, void 0 === s ? [] : [s]) : void 0 !== s && (a.unshift(s), o.locked.set(i, a)) }, this.isLocked = function (i) { return o.locked.has(i) }, this.lock = function (i) { return new Promise(function (s, a) { o.isLocked(i) ? o.addToLocked(i, s) : (o.addToLocked(i), s()) }) }, this.unlock = function (i) { var s = o.locked.get(i); if (void 0 !== s && 0 !== s.length) { var a = s.pop(); o.locked.set(i, s), void 0 !== a && setTimeout(a, 0) } else o.locked.delete(i) } } return r.getInstance = function () { return void 0 === r.instance && (r.instance = new r), r.instance }, r }(); t.default = function () { return n.getInstance() } }); $h(eo); var l2 = $h(Uh(function (e, t) { var n = mi && mi.__awaiter || function (c, u, l, d) { return new (l || (l = Promise))(function (f, h) { function p(v) { try { m(d.next(v)) } catch (_) { h(_) } } function g(v) { try { m(d.throw(v)) } catch (_) { h(_) } } function m(v) { v.done ? f(v.value) : new l(function (_) { _(v.value) }).then(p, g) } m((d = d.apply(c, u || [])).next()) }) }, r = mi && mi.__generator || function (c, u) { var l, d, f, h, p = { label: 0, sent: function () { if (1 & f[0]) throw f[1]; return f[1] }, trys: [], ops: [] }; return h = { next: g(0), throw: g(1), return: g(2) }, "function" == typeof Symbol && (h[Symbol.iterator] = function () { return this }), h; function g(m) { return function (v) { return function (_) { if (l) throw new TypeError("Generator is already executing."); for (; p;)try { if (l = 1, d && (f = 2 & _[0] ? d.return : _[0] ? d.throw || ((f = d.return) && f.call(d), 0) : d.next) && !(f = f.call(d, _[1])).done) return f; switch (d = 0, f && (_ = [2 & _[0], f.value]), _[0]) { case 0: case 1: f = _; break; case 4: return p.label++, { value: _[1], done: !1 }; case 5: p.label++, d = _[1], _ = [0]; continue; case 7: _ = p.ops.pop(), p.trys.pop(); continue; default: if (!((f = (f = p.trys).length > 0 && f[f.length - 1]) || 6 !== _[0] && 2 !== _[0])) { p = 0; continue } if (3 === _[0] && (!f || _[1] > f[0] && _[1] < f[3])) { p.label = _[1]; break } if (6 === _[0] && p.label < f[1]) { p.label = f[1], f = _; break } if (f && p.label < f[2]) { p.label = f[2], p.ops.push(_); break } f[2] && p.ops.pop(), p.trys.pop(); continue }_ = u.call(c, p) } catch (y) { _ = [6, y], d = 0 } finally { l = f = 0 } if (5 & _[0]) throw _[1]; return { value: _[0] ? _[1] : void 0, done: !0 } }([m, v]) } } }; Object.defineProperty(t, "__esModule", { value: !0 }); var o = "browser-tabs-lock-key"; function i(c) { return new Promise(function (u) { return setTimeout(u, c) }) } function s(c) { for (var u = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz", l = "", d = 0; d < c; d++)l += u[Math.floor(Math.random() * u.length)]; return l } var a = function () { function c() { this.acquiredIatSet = new Set, this.id = Date.now().toString() + s(15), this.acquireLock = this.acquireLock.bind(this), this.releaseLock = this.releaseLock.bind(this), this.releaseLock__private__ = this.releaseLock__private__.bind(this), this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this), this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this), void 0 === c.waiters && (c.waiters = []) } return c.prototype.acquireLock = function (u, l) { return void 0 === l && (l = 5e3), n(this, void 0, void 0, function () { var d, f, h, p, g, m; return r(this, function (v) { switch (v.label) { case 0: d = Date.now() + s(4), f = Date.now() + l, h = o + "-" + u, p = window.localStorage, v.label = 1; case 1: return Date.now() < f ? [4, i(30)] : [3, 8]; case 2: return v.sent(), null !== p.getItem(h) ? [3, 5] : (g = this.id + "-" + u + "-" + d, [4, i(Math.floor(25 * Math.random()))]); case 3: return v.sent(), p.setItem(h, JSON.stringify({ id: this.id, iat: d, timeoutKey: g, timeAcquired: Date.now(), timeRefreshed: Date.now() })), [4, i(30)]; case 4: return v.sent(), null !== (m = p.getItem(h)) && (m = JSON.parse(m)).id === this.id && m.iat === d ? (this.acquiredIatSet.add(d), this.refreshLockWhileAcquired(h, d), [2, !0]) : [3, 7]; case 5: return c.lockCorrector(), [4, this.waitForSomethingToChange(f)]; case 6: v.sent(), v.label = 7; case 7: return d = Date.now() + s(4), [3, 1]; case 8: return [2, !1] } }) }) }, c.prototype.refreshLockWhileAcquired = function (u, l) { return n(this, void 0, void 0, function () { var d = this; return r(this, function (f) { return setTimeout(function () { return n(d, void 0, void 0, function () { var h, p; return r(this, function (g) { switch (g.label) { case 0: return [4, eo.default().lock(l)]; case 1: return g.sent(), this.acquiredIatSet.has(l) ? (h = window.localStorage, null === (p = h.getItem(u)) ? (eo.default().unlock(l), [2]) : ((p = JSON.parse(p)).timeRefreshed = Date.now(), h.setItem(u, JSON.stringify(p)), eo.default().unlock(l), this.refreshLockWhileAcquired(u, l), [2])) : (eo.default().unlock(l), [2]) } }) }) }, 1e3), [2] }) }) }, c.prototype.waitForSomethingToChange = function (u) { return n(this, void 0, void 0, function () { return r(this, function (l) { switch (l.label) { case 0: return [4, new Promise(function (d) { var f = !1, h = Date.now(), p = !1; function g() { if (p || (window.removeEventListener("storage", g), c.removeFromWaiting(g), clearTimeout(m), p = !0), !f) { f = !0; var v = 50 - (Date.now() - h); v > 0 ? setTimeout(d, v) : d() } } window.addEventListener("storage", g), c.addToWaiting(g); var m = setTimeout(g, Math.max(0, u - Date.now())) })]; case 1: return l.sent(), [2] } }) }) }, c.addToWaiting = function (u) { this.removeFromWaiting(u), void 0 !== c.waiters && c.waiters.push(u) }, c.removeFromWaiting = function (u) { void 0 !== c.waiters && (c.waiters = c.waiters.filter(function (l) { return l !== u })) }, c.notifyWaiters = function () { void 0 !== c.waiters && c.waiters.slice().forEach(function (u) { return u() }) }, c.prototype.releaseLock = function (u) { return n(this, void 0, void 0, function () { return r(this, function (l) { switch (l.label) { case 0: return [4, this.releaseLock__private__(u)]; case 1: return [2, l.sent()] } }) }) }, c.prototype.releaseLock__private__ = function (u) { return n(this, void 0, void 0, function () { var l, d, f; return r(this, function (h) { switch (h.label) { case 0: return l = window.localStorage, null === (f = l.getItem(d = o + "-" + u)) ? [2] : (f = JSON.parse(f)).id !== this.id ? [3, 2] : [4, eo.default().lock(f.iat)]; case 1: h.sent(), this.acquiredIatSet.delete(f.iat), l.removeItem(d), eo.default().unlock(f.iat), c.notifyWaiters(), h.label = 2; case 2: return [2] } }) }) }, c.lockCorrector = function () { for (var u = Date.now() - 5e3, l = window.localStorage, d = Object.keys(l), f = !1, h = 0; h < d.length; h++) { var p = d[h]; if (p.includes(o)) { var g = l.getItem(p); null !== g && (void 0 === (g = JSON.parse(g)).timeRefreshed && g.timeAcquired < u || void 0 !== g.timeRefreshed && g.timeRefreshed < u) && (l.removeItem(p), f = !0) } } f && c.notifyWaiters() }, c.waiters = void 0, c }(); t.default = a })); const d2 = { timeoutInSeconds: 60 }, Nb = { name: "auth0-spa-js", version: "2.0.4" }, Fb = () => Date.now(); class tn extends Error { constructor(t, n) { super(n), this.error = t, this.error_description = n, Object.setPrototypeOf(this, tn.prototype) } static fromPayload({ error: t, error_description: n }) { return new tn(t, n) } } class Vh extends tn { constructor(t, n, r, o = null) { super(t, n), this.state = r, this.appState = o, Object.setPrototypeOf(this, Vh.prototype) } } class Bs extends tn { constructor() { super("timeout", "Timeout"), Object.setPrototypeOf(this, Bs.prototype) } } class Bh extends Bs { constructor(t) { super(), this.popup = t, Object.setPrototypeOf(this, Bh.prototype) } } class Hh extends tn { constructor(t) { super("cancelled", "Popup closed"), this.popup = t, Object.setPrototypeOf(this, Hh.prototype) } } class zh extends tn { constructor(t, n, r) { super(t, n), this.mfa_token = r, Object.setPrototypeOf(this, zh.prototype) } } class Su extends tn { constructor(t, n) { super("missing_refresh_token", `Missing Refresh Token (audience: '${Lb(t, ["default"])}', scope: '${Lb(n)}')`), this.audience = t, this.scope = n, Object.setPrototypeOf(this, Su.prototype) } } function Lb(e, t = []) { return e && !t.includes(e) ? e : "" } const Iu = () => window.crypto, qh = () => { const e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~."; let t = ""; return Array.from(Iu().getRandomValues(new Uint8Array(43))).forEach(n => t += e[n % e.length]), t }, jb = e => btoa(e), Wh = e => { var r, { clientId: t } = e, n = On(e, ["clientId"]); return new URLSearchParams((r = Object.assign({ client_id: t }, n), Object.keys(r).filter(o => void 0 !== r[o]).reduce((o, i) => Object.assign(Object.assign({}, o), { [i]: r[i] }), {}))).toString() }, $b = e => { return t = e.replace(/_/g, "/").replace(/-/g, "+"), decodeURIComponent(atob(t).split("").map(n => "%" + ("00" + n.charCodeAt(0).toString(16)).slice(-2)).join("")); var t }, f2 = function () { var e = Z(function* (t, n) { const r = yield fetch(t, n); return { ok: r.ok, json: yield r.json() } }); return function (n, r) { return e.apply(this, arguments) } }(), h2 = function () { var e = Z(function* (t, n, r) { const o = new AbortController; let i; return n.signal = o.signal, Promise.race([f2(t, n), new Promise((s, a) => { i = setTimeout(() => { o.abort(), a(new Error("Timeout when executing 'fetch'")) }, r) })]).finally(() => { clearTimeout(i) }) }); return function (n, r, o) { return e.apply(this, arguments) } }(), p2 = function () { var e = Z(function* (t, n, r, o, i, s, a) { return c = { auth: { audience: n, scope: r }, timeout: i, fetchUrl: t, fetchOptions: o, useFormData: a }, u = s, new Promise(function (l, d) { const f = new MessageChannel; f.port1.onmessage = function (h) { h.data.error ? d(new Error(h.data.error)) : l(h.data), f.port1.close() }, u.postMessage(c, [f.port2]) }); var c, u }); return function (n, r, o, i, s, a, c) { return e.apply(this, arguments) } }(), g2 = function () { var e = Z(function* (t, n, r, o, i, s, a = 1e4) { return i ? p2(t, n, r, o, a, i, s) : h2(t, o, a) }); return function (n, r, o, i, s, a) { return e.apply(this, arguments) } }(); function Gh() { return Gh = Z(function* (e, t) { var { baseUrl: n, timeout: r, audience: o, scope: i, auth0Client: s, useFormData: a } = e, c = On(e, ["baseUrl", "timeout", "audience", "scope", "auth0Client", "useFormData"]); const u = a ? Wh(c) : JSON.stringify(c); return yield (l = Z(function* (d, f, h, p, g, m, v) { let _, y = null; for (let Mt = 0; Mt < 3; Mt++)try { _ = yield g2(d, h, p, g, m, v, f), y = null; break } catch (nr) { y = nr } if (y) throw y; const w = _.json, { error: N, error_description: ne } = w, gt = On(w, ["error", "error_description"]), { ok: Et } = _; if (!Et) { const Mt = ne || `HTTP error. Unable to fetch ${d}`; throw "mfa_required" === N ? new zh(N, Mt, gt.mfa_token) : "missing_refresh_token" === N ? new Su(h, p) : new tn(N || "request_error", Mt) } return gt }), function (d, f, h, p, g, m, v) { return l.apply(this, arguments) })(`${n}/oauth/token`, r, o || "default", i, { method: "POST", body: u, headers: { "Content-Type": a ? "application/x-www-form-urlencoded" : "application/json", "Auth0-Client": btoa(JSON.stringify(s || Nb)) } }, t, a); var l }), Gh.apply(this, arguments) } const Tu = (...e) => { return (t = e.filter(Boolean).join(" ").trim().split(/\s+/), Array.from(new Set(t))).join(" "); var t }; class Pn { constructor(t, n = "@@auth0spajs@@", r) { this.prefix = n, this.suffix = r, this.clientId = t.clientId, this.scope = t.scope, this.audience = t.audience } toKey() { return [this.prefix, this.clientId, this.audience, this.scope, this.suffix].filter(Boolean).join("::") } static fromKey(t) { const [n, r, o, i] = t.split("::"); return new Pn({ clientId: r, scope: i, audience: o }, n) } static fromCacheEntry(t) { const { scope: n, audience: r, client_id: o } = t; return new Pn({ scope: n, audience: r, clientId: o }) } } class y2 { set(t, n) { localStorage.setItem(t, JSON.stringify(n)) } get(t) { const n = window.localStorage.getItem(t); if (n) try { return JSON.parse(n) } catch { return } } remove(t) { localStorage.removeItem(t) } allKeys() { return Object.keys(window.localStorage).filter(t => t.startsWith("@@auth0spajs@@")) } } class Ub { constructor() { this.enclosedCache = function () { let t = {}; return { set(n, r) { t[n] = r }, get(n) { const r = t[n]; if (r) return r }, remove(n) { delete t[n] }, allKeys: () => Object.keys(t) } }() } } class v2 { constructor(t, n, r) { this.cache = t, this.keyManifest = n, this.nowProvider = r || Fb } setIdToken(t, n, r) { var o = this; return Z(function* () { var i; const s = o.getIdTokenCacheKey(t); yield o.cache.set(s, { id_token: n, decodedToken: r }), yield null === (i = o.keyManifest) || void 0 === i ? void 0 : i.add(s) })() } getIdToken(t) { var n = this; return Z(function* () { const r = yield n.cache.get(n.getIdTokenCacheKey(t.clientId)); if (!r && t.scope && t.audience) { const o = yield n.get(t); return o && o.id_token && o.decodedToken ? { id_token: o.id_token, decodedToken: o.decodedToken } : void 0 } if (r) return { id_token: r.id_token, decodedToken: r.decodedToken } })() } get(t, n = 0) { var r = this; return Z(function* () { var o; let i = yield r.cache.get(t.toKey()); if (!i) { const c = yield r.getCacheKeys(); if (!c) return; const u = r.matchExistingCacheKey(t, c); u && (i = yield r.cache.get(u)) } if (!i) return; const s = yield r.nowProvider(), a = Math.floor(s / 1e3); return i.expiresAt - n < a ? i.body.refresh_token ? (i.body = { refresh_token: i.body.refresh_token }, yield r.cache.set(t.toKey(), i), i.body) : (yield r.cache.remove(t.toKey()), void (yield null === (o = r.keyManifest) || void 0 === o ? void 0 : o.remove(t.toKey()))) : i.body })() } set(t) { var n = this; return Z(function* () { var r; const o = new Pn({ clientId: t.client_id, scope: t.scope, audience: t.audience }), i = yield n.wrapCacheEntry(t); yield n.cache.set(o.toKey(), i), yield null === (r = n.keyManifest) || void 0 === r ? void 0 : r.add(o.toKey()) })() } clear(t) { var n = this; return Z(function* () { var r; const o = yield n.getCacheKeys(); o && (yield o.filter(i => !t || i.includes(t)).reduce(function () { var i = Z(function* (s, a) { yield s, yield n.cache.remove(a) }); return function (s, a) { return i.apply(this, arguments) } }(), Promise.resolve()), yield null === (r = n.keyManifest) || void 0 === r ? void 0 : r.clear()) })() } wrapCacheEntry(t) { var n = this; return Z(function* () { const r = yield n.nowProvider(); return { body: t, expiresAt: Math.floor(r / 1e3) + t.expires_in } })() } getCacheKeys() { var t = this; return Z(function* () { var n; return t.keyManifest ? null === (n = yield t.keyManifest.get()) || void 0 === n ? void 0 : n.keys : t.cache.allKeys ? t.cache.allKeys() : void 0 })() } getIdTokenCacheKey(t) { return new Pn({ clientId: t }, "@@auth0spajs@@", "@@user@@").toKey() } matchExistingCacheKey(t, n) { return n.filter(r => { var o; const i = Pn.fromKey(r), s = new Set(i.scope && i.scope.split(" ")), a = (null === (o = t.scope) || void 0 === o ? void 0 : o.split(" ")) || [], c = i.scope && a.reduce((u, l) => u && s.has(l), !0); return "@@auth0spajs@@" === i.prefix && i.clientId === t.clientId && i.audience === t.audience && c })[0] } } class _2 { constructor(t, n) { this.storage = t, this.clientId = n, this.storageKey = `a0.spajs.txs.${this.clientId}`, this.transaction = this.storage.get(this.storageKey) } create(t) { this.transaction = t, this.storage.save(this.storageKey, t, { daysUntilExpire: 1 }) } get() { return this.transaction } remove() { delete this.transaction, this.storage.remove(this.storageKey) } } const Hs = e => "number" == typeof e, C2 = ["iss", "aud", "exp", "nbf", "iat", "jti", "azp", "nonce", "auth_time", "at_hash", "c_hash", "acr", "amr", "sub_jwk", "cnf", "sip_from_tag", "sip_date", "sip_callid", "sip_cseq_num", "sip_via_branch", "orig", "dest", "mky", "events", "toe", "txn", "rph", "sid", "vot", "vtm"]; var to = Uh(function (e, t) { var n = mi && mi.__assign || function () { return n = Object.assign || function (c) { for (var u, l = 1, d = arguments.length; l < d; l++)for (var f in u = arguments[l]) Object.prototype.hasOwnProperty.call(u, f) && (c[f] = u[f]); return c }, n.apply(this, arguments) }; function r(c, u) { if (!u) return ""; var l = "; " + c; return !0 === u ? l : l + "=" + u } function o(c, u, l) { return encodeURIComponent(c).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/\(/g, "%28").replace(/\)/g, "%29") + "=" + encodeURIComponent(u).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent) + function (d) { if ("number" == typeof d.expires) { var f = new Date; f.setMilliseconds(f.getMilliseconds() + 864e5 * d.expires), d.expires = f } return r("Expires", d.expires ? d.expires.toUTCString() : "") + r("Domain", d.domain) + r("Path", d.path) + r("Secure", d.secure) + r("SameSite", d.sameSite) }(l) } function i(c) { for (var u = {}, l = c ? c.split("; ") : [], d = /(%[\dA-F]{2})+/gi, f = 0; f < l.length; f++) { var h = l[f].split("="), p = h.slice(1).join("="); '"' === p.charAt(0) && (p = p.slice(1, -1)); try { u[h[0].replace(d, decodeURIComponent)] = p.replace(d, decodeURIComponent) } catch { } } return u } function s() { return i(document.cookie) } function a(c, u, l) { document.cookie = o(c, u, n({ path: "/" }, l)) } t.__esModule = !0, t.encode = o, t.parse = i, t.getAll = s, t.get = function (c) { return s()[c] }, t.set = a, t.remove = function (c, u) { a(c, "", n(n({}, u), { expires: -1 })) } }); $h(to); var b2 = to.get, Vb = to.set, Bb = to.remove; const yi = { get(e) { const t = b2(e); if (void 0 !== t) return JSON.parse(t) }, save(e, t, n) { let r = {}; "https:" === window.location.protocol && (r = { secure: !0, sameSite: "none" }), n?.daysUntilExpire && (r.expires = n.daysUntilExpire), n?.cookieDomain && (r.domain = n.cookieDomain), Vb(e, JSON.stringify(t), r) }, remove(e, t) { let n = {}; t?.cookieDomain && (n.domain = t.cookieDomain), Bb(e, n) } }, D2 = { get: e => yi.get(e) || yi.get(`_legacy_${e}`), save(e, t, n) { let r = {}; "https:" === window.location.protocol && (r = { secure: !0 }), n?.daysUntilExpire && (r.expires = n.daysUntilExpire), n?.cookieDomain && (r.domain = n.cookieDomain), Vb(`_legacy_${e}`, JSON.stringify(t), r), yi.save(e, t, n) }, remove(e, t) { let n = {}; t?.cookieDomain && (n.domain = t.cookieDomain), Bb(e, n), yi.remove(e, t), yi.remove(`_legacy_${e}`, t) } }, E2 = { get(e) { if (typeof sessionStorage > "u") return; const t = sessionStorage.getItem(e); return null != t ? JSON.parse(t) : void 0 }, save(e, t) { sessionStorage.setItem(e, JSON.stringify(t)) }, remove(e) { sessionStorage.removeItem(e) } }; var Zh, S2 = function (e) { return Zh = Zh || function M2(e, t, n) { var r = void 0 === t ? null : t, o = function (c, u) { var l = atob(c); if (u) { for (var d = new Uint8Array(l.length), f = 0, h = l.length; f < h; ++f)d[f] = l.charCodeAt(f); return String.fromCharCode.apply(null, new Uint16Array(d.buffer)) } return l }(e, void 0 !== n && n), i = o.indexOf("\n", 10) + 1, s = o.substring(i) + (r ? "//# sourceMappingURL=" + r : ""), a = new Blob([s], { type: "application/javascript" }); return URL.createObjectURL(a) }("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y2xhc3MgZSBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQscil7c3VwZXIociksdGhpcy5lcnJvcj10LHRoaXMuZXJyb3JfZGVzY3JpcHRpb249cixPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxlLnByb3RvdHlwZSl9c3RhdGljIGZyb21QYXlsb2FkKHtlcnJvcjp0LGVycm9yX2Rlc2NyaXB0aW9uOnJ9KXtyZXR1cm4gbmV3IGUodCxyKX19Y2xhc3MgdCBleHRlbmRzIGV7Y29uc3RydWN0b3IoZSxzKXtzdXBlcigibWlzc2luZ19yZWZyZXNoX3Rva2VuIixgTWlzc2luZyBSZWZyZXNoIFRva2VuIChhdWRpZW5jZTogJyR7cihlLFsiZGVmYXVsdCJdKX0nLCBzY29wZTogJyR7cihzKX0nKWApLHRoaXMuYXVkaWVuY2U9ZSx0aGlzLnNjb3BlPXMsT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsdC5wcm90b3R5cGUpfX1mdW5jdGlvbiByKGUsdD1bXSl7cmV0dXJuIGUmJiF0LmluY2x1ZGVzKGUpP2U6IiJ9Y29uc3Qgcz1lPT57dmFye2NsaWVudElkOnR9PWUscj1mdW5jdGlvbihlLHQpe3ZhciByPXt9O2Zvcih2YXIgcyBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHMpJiZ0LmluZGV4T2Yocyk8MCYmKHJbc109ZVtzXSk7aWYobnVsbCE9ZSYmImZ1bmN0aW9uIj09dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBvPTA7Zm9yKHM9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtvPHMubGVuZ3RoO28rKyl0LmluZGV4T2Yoc1tvXSk8MCYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsc1tvXSkmJihyW3Nbb11dPWVbc1tvXV0pfXJldHVybiByfShlLFsiY2xpZW50SWQiXSk7cmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoKGU9Pk9iamVjdC5rZXlzKGUpLmZpbHRlcigodD0+dm9pZCAwIT09ZVt0XSkpLnJlZHVjZSgoKHQscik9Pk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7W3JdOmVbcl19KSkse30pKShPYmplY3QuYXNzaWduKHtjbGllbnRfaWQ6dH0scikpKS50b1N0cmluZygpfTtsZXQgbz17fTtjb25zdCBuPShlLHQpPT5gJHtlfXwke3R9YDthZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwoYXN5bmMoe2RhdGE6e3RpbWVvdXQ6ZSxhdXRoOnIsZmV0Y2hVcmw6aSxmZXRjaE9wdGlvbnM6Yyx1c2VGb3JtRGF0YTphfSxwb3J0czpbZl19KT0+e2xldCBwO2NvbnN0e2F1ZGllbmNlOmwsc2NvcGU6dX09cnx8e307dHJ5e2NvbnN0IHI9YT8oZT0+e2NvbnN0IHQ9bmV3IFVSTFNlYXJjaFBhcmFtcyhlKSxyPXt9O3JldHVybiB0LmZvckVhY2goKChlLHQpPT57clt0XT1lfSkpLHJ9KShjLmJvZHkpOkpTT04ucGFyc2UoYy5ib2R5KTtpZighci5yZWZyZXNoX3Rva2VuJiYicmVmcmVzaF90b2tlbiI9PT1yLmdyYW50X3R5cGUpe2NvbnN0IGU9KChlLHQpPT5vW24oZSx0KV0pKGwsdSk7aWYoIWUpdGhyb3cgbmV3IHQobCx1KTtjLmJvZHk9YT9zKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7cmVmcmVzaF90b2tlbjplfSkpOkpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7cmVmcmVzaF90b2tlbjplfSkpfWxldCBkLGc7ImZ1bmN0aW9uIj09dHlwZW9mIEFib3J0Q29udHJvbGxlciYmKGQ9bmV3IEFib3J0Q29udHJvbGxlcixjLnNpZ25hbD1kLnNpZ25hbCk7dHJ5e2c9YXdhaXQgUHJvbWlzZS5yYWNlKFsoaD1lLG5ldyBQcm9taXNlKChlPT5zZXRUaW1lb3V0KGUsaCkpKSksZmV0Y2goaSxPYmplY3QuYXNzaWduKHt9LGMpKV0pfWNhdGNoKGUpe3JldHVybiB2b2lkIGYucG9zdE1lc3NhZ2Uoe2Vycm9yOmUubWVzc2FnZX0pfWlmKCFnKXJldHVybiBkJiZkLmFib3J0KCksdm9pZCBmLnBvc3RNZXNzYWdlKHtlcnJvcjoiVGltZW91dCB3aGVuIGV4ZWN1dGluZyAnZmV0Y2gnIn0pO3A9YXdhaXQgZy5qc29uKCkscC5yZWZyZXNoX3Rva2VuPygoKGUsdCxyKT0+e29bbih0LHIpXT1lfSkocC5yZWZyZXNoX3Rva2VuLGwsdSksZGVsZXRlIHAucmVmcmVzaF90b2tlbik6KChlLHQpPT57ZGVsZXRlIG9bbihlLHQpXX0pKGwsdSksZi5wb3N0TWVzc2FnZSh7b2s6Zy5vayxqc29uOnB9KX1jYXRjaChlKXtmLnBvc3RNZXNzYWdlKHtvazohMSxqc29uOntlcnJvcjplLmVycm9yLGVycm9yX2Rlc2NyaXB0aW9uOmUubWVzc2FnZX19KX12YXIgaH0pKX0oKTsKCg==", null, !1), new Worker(Zh, e) }; const Kh = {}; class I2 { constructor(t, n) { this.cache = t, this.clientId = n, this.manifestKey = this.createManifestKeyFrom(this.clientId) } add(t) { var n = this; return Z(function* () { var r; const o = new Set((null === (r = yield n.cache.get(n.manifestKey)) || void 0 === r ? void 0 : r.keys) || []); o.add(t), yield n.cache.set(n.manifestKey, { keys: [...o] }) })() } remove(t) { var n = this; return Z(function* () { const r = yield n.cache.get(n.manifestKey); if (r) { const o = new Set(r.keys); return o.delete(t), o.size > 0 ? yield n.cache.set(n.manifestKey, { keys: [...o] }) : yield n.cache.remove(n.manifestKey) } })() } get() { return this.cache.get(this.manifestKey) } clear() { return this.cache.remove(this.manifestKey) } createManifestKeyFrom(t) { return `@@auth0spajs@@::${t}` } } const T2 = { memory: () => (new Ub).enclosedCache, localstorage: () => new y2 }, Wb = e => T2[e], Gb = e => { const { openUrl: t, onRedirect: n } = e, r = On(e, ["openUrl", "onRedirect"]); return Object.assign(Object.assign({}, r), { openUrl: !1 === t || t ? t : n }) }, Yh = new l2; class Zb { constructor(t) { var n = this; let r, o; if (this.userCache = (new Ub).enclosedCache, this.defaultOptions = { authorizationParams: { scope: "openid profile email" }, useRefreshTokensFallback: !1, useFormData: !0 }, this._releaseLockOnPageHide = Z(function* () { yield Yh.releaseLock("auth0.lock.getTokenSilently"), window.removeEventListener("pagehide", n._releaseLockOnPageHide) }), this.options = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), t), { authorizationParams: Object.assign(Object.assign({}, this.defaultOptions.authorizationParams), t.authorizationParams) }), typeof window < "u" && (() => { if (!Iu()) throw new Error("For security reasons, `window.crypto` is required to run `auth0-spa-js`."); if (void 0 === Iu().subtle) throw new Error("\n      auth0-spa-js must run on a secure origin. See https://github.com/auth0/auth0-spa-js/blob/master/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin for more information.\n    ") })(), t.cache && t.cacheLocation && console.warn("Both `cache` and `cacheLocation` options have been specified in the Auth0Client configuration; ignoring `cacheLocation` and using `cache`."), t.cache) o = t.cache; else { if (r = t.cacheLocation || "memory", !Wb(r)) throw new Error(`Invalid cache location "${r}"`); o = Wb(r)() } this.httpTimeoutMs = t.httpTimeoutInSeconds ? 1e3 * t.httpTimeoutInSeconds : 1e4, this.cookieStorage = !1 === t.legacySameSiteCookie ? yi : D2, this.orgHintCookieName = `auth0.${this.options.clientId}.organization_hint`, this.isAuthenticatedCookieName = (a => `auth0.${this.options.clientId}.is.authenticated`)(), this.sessionCheckExpiryDays = t.sessionCheckExpiryDays || 1; const i = t.useCookiesForTransactions ? this.cookieStorage : E2; var s, a, c; this.scope = Tu("openid", this.options.authorizationParams.scope, this.options.useRefreshTokens ? "offline_access" : ""), this.transactionManager = new _2(i, this.options.clientId), this.nowProvider = this.options.nowProvider || Fb, this.cacheManager = new v2(o, o.allKeys ? void 0 : new I2(o, this.options.clientId), this.nowProvider), this.domainUrl = /^https?:\/\//.test(s = this.options.domain) ? s : `https://${s}`, this.tokenIssuer = (c = this.domainUrl, (a = this.options.issuer) ? a.startsWith("https://") ? a : `https://${a}/` : `${c}/`), typeof window < "u" && window.Worker && this.options.useRefreshTokens && "memory" === r && (this.worker = new S2) } _url(t) { const n = encodeURIComponent(btoa(JSON.stringify(this.options.auth0Client || Nb))); return `${this.domainUrl}${t}&auth0Client=${n}` } _authorizeUrl(t) { return this._url(`/authorize?${Wh(t)}`) } _verifyIdToken(t, n, r) { var o = this; return Z(function* () { const i = yield o.nowProvider(); return (e => { if (!e.id_token) throw new Error("ID token is required but missing"); const t = (i => { const s = i.split("."), [a, c, u] = s; if (3 !== s.length || !a || !c || !u) throw new Error("ID token could not be decoded"); const l = JSON.parse($b(c)), d = { __raw: i }, f = {}; return Object.keys(l).forEach(h => { d[h] = l[h], C2.includes(h) || (f[h] = l[h]) }), { encoded: { header: a, payload: c, signature: u }, header: JSON.parse($b(a)), claims: d, user: f } })(e.id_token); if (!t.claims.iss) throw new Error("Issuer (iss) claim must be a string present in the ID token"); if (t.claims.iss !== e.iss) throw new Error(`Issuer (iss) claim mismatch in the ID token; expected "${e.iss}", found "${t.claims.iss}"`); if (!t.user.sub) throw new Error("Subject (sub) claim must be a string present in the ID token"); if ("RS256" !== t.header.alg) throw new Error(`Signature algorithm of "${t.header.alg}" is not supported. Expected the ID token to be signed with "RS256".`); if (!t.claims.aud || "string" != typeof t.claims.aud && !Array.isArray(t.claims.aud)) throw new Error("Audience (aud) claim must be a string or array of strings present in the ID token"); if (Array.isArray(t.claims.aud)) { if (!t.claims.aud.includes(e.aud)) throw new Error(`Audience (aud) claim mismatch in the ID token; expected "${e.aud}" but was not one of "${t.claims.aud.join(", ")}"`); if (t.claims.aud.length > 1) { if (!t.claims.azp) throw new Error("Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values"); if (t.claims.azp !== e.aud) throw new Error(`Authorized Party (azp) claim mismatch in the ID token; expected "${e.aud}", found "${t.claims.azp}"`) } } else if (t.claims.aud !== e.aud) throw new Error(`Audience (aud) claim mismatch in the ID token; expected "${e.aud}" but found "${t.claims.aud}"`); if (e.nonce) { if (!t.claims.nonce) throw new Error("Nonce (nonce) claim must be a string present in the ID token"); if (t.claims.nonce !== e.nonce) throw new Error(`Nonce (nonce) claim mismatch in the ID token; expected "${e.nonce}", found "${t.claims.nonce}"`) } if (e.max_age && !Hs(t.claims.auth_time)) throw new Error("Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified"); if (null == t.claims.exp || !Hs(t.claims.exp)) throw new Error("Expiration Time (exp) claim must be a number present in the ID token"); if (!Hs(t.claims.iat)) throw new Error("Issued At (iat) claim must be a number present in the ID token"); const n = e.leeway || 60, r = new Date(e.now || Date.now()), o = new Date(0); if (o.setUTCSeconds(t.claims.exp + n), r > o) throw new Error(`Expiration Time (exp) claim error in the ID token; current time (${r}) is after expiration time (${o})`); if (null != t.claims.nbf && Hs(t.claims.nbf)) { const i = new Date(0); if (i.setUTCSeconds(t.claims.nbf - n), r < i) throw new Error(`Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Current time (${r}) is before ${i}`) } if (null != t.claims.auth_time && Hs(t.claims.auth_time)) { const i = new Date(0); if (i.setUTCSeconds(parseInt(t.claims.auth_time) + e.max_age + n), r > i) throw new Error(`Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (${r}) is after last auth at ${i}`) } if (e.organizationId) { if (!t.claims.org_id) throw new Error("Organization ID (org_id) claim must be a string present in the ID token"); if (e.organizationId !== t.claims.org_id) throw new Error(`Organization ID (org_id) claim mismatch in the ID token; expected "${e.organizationId}", found "${t.claims.org_id}"`) } return t })({ iss: o.tokenIssuer, aud: o.options.clientId, id_token: t, nonce: n, organizationId: r, leeway: o.options.leeway, max_age: (s = o.options.authorizationParams.max_age, "string" != typeof s ? s : parseInt(s, 10) || void 0), now: i }); var s })() } _processOrgIdHint(t) { t ? this.cookieStorage.save(this.orgHintCookieName, t, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }) : this.cookieStorage.remove(this.orgHintCookieName, { cookieDomain: this.options.cookieDomain }) } _prepareAuthorizeUrl(t, n, r) { var o = this; return Z(function* () { const i = jb(qh()), s = jb(qh()), a = qh(), c = (d => { const f = new Uint8Array(d); return (h => { const p = { "+": "-", "/": "_", "=": "" }; return h.replace(/[+/=]/g, g => p[g]) })(window.btoa(String.fromCharCode(...Array.from(f)))) })(yield (d = Z(function* (f) { return yield Iu().subtle.digest({ name: "SHA-256" }, (new TextEncoder).encode(f)) }), function (f) { return d.apply(this, arguments) })(a)), u = ((d, f, h, p, g, m, v, _) => Object.assign(Object.assign(Object.assign({ client_id: d.clientId }, d.authorizationParams), h), { scope: Tu(f, h.scope), response_type: "code", response_mode: _ || "query", state: p, nonce: g, redirect_uri: v || d.authorizationParams.redirect_uri, code_challenge: m, code_challenge_method: "S256" }))(o.options, o.scope, t, i, s, c, t.redirect_uri || o.options.authorizationParams.redirect_uri || r, n?.response_mode), l = o._authorizeUrl(u); var d; return { nonce: s, code_verifier: a, scope: u.scope, audience: u.audience || "default", redirect_uri: u.redirect_uri, state: i, url: l } })() } loginWithPopup(t, n) { var r = this; return Z(function* () { var o; if (t = t || {}, !(n = n || {}).popup && (n.popup = (c => { const u = window.screenX + (window.innerWidth - 400) / 2, l = window.screenY + (window.innerHeight - 600) / 2; return window.open("", "auth0:authorize:popup", `left=${u},top=${l},width=400,height=600,resizable,scrollbars=yes,status=1`) })(), !n.popup)) throw new Error("Unable to open a popup for loginWithPopup - window.open returned `null`"); const i = yield r._prepareAuthorizeUrl(t.authorizationParams || {}, { response_mode: "web_message" }, window.location.origin); n.popup.location.href = i.url; const s = yield (c = Object.assign(Object.assign({}, n), { timeoutInSeconds: n.timeoutInSeconds || r.options.authorizeTimeoutInSeconds || 60 }), new Promise((u, l) => { let d; const f = setInterval(() => { c.popup && c.popup.closed && (clearInterval(f), clearTimeout(h), window.removeEventListener("message", d, !1), l(new Hh(c.popup))) }, 1e3), h = setTimeout(() => { clearInterval(f), l(new Bh(c.popup)), window.removeEventListener("message", d, !1) }, 1e3 * (c.timeoutInSeconds || 60)); d = function (p) { if (p.data && "authorization_response" === p.data.type) { if (clearTimeout(h), clearInterval(f), window.removeEventListener("message", d, !1), c.popup.close(), p.data.response.error) return l(tn.fromPayload(p.data.response)); u(p.data.response) } }, window.addEventListener("message", d) })); var c; if (i.state !== s.state) throw new Error("Invalid state"); const a = (null === (o = t.authorizationParams) || void 0 === o ? void 0 : o.organization) || r.options.authorizationParams.organization; yield r._requestToken({ audience: i.audience, scope: i.scope, code_verifier: i.code_verifier, grant_type: "authorization_code", code: s.code, redirect_uri: i.redirect_uri }, { nonceIn: i.nonce, organizationId: a }) })() } getUser() { var t = this; return Z(function* () { var n; return null === (n = (yield t._getIdTokenFromCache())?.decodedToken) || void 0 === n ? void 0 : n.user })() } getIdTokenClaims() { var t = this; return Z(function* () { var n; return null === (n = (yield t._getIdTokenFromCache())?.decodedToken) || void 0 === n ? void 0 : n.claims })() } loginWithRedirect(t = {}) { var n = this; return Z(function* () { var r; const o = Gb(t), { openUrl: i, fragment: s, appState: a } = o, c = On(o, ["openUrl", "fragment", "appState"]), u = (null === (r = c.authorizationParams) || void 0 === r ? void 0 : r.organization) || n.options.authorizationParams.organization, l = yield n._prepareAuthorizeUrl(c.authorizationParams || {}), { url: d } = l, f = On(l, ["url"]); n.transactionManager.create(Object.assign(Object.assign(Object.assign({}, f), { appState: a }), u && { organizationId: u })); const h = s ? `${d}#${s}` : d; i ? yield i(h) : window.location.assign(h) })() } handleRedirectCallback(t = window.location.href) { var n = this; return Z(function* () { const r = t.split("?").slice(1); if (0 === r.length) throw new Error("There are no query params available for parsing."); const { state: o, code: i, error: s, error_description: a } = (f => { f.indexOf("#") > -1 && (f = f.substring(0, f.indexOf("#"))); const h = new URLSearchParams(f); return { state: h.get("state"), code: h.get("code") || void 0, error: h.get("error") || void 0, error_description: h.get("error_description") || void 0 } })(r.join("")), c = n.transactionManager.get(); if (!c) throw new Error("Invalid state"); if (n.transactionManager.remove(), s) throw new Vh(s, a || s, o, c.appState); if (!c.code_verifier || c.state && c.state !== o) throw new Error("Invalid state"); const u = c.organizationId, l = c.nonce, d = c.redirect_uri; return yield n._requestToken(Object.assign({ audience: c.audience, scope: c.scope, code_verifier: c.code_verifier, grant_type: "authorization_code", code: i }, d ? { redirect_uri: d } : {}), { nonceIn: l, organizationId: u }), { appState: c.appState } })() } checkSession(t) { var n = this; return Z(function* () { if (!n.cookieStorage.get(n.isAuthenticatedCookieName)) { if (!n.cookieStorage.get("auth0.is.authenticated")) return; n.cookieStorage.save(n.isAuthenticatedCookieName, !0, { daysUntilExpire: n.sessionCheckExpiryDays, cookieDomain: n.options.cookieDomain }), n.cookieStorage.remove("auth0.is.authenticated") } try { yield n.getTokenSilently(t) } catch { } })() } getTokenSilently(t = {}) { var n = this; return Z(function* () { var r; const o = Object.assign(Object.assign({ cacheMode: "on" }, t), { authorizationParams: Object.assign(Object.assign(Object.assign({}, n.options.authorizationParams), t.authorizationParams), { scope: Tu(n.scope, null === (r = t.authorizationParams) || void 0 === r ? void 0 : r.scope) }) }), i = yield ((s, a) => { let c = Kh[a]; return c || (c = n._getTokenSilently(o).finally(() => { delete Kh[a], c = null }), Kh[a] = c), c })(0, `${n.options.clientId}::${o.authorizationParams.audience}::${o.authorizationParams.scope}`); return t.detailedResponse ? i : i?.access_token })() } _getTokenSilently(t) { var n = this; return Z(function* () { const { cacheMode: r } = t, o = On(t, ["cacheMode"]); if ("off" !== r) { const i = yield n._getEntryFromCache({ scope: o.authorizationParams.scope, audience: o.authorizationParams.audience || "default", clientId: n.options.clientId }); if (i) return i } if ("cache-only" !== r) { if (!(yield (i = Z(function* (s, a = 3) { for (let c = 0; c < a; c++)if (yield s()) return !0; return !1 }), function (s) { return i.apply(this, arguments) })(() => Yh.acquireLock("auth0.lock.getTokenSilently", 5e3), 10))) throw new Bs; try { if (window.addEventListener("pagehide", n._releaseLockOnPageHide), "off" !== r) { const l = yield n._getEntryFromCache({ scope: o.authorizationParams.scope, audience: o.authorizationParams.audience || "default", clientId: n.options.clientId }); if (l) return l } const i = n.options.useRefreshTokens ? yield n._getTokenUsingRefreshToken(o) : yield n._getTokenFromIFrame(o), { id_token: s, access_token: a, oauthTokenScope: c, expires_in: u } = i; return Object.assign(Object.assign({ id_token: s, access_token: a }, c ? { scope: c } : null), { expires_in: u }) } finally { yield Yh.releaseLock("auth0.lock.getTokenSilently"), window.removeEventListener("pagehide", n._releaseLockOnPageHide) } } var i })() } getTokenWithPopup(t = {}, n = {}) { var r = this; return Z(function* () { var o; const i = Object.assign(Object.assign({}, t), { authorizationParams: Object.assign(Object.assign(Object.assign({}, r.options.authorizationParams), t.authorizationParams), { scope: Tu(r.scope, null === (o = t.authorizationParams) || void 0 === o ? void 0 : o.scope) }) }); return n = Object.assign(Object.assign({}, d2), n), yield r.loginWithPopup(i, n), (yield r.cacheManager.get(new Pn({ scope: i.authorizationParams.scope, audience: i.authorizationParams.audience || "default", clientId: r.options.clientId }))).access_token })() } isAuthenticated() { var t = this; return Z(function* () { return !!(yield t.getUser()) })() } _buildLogoutUrl(t) { null !== t.clientId ? t.clientId = t.clientId || this.options.clientId : delete t.clientId; const n = t.logoutParams || {}, { federated: r } = n, o = On(n, ["federated"]), i = r ? "&federated" : ""; return this._url(`/v2/logout?${Wh(Object.assign({ clientId: t.clientId }, o))}`) + i } logout(t = {}) { var n = this; return Z(function* () { const r = Gb(t), { openUrl: o } = r, i = On(r, ["openUrl"]); null === t.clientId ? yield n.cacheManager.clear() : yield n.cacheManager.clear(t.clientId || n.options.clientId), n.cookieStorage.remove(n.orgHintCookieName, { cookieDomain: n.options.cookieDomain }), n.cookieStorage.remove(n.isAuthenticatedCookieName, { cookieDomain: n.options.cookieDomain }), n.userCache.remove("@@user@@"); const s = n._buildLogoutUrl(i); o ? yield o(s) : !1 !== o && window.location.assign(s) })() } _getTokenFromIFrame(t) { var n = this; return Z(function* () { const r = Object.assign(Object.assign({}, t.authorizationParams), { prompt: "none" }), o = n.cookieStorage.get(n.orgHintCookieName); o && !r.organization && (r.organization = o); const { url: i, state: s, nonce: a, code_verifier: c, redirect_uri: u, scope: l, audience: d } = yield n._prepareAuthorizeUrl(r, { response_mode: "web_message" }, window.location.origin); try { if (window.crossOriginIsolated) throw new tn("login_required", "The application is running in a Cross-Origin Isolated context, silently retrieving a token without refresh token is not possible."); const f = t.timeoutInSeconds || n.options.authorizeTimeoutInSeconds, h = yield ((g, m, v = 60) => new Promise((_, y) => { const w = window.document.createElement("iframe"); w.setAttribute("width", "0"), w.setAttribute("height", "0"), w.style.display = "none"; const N = () => { window.document.body.contains(w) && (window.document.body.removeChild(w), window.removeEventListener("message", ne, !1)) }; let ne; const gt = setTimeout(() => { y(new Bs), N() }, 1e3 * v); ne = function (Et) { if (Et.origin != m || !Et.data || "authorization_response" !== Et.data.type) return; const Mt = Et.source; Mt && Mt.close(), Et.data.response.error ? y(tn.fromPayload(Et.data.response)) : _(Et.data.response), clearTimeout(gt), window.removeEventListener("message", ne, !1), setTimeout(N, 2e3) }, window.addEventListener("message", ne, !1), window.document.body.appendChild(w), w.setAttribute("src", g) }))(i, n.domainUrl, f); if (s !== h.state) throw new Error("Invalid state"); const p = yield n._requestToken(Object.assign(Object.assign({}, t.authorizationParams), { code_verifier: c, code: h.code, grant_type: "authorization_code", redirect_uri: u, timeout: t.authorizationParams.timeout || n.httpTimeoutMs }), { nonceIn: a }); return Object.assign(Object.assign({}, p), { scope: l, oauthTokenScope: p.scope, audience: d }) } catch (f) { throw "login_required" === f.error && n.logout({ openUrl: !1 }), f } })() } _getTokenUsingRefreshToken(t) { var n = this; return Z(function* () { const r = yield n.cacheManager.get(new Pn({ scope: t.authorizationParams.scope, audience: t.authorizationParams.audience || "default", clientId: n.options.clientId })); if (!(r && r.refresh_token || n.worker)) { if (n.options.useRefreshTokensFallback) return yield n._getTokenFromIFrame(t); throw new Su(t.authorizationParams.audience || "default", t.authorizationParams.scope) } const o = t.authorizationParams.redirect_uri || n.options.authorizationParams.redirect_uri || window.location.origin, i = "number" == typeof t.timeoutInSeconds ? 1e3 * t.timeoutInSeconds : null; try { const s = yield n._requestToken(Object.assign(Object.assign(Object.assign({}, t.authorizationParams), { grant_type: "refresh_token", refresh_token: r && r.refresh_token, redirect_uri: o }), i && { timeout: i })); return Object.assign(Object.assign({}, s), { scope: t.authorizationParams.scope, oauthTokenScope: s.scope, audience: t.authorizationParams.audience || "default" }) } catch (s) { if ((s.message.indexOf("Missing Refresh Token") > -1 || s.message && s.message.indexOf("invalid refresh token") > -1) && n.options.useRefreshTokensFallback) return yield n._getTokenFromIFrame(t); throw s } })() } _saveEntryInCache(t) { var n = this; return Z(function* () { const { id_token: r, decodedToken: o } = t, i = On(t, ["id_token", "decodedToken"]); n.userCache.set("@@user@@", { id_token: r, decodedToken: o }), yield n.cacheManager.setIdToken(n.options.clientId, t.id_token, t.decodedToken), yield n.cacheManager.set(i) })() } _getIdTokenFromCache() { var t = this; return Z(function* () { const n = t.options.authorizationParams.audience || "default", r = yield t.cacheManager.getIdToken(new Pn({ clientId: t.options.clientId, audience: n, scope: t.scope })), o = t.userCache.get("@@user@@"); return r && r.id_token === o?.id_token ? o : (t.userCache.set("@@user@@", r), r) })() } _getEntryFromCache({ scope: t, audience: n, clientId: r }) { var o = this; return Z(function* () { const i = yield o.cacheManager.get(new Pn({ scope: t, audience: n, clientId: r }), 60); if (i && i.access_token) { const { access_token: s, oauthTokenScope: a, expires_in: c } = i, u = yield o._getIdTokenFromCache(); return u && Object.assign(Object.assign({ id_token: u.id_token, access_token: s }, a ? { scope: a } : null), { expires_in: c }) } })() } _requestToken(t, n) { var r = this; return Z(function* () { const { nonceIn: o, organizationId: i } = n || {}, s = yield function m2(e, t) { return Gh.apply(this, arguments) }(Object.assign({ baseUrl: r.domainUrl, client_id: r.options.clientId, auth0Client: r.options.auth0Client, useFormData: r.options.useFormData, timeout: r.httpTimeoutMs }, t), r.worker), a = yield r._verifyIdToken(s.id_token, o, i); return yield r._saveEntryInCache(Object.assign(Object.assign(Object.assign(Object.assign({}, s), { decodedToken: a, scope: t.scope, audience: t.audience || "default" }), s.scope ? { oauthTokenScope: s.scope } : null), { client_id: r.options.clientId })), r.cookieStorage.save(r.isAuthenticatedCookieName, !0, { daysUntilExpire: r.sessionCheckExpiryDays, cookieDomain: r.options.cookieDomain }), r._processOrgIdHint(a.claims.org_id), Object.assign(Object.assign({}, s), { decodedToken: a }) })() } } class Yb { static createClient(t) { const n = t.get(); if (!n) throw new Error("Configuration must be specified either through AuthModule.forRoot or through AuthClientConfig.set"); return new Zb({ ...n, auth0Client: { name: "@auth0/auth0-angular", version: "2.1.0", env: { "angular/core": Mm.full } } }) } } const xu = new O("auth0.client"), Xh = new O("auth0-angular.config"); let Jh = (() => { class e { constructor(n) { n && this.set(n) } set(n) { this.config = n } get() { return this.config } } return e.\u0275fac = function (n) { return new (n || e)(E(Xh, 8)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), x2 = (() => { class e { constructor(n, r) { this.location = n; try { this.router = r.get(Ke) } catch { } } navigateByUrl(n) { this.router ? this.router.navigateByUrl(n) : this.location.replaceState(n) } } return e.\u0275fac = function (n) { return new (n || e)(E(dc), E(Vt)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), O2 = (() => { class e { constructor(n) { this.auth0Client = n, this.isLoadingSubject$ = new ht(!0), this.refresh$ = new Pt, this.accessToken$ = new Mu(1), this.errorSubject$ = new Mu(1), this.isLoading$ = this.isLoadingSubject$.asObservable(), this.accessTokenTrigger$ = this.accessToken$.pipe(Kf((r, o) => ({ previous: r.current, current: o }), { current: null, previous: null }), Ze(({ previous: r, current: o }) => r !== o)), this.isAuthenticatedTrigger$ = this.isLoading$.pipe(Ze(r => !r), jh(), Jt(() => Ep(Qo(() => this.auth0Client.isAuthenticated()), this.accessTokenTrigger$.pipe(Be(() => this.auth0Client.isAuthenticated())), this.refresh$.pipe(Be(() => this.auth0Client.isAuthenticated()))))), this.isAuthenticated$ = this.isAuthenticatedTrigger$.pipe(jh(), function a2(e, t, n) { let r, o = !1; return e && "object" == typeof e ? ({ bufferSize: r = 1 / 0, windowTime: t = 1 / 0, refCount: o = !1, scheduler: n } = e) : r = e ?? 1 / 0, Mp({ connector: () => new Mu(r, t, n), resetOnError: !0, resetOnComplete: !1, resetOnRefCountZero: o }) }(1)), this.user$ = this.isAuthenticatedTrigger$.pipe(mn(r => r ? this.auth0Client.getUser() : T(null)), jh()), this.idTokenClaims$ = this.isAuthenticatedTrigger$.pipe(mn(r => r ? this.auth0Client.getIdTokenClaims() : T(null))), this.error$ = this.errorSubject$.asObservable() } setIsLoading(n) { this.isLoadingSubject$.next(n) } refresh() { this.refresh$.next() } setAccessToken(n) { this.accessToken$.next(n) } setError(n) { this.errorSubject$.next(n) } } return e.\u0275fac = function (n) { return new (n || e)(E(xu)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), vi = (() => { class e { constructor(n, r, o, i) { this.auth0Client = n, this.configFactory = r, this.navigator = o, this.authState = i, this.appStateSubject$ = new Mu(1), this.ngUnsubscribe$ = new Pt, this.isLoading$ = this.authState.isLoading$, this.isAuthenticated$ = this.authState.isAuthenticated$, this.user$ = this.authState.user$, this.idTokenClaims$ = this.authState.idTokenClaims$, this.error$ = this.authState.error$, this.appState$ = this.appStateSubject$.asObservable(); const s = a => function i2(e, t, n) { return Qo(() => e() ? t : n) }(() => a, this.handleRedirectCallback(), Qo(() => this.auth0Client.checkSession())); this.shouldHandleCallback().pipe(Jt(a => s(a).pipe(yn(c => { const u = this.configFactory.get(); return this.navigator.navigateByUrl(u.errorPath || "/"), this.authState.setError(c), T(void 0) }))), Fe(() => { this.authState.setIsLoading(!1) }), function c2(e) { return ke((t, n) => { Wt(e).subscribe(Se(n, () => n.complete(), j)), !n.closed && t.subscribe(n) }) }(this.ngUnsubscribe$)).subscribe() } ngOnDestroy() { this.ngUnsubscribe$.next(), this.ngUnsubscribe$.complete() } loginWithRedirect(n) { return Ie(this.auth0Client.loginWithRedirect(n)) } loginWithPopup(n, r) { return Ie(this.auth0Client.loginWithPopup(n, r).then(() => { this.authState.refresh() })) } logout(n) { return Ie(this.auth0Client.logout(n).then(() => { (!1 === n?.openUrl || n?.openUrl) && this.authState.refresh() })) } getAccessTokenSilently(n = {}) { return T(this.auth0Client).pipe(mn(r => r.getTokenSilently(!0 === n.detailedResponse ? { ...n, detailedResponse: !0 } : n)), Fe(r => this.authState.setAccessToken("string" == typeof r ? r : r.access_token)), yn(r => (this.authState.setError(r), this.authState.refresh(), Ur(r)))) } getAccessTokenWithPopup(n) { return T(this.auth0Client).pipe(mn(r => r.getTokenWithPopup(n)), Fe(r => { r && this.authState.setAccessToken(r) }), yn(r => (this.authState.setError(r), this.authState.refresh(), Ur(r)))) } handleRedirectCallback(n) { return Qo(() => this.auth0Client.handleRedirectCallback(n)).pipe(function u2(...e) { const t = Cp(e); return ke((n, r) => { const o = e.length, i = new Array(o); let s = e.map(() => !1), a = !1; for (let c = 0; c < o; c++)Wt(e[c]).subscribe(Se(r, u => { i[c] = u, !a && !s[c] && (s[c] = !0, (a = s.every(Rn)) && (s = null)) }, j)); n.subscribe(Se(r, c => { if (a) { const u = [c, ...i]; r.next(t ? t(...u) : u) } })) }) }(this.authState.isLoading$), Fe(([r, o]) => { o || this.authState.refresh(); const i = r?.appState, s = i?.target ?? "/"; i && this.appStateSubject$.next(i), this.navigator.navigateByUrl(s) }), H(([r]) => r)) } shouldHandleCallback() { return T(location.search).pipe(H(n => { const r = new URLSearchParams(n); return (r.has("code") || r.has("error")) && r.has("state") && !this.configFactory.get().skipRedirectCallback })) } } return e.\u0275fac = function (n) { return new (n || e)(E(xu), E(Jh), E(x2), E(O2)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), Ou = (() => { class e { constructor(n) { this.auth = n } canLoad(n, r) { return this.auth.isAuthenticated$.pipe(Xo(1)) } canActivate(n, r) { return this.redirectIfUnauthenticated(r) } canActivateChild(n, r) { return this.redirectIfUnauthenticated(r) } redirectIfUnauthenticated(n) { return this.auth.isAuthenticated$.pipe(Fe(r => { r || this.auth.loginWithRedirect({ appState: { target: n.url } }) })) } } return e.\u0275fac = function (n) { return new (n || e)(E(vi)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), P2 = (() => { class e { static forRoot(n) { return { ngModule: e, providers: [vi, Ou, { provide: Xh, useValue: n }, { provide: xu, useFactory: Yb.createClient, deps: [Jh] }] } } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = $n({ type: e }), e.\u0275inj = _n({}), e })(), k2 = (() => { class e { constructor(n) { this.auth = n } ngOnInit() { } loginWithRedirect() { this.auth.loginWithRedirect() } } return e.\u0275fac = function (n) { return new (n || e)(S(vi)) }, e.\u0275cmp = ot({ type: e, selectors: [["app-login-button"]], inputs: { buttonText: "buttonText" }, decls: 2, vars: 1, consts: [[1, "btn", "btn-default", "btn-xl", "wow", "tada", 3, "click"]], template: function (n, r) { 1 & n && (ee(0, "button", 0), pr("click", function () { return r.loginWithRedirect() }), De(1), Q()), 2 & n && (A(1), zo(" ", r.buttonText, " ")) }, encapsulation: 2 }), e })(), A2 = (() => { class e { constructor(n, r) { this.auth = n, this.doc = r } ngOnInit() { } logout() { this.auth.logout() } } return e.\u0275fac = function (n) { return new (n || e)(S(vi), S(it)) }, e.\u0275cmp = ot({ type: e, selectors: [["app-logout-button"]], decls: 2, vars: 0, consts: [[1, "btn", "btn-default", "btn-xl", "wow", "tada", 3, "click"]], template: function (n, r) { 1 & n && (ee(0, "button", 0), pr("click", function () { return r.logout() }), De(1, " Log out\n"), Q()) }, encapsulation: 2 }), e })(); function R2(e, t) { 1 & e && me(0, "app-login-button", 2), 2 & e && J("buttonText", ft().buttonText) } function N2(e, t) { 1 & e && me(0, "app-logout-button") } let F2 = (() => { class e { constructor(n) { this.auth = n } } return e.\u0275fac = function (n) { return new (n || e)(S(vi)) }, e.\u0275cmp = ot({ type: e, selectors: [["app-auth-button"]], inputs: { buttonText: "buttonText" }, decls: 4, vars: 6, consts: [[3, "buttonText", 4, "ngIf"], [4, "ngIf"], [3, "buttonText"]], template: function (n, r) { 1 & n && (we(0, R2, 1, 1, "app-login-button", 0), Hd(1, "async"), we(2, N2, 1, 0, "app-logout-button", 1), Hd(3, "async")), 2 & n && (J("ngIf", !1 === zd(1, 2, r.auth.isAuthenticated$)), A(2), J("ngIf", zd(3, 4, r.auth.isAuthenticated$))) }, dependencies: [fs, k2, A2, LC], encapsulation: 2 }), e })(), L2 = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = ot({ type: e, selectors: [["app-aside"]], inputs: { aside: "aside" }, decls: 6, vars: 6, consts: [[1, "bg-dark", 3, "id"], [1, "container", "text-center"], [3, "buttonText"]], template: function (n, r) { 1 & n && (ee(0, "aside", 0)(1, "div", 1)(2, "div")(3, "h2"), De(4), Q(), me(5, "app-auth-button", 2), Q()()()), 2 & n && (Zn("id", r.aside.key), A(2), za(r.aside.key), A(2), et(r.aside.title.text), A(1), J("buttonText", r.aside.buttonText.text)) }, dependencies: [F2], encapsulation: 2 }), e })(); function j2(e, t) { if (1 & e && (ee(0, "div")(1, "a", 7), me(2, "i", 8), ee(3, "p"), De(4), Q()()()), 2 & e) { const n = t.$implicit; Wa("col-lg-2 col-lg-offset-", 0 == t.index ? 2 : 1, " text-center"), A(1), Zn("href", n.link, zn), A(1), Wa("fa ", n.icon, " fa-3x wow bounceIn"), A(2), et(n.title.text) } } let $2 = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = ot({ type: e, selectors: [["app-contact"]], inputs: { contact: "contact" }, decls: 10, vars: 4, consts: [[3, "id"], [1, "container"], [1, "row"], [1, "col-lg-8", "col-lg-offset-2", "text-center"], [1, "section-heading"], [1, "primary"], [3, "class", 4, "ngFor", "ngForOf"], [3, "href"], ["data-wow-delay", ".1s"]], template: function (n, r) { 1 & n && (ee(0, "section", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "h2", 4), De(5), Q(), me(6, "hr", 5), ee(7, "p"), De(8), Q()(), we(9, j2, 5, 8, "div", 6), Q()()()), 2 & n && (Zn("id", r.contact.key), A(5), et(r.contact.title.text), A(3), et(r.contact.text.text), A(1), J("ngForOf", r.contact.boxItems)) }, dependencies: [Yo], encapsulation: 2 }), e })(); function U2(e, t) { 1 & e && me(0, "app-header", 7), 2 & e && J("header", ft().getHeader()) } function V2(e, t) { 1 & e && me(0, "app-call-to-action", 8), 2 & e && J("cta", ft().getCallToAction()) } function B2(e, t) { 1 & e && me(0, "app-services", 9), 2 & e && J("services", ft().getServices()) } function H2(e, t) { 1 & e && me(0, "app-portfolio", 10), 2 & e && J("portfolio", ft().getPortfolio()) } function z2(e, t) { 1 & e && me(0, "app-aside", 11), 2 & e && J("aside", ft().getAside()) } function q2(e, t) { 1 & e && me(0, "app-contact", 12), 2 & e && J("contact", ft().getContact()) } let ep = (() => { class e { constructor(n, r, o) { this.router = n, this.homePageService = r, this.spinnerService = o } ngOnInit() { this.spinnerService.start(), this.homePageService.getHomePage().then(n => { this.homePage = n, this.header = this.homePage.content.filter(r => "header" == r.key)[0], this.call_to_action = this.homePage.content.filter(r => "call_to_action" == r.key)[0], this.services = this.homePage.content.filter(r => "services" == r.key)[0], this.portfolio = this.homePage.content.filter(r => "portfolio" == r.key)[0], this.aside = this.homePage.content.filter(r => "aside" == r.key)[0], this.contact = this.homePage.content.filter(r => "contact" == r.key)[0], this.isDataLoaded = !0 }).catch(n => { console.log("API ERROR: 2"), console.log(n) }) } isLoaded() { return this.isDataLoaded && this.spinnerService.stop(), this.isDataLoaded } getHeader() { return this.header } getCallToAction() { return this.call_to_action } getServices() { return this.services } getPortfolio() { return this.portfolio } getAside() { return this.aside } getContact() { return this.contact } } return e.\u0275fac = function (n) { return new (n || e)(S(Ke), S(PL), S(Ab)) }, e.\u0275cmp = ot({ type: e, selectors: [["app-front"]], decls: 8, vars: 6, consts: [["fgsColor", "#F05F40"], [3, "header", 4, "ngIf"], [3, "cta", 4, "ngIf"], [3, "services", 4, "ngIf"], [3, "portfolio", 4, "ngIf"], [3, "aside", 4, "ngIf"], [3, "contact", 4, "ngIf"], [3, "header"], [3, "cta"], [3, "services"], [3, "portfolio"], [3, "aside"], [3, "contact"]], template: function (n, r) { 1 & n && (me(0, "ngx-ui-loader", 0)(1, "app-nav"), we(2, U2, 1, 1, "app-header", 1), we(3, V2, 1, 1, "app-call-to-action", 2), we(4, B2, 1, 1, "app-services", 3), we(5, H2, 1, 1, "app-portfolio", 4), we(6, z2, 1, 1, "app-aside", 5), we(7, q2, 1, 1, "app-contact", 6)), 2 & n && (A(2), J("ngIf", r.isLoaded() && r.getHeader().display), A(1), J("ngIf", r.isLoaded() && r.getCallToAction().display), A(1), J("ngIf", r.isLoaded() && r.getServices().display), A(1), J("ngIf", r.isLoaded() && r.getPortfolio().display), A(1), J("ngIf", r.isLoaded() && r.getAside().display), A(1), J("ngIf", r.isLoaded() && r.getContact().display)) }, dependencies: [fs, GL, XL, JL, e2, n2, o2, L2, $2], encapsulation: 2 }), e })(); const W2 = [{ path: "demo", component: (() => { class e { constructor() { } ngOnInit() { } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = ot({ type: e, selectors: [["app-demo"]], decls: 2, vars: 0, template: function (n, r) { 1 & n && (ee(0, "p"), De(1, "demo works!"), Q()) } }), e })(), canActivate: [Ou] }, { path: "en", component: ep }, { path: "bg", component: ep }, { path: "**", component: ep }]; let G2 = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = $n({ type: e }), e.\u0275inj = _n({ imports: [D0.forRoot(W2), D0] }), e })(), Z2 = (() => { class e { constructor() { this.title = "gbaby_tech_ui_v01" } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = ot({ type: e, selectors: [["app-root"]], decls: 1, vars: 0, template: function (n, r) { 1 & n && me(0, "router-outlet") }, dependencies: [fh], encapsulation: 2 }), e })(), K2 = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = $n({ type: e, bootstrap: [Z2] }), e.\u0275inj = _n({ imports: [gA, G2, ZL, P2.forRoot({ domain: "dev-q2vwn6qu.us.auth0.com", clientId: "jVUO6vnw3tssv9w3OK8eQ5oJLlmS0DBC", authorizationParams: { redirect_uri: window.location.origin } })] }), e })(); (function kO() { iC = !1 })(), pA().bootstrapModule(K2).catch(e => console.error(e)) }, 455: (Ot, le, Ve) => { le.formatArgs = function ve(re) { if (re[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + re[0] + (this.useColors ? "%c " : " ") + "+" + Ot.exports.humanize(this.diff), !this.useColors) return; const Le = "color: " + this.color; re.splice(1, 0, Le, "color: inherit"); let B = 0, oe = 0; re[0].replace(/%[a-zA-Z%]/g, Oe => { "%%" !== Oe && (B++, "%c" === Oe && (oe = B)) }), re.splice(oe, 0, Le) }, le.save = function qt(re) { try { re ? le.storage.setItem("debug", re) : le.storage.removeItem("debug") } catch { } }, le.load = function I() { let re; try { re = le.storage.getItem("debug") } catch { } return !re && typeof process < "u" && "env" in process && (re = process.env.DEBUG), re }, le.useColors = function V() { return !(!(typeof window < "u" && window.process) || "renderer" !== window.process.type && !window.process.__nwjs) || !(typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && (typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)) }, le.storage = function Me() { try { return localStorage } catch { } }(), le.destroy = (() => { let re = !1; return () => { re || (re = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")) } })(), le.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], le.log = console.debug || console.log || (() => { }), Ot.exports = Ve(283)(le); const { formatters: nn } = Ot.exports; nn.j = function (re) { try { return JSON.stringify(re) } catch (Le) { return "[UnexpectedJSONParseError]: " + Le.message } } }, 283: (Ot, le, Ve) => { Ot.exports = function V(ve) { function I(j) { let ie, ro, oo, Pe = null; function Xe(...rt) { if (!Xe.enabled) return; const kn = Xe, rr = Number(new Date); kn.diff = rr - (ie || rr), kn.prev = ie, kn.curr = rr, ie = rr, rt[0] = I.coerce(rt[0]), "string" != typeof rt[0] && rt.unshift("%O"); let or = 0; rt[0] = rt[0].replace(/%([a-zA-Z%])/g, (An, io) => { if ("%%" === An) return "%"; or++; const Ws = I.formatters[io]; return "function" == typeof Ws && (An = Ws.call(kn, rt[or]), rt.splice(or, 1), or--), An }), I.formatArgs.call(kn, rt), (kn.log || I.log).apply(kn, rt) } return Xe.namespace = j, Xe.useColors = I.useColors(), Xe.color = I.selectColor(j), Xe.extend = Me, Xe.destroy = I.destroy, Object.defineProperty(Xe, "enabled", { enumerable: !0, configurable: !1, get: () => null !== Pe ? Pe : (ro !== I.namespaces && (ro = I.namespaces, oo = I.enabled(j)), oo), set: rt => { Pe = rt } }), "function" == typeof I.init && I.init(Xe), Xe } function Me(j, ie) { const Pe = I(this.namespace + (typeof ie > "u" ? ":" : ie) + j); return Pe.log = this.log, Pe } function B(j) { return j.toString().substring(2, j.toString().length - 2).replace(/\.\*\?$/, "*") } return I.debug = I, I.default = I, I.coerce = function oe(j) { return j instanceof Error ? j.stack || j.message : j }, I.disable = function re() { const j = [...I.names.map(B), ...I.skips.map(B).map(ie => "-" + ie)].join(","); return I.enable(""), j }, I.enable = function nn(j) { let ie; I.save(j), I.namespaces = j, I.names = [], I.skips = []; const Pe = ("string" == typeof j ? j : "").split(/[\s,]+/), ro = Pe.length; for (ie = 0; ie < ro; ie++)!Pe[ie] || ("-" === (j = Pe[ie].replace(/\*/g, ".*?"))[0] ? I.skips.push(new RegExp("^" + j.slice(1) + "$")) : I.names.push(new RegExp("^" + j + "$"))) }, I.enabled = function Le(j) { if ("*" === j[j.length - 1]) return !0; let ie, Pe; for (ie = 0, Pe = I.skips.length; ie < Pe; ie++)if (I.skips[ie].test(j)) return !1; for (ie = 0, Pe = I.names.length; ie < Pe; ie++)if (I.names[ie].test(j)) return !0; return !1 }, I.humanize = Ve(366), I.destroy = function Oe() { console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.") }, Object.keys(ve).forEach(j => { I[j] = ve[j] }), I.names = [], I.skips = [], I.formatters = {}, I.selectColor = function qt(j) { let ie = 0; for (let Pe = 0; Pe < j.length; Pe++)ie = (ie << 5) - ie + j.charCodeAt(Pe), ie |= 0; return I.colors[Math.abs(ie) % I.colors.length] }, I.enable(I.load()), I } }, 366: Ot => { var le = 1e3, Ve = 6e4, V = 60 * Ve, ve = 24 * V; function Le(B, oe, Oe, j) { var ie = oe >= 1.5 * Oe; return Math.round(B / Oe) + " " + j + (ie ? "s" : "") } Ot.exports = function (B, oe) { oe = oe || {}; var Oe = typeof B; if ("string" === Oe && B.length > 0) return function Me(B) { if (!((B = String(B)).length > 100)) { var oe = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(B); if (oe) { var Oe = parseFloat(oe[1]); switch ((oe[2] || "ms").toLowerCase()) { case "years": case "year": case "yrs": case "yr": case "y": return 315576e5 * Oe; case "weeks": case "week": case "w": return 6048e5 * Oe; case "days": case "day": case "d": return Oe * ve; case "hours": case "hour": case "hrs": case "hr": case "h": return Oe * V; case "minutes": case "minute": case "mins": case "min": case "m": return Oe * Ve; case "seconds": case "second": case "secs": case "sec": case "s": return Oe * le; case "milliseconds": case "millisecond": case "msecs": case "msec": case "ms": return Oe; default: return } } } }(B); if ("number" === Oe && isFinite(B)) return oe.long ? function re(B) { var oe = Math.abs(B); return oe >= ve ? Le(B, oe, ve, "day") : oe >= V ? Le(B, oe, V, "hour") : oe >= Ve ? Le(B, oe, Ve, "minute") : oe >= le ? Le(B, oe, le, "second") : B + " ms" }(B) : function nn(B) { var oe = Math.abs(B); return oe >= ve ? Math.round(B / ve) + "d" : oe >= V ? Math.round(B / V) + "h" : oe >= Ve ? Math.round(B / Ve) + "m" : oe >= le ? Math.round(B / le) + "s" : B + "ms" }(B); throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(B)) } }, 689: Ot => { var le = function (V) { return V.replace(/^\s+|\s+$/g, "") }, Ve = function (V) { return "[object Array]" === Object.prototype.toString.call(V) }; Ot.exports = function (V) { if (!V) return {}; for (var ve = {}, qt = le(V).split("\n"), I = 0; I < qt.length; I++) { var Me = qt[I], nn = Me.indexOf(":"), re = le(Me.slice(0, nn)).toLowerCase(), Le = le(Me.slice(nn + 1)); typeof ve[re] > "u" ? ve[re] = Le : Ve(ve[re]) ? ve[re].push(Le) : ve[re] = [ve[re], Le] } return ve } } }, Ot => { Ot(Ot.s = 296) }]);